Model FoodFastModel ; 
package FoodFast.types { 
	value type Int { } 
	value type Boolean { } 
	value type String { } 
	value type Void { } 
	value type Real { }
datatype Date { attributes : Day : Int ; Month : Int ; Year : Int ; } datatype Time { attributes : Second : Int ; Minute : Int ; Hour : Int ; } datatype DateTime { attributes : Date : Date ; Time : Time ; } datatype CredentialAccess { attributes : CPF : String ; Password : String ; } datatype UserData { attributes : UserId : String ; Name : String ; Email : String ; Phone : String ; BirthDate : Date ; } enum RegisterStatus { Success , WeakPassword , EmailExists } datatype AuthResult { attributes : Success : Boolean ; Token : String ; User : UserData ; ExpiresIn : DateTime ; } datatype CardData { attributes : CardId : String ; CardNumber : String ; CardHolderName : String ; ExpirationMonth : Int ; ExpirationYear : Int ; CVV : Int ; Method : PaymentMethod ; } enum PaymentMethod { DebitCard , CreditCard } enum ChargeSituation { Paid , Failure } datatype ChargeRequest { attributes : UserId : String ; OrderId : String ; TotalAmount : Real ; } datatype ChargeResponse { attributes : Situation : ChargeSituation ; OrderId : String ; } datatype RegisterCardRequest { attributes : UserId : String ; Card : CardData ; } datatype RegisterCardResponse { attributes : PaymentMethodId : String ; Success : Boolean ; } enum BiometricAuthMethod { Face , FingerPrint } datatype BiometricAuthRequest { attributes : Method : BiometricAuthMethod ; BiometricHash : String ; } datatype BiometricAuthResponse { attributes : UserId : String ; Success : Boolean ; SessionToken : String ; } datatype RegisterBiometricAuthRequest { attributes : UserId : String ; Method : BiometricAuthMethod ; BiometricHash : String ; } datatype RegisterBiometricAuthResponse { attributes : Success : Boolean ; } enum OrderStatus { OnHold , InPreparation , Ready , Withdrawn , Canceled } datatype UpdateOrderStatus { attributes : OrderId : String ; NewStatus : OrderStatus ; } datatype OrderRequest { attributes : Order : OrderData ; UserId : String ; DeliveryLocation : String ; } datatype OrderData { attributes : OrderId : String ; ItemsId : ListOfString ; TotalAmount : Real ; Timestamp : DateTime ; } value type ListOfString { unit = List } unit List datatype MenuItem { attributes : ItemId : String ; Name : String ; Price : Real ; Available : Int ; } } 
Requirement ManageUsersFR ( 1 ) { text = "\"O sistema deve permitir o gerenciamento de usuários.\"" 

Requirement RegisterUserFR ( 1.1 ) { text = "\"O sistema deve permitir que o usuário realize o cadastro no sistema com todos dados necessários.\"" 

Requirement RegisterPersonalInfoFR ( 1.1.1 ) { text = "\"O sistema precisa ser capaz de cadastrar informações pessoais do usuário.\"" } 

Requirement RegisterPaymentMethodsFR ( 1.1.2 ) { text = "\"O usuário deve cadastar os métodos de pagamentos.\"" } }

Requirement AuthenticateWithCPFFR ( 1.3 ) { text = "\"O sistema deve permitir que o usuário se autentique em sua conta com CPF e senha registrados.\"" } 
 
Requirement AuthenticateWithBiometricsFR ( 1.4 ) { text = "\"O sistema deve permitir que o usuário se autentique por meio de reconhecimento facial ou digital.\"" derive MonitorInvoicesFR.ManageOrdersFR.AuthenticateOrderFR ; 

Requirement RecognizeFaceFR ( 1.4.1 )  { text = "\"O usuário poderá registrar sua face no sistema que deve ser capaz de identifica-lo sem erros.\"" Requirement CaptureFaceFR ( 1.4.1.1 ) 
{ text = "\"O sensor de facial deve coletar corretamente a face em análise.\"" } Requirement IdentifyFaceFR ( 1.4.1.2 ) 
{ text = "\"O servidor deve receber a face coletada pelo sensor e reconhecer corretamente quem está utilizando.\"" } } Requirement RecognizeFingerprintFR ( 1.4.2 ) 
{ text = "\"O usuário poderá registrar sua digital no sistema que deve ser capaz de identifica-lo sem erros.\"" Requirement CaptureFingerprintFR ( 1.4.2.1 ) 
{ text = "\"O sensor de digital deve coletar corretamente a digital sobre ele.\"" } Requirement IdentifyFingerprintFR ( 1.4.2.2 ) 
{ text = "\"O servidor deve receber a digital coletada pelo sensor e reconhecer corretamente quem está utilizando.\"" } }  } } Requirement UpdateUserFR ( 1.2 ) 
{ text = "\"O sistema deve permitir que o usuário realize atualize a conta no sistema com todos dados necessários.\"" derive ManageUsersFR.RegisterUserFR ; } Requirement MonitorInvoicesFR ( 3 ) 
{ text = "\"O sistema deve ser capaz de monitorar o valor total das faturas de cada cliente, agrupando-as por dia de consumo.\"" Requirement IdentifyInvoiceDateFR ( 3.1 ) 
{ text = "\"O sistema deve identificar corretamente a data de cada fatura com base no horário local do restaurante.\"" } Requirement ManageOrdersFR ( 2 ) 
{ text = "\"O sistema deve ser capaz de  reconhecer e gerenciar os pedidos do usuário.\"" Requirement AuthenticateOrderFR ( 2.1 ) 
{ text = "\"O sistema deve reconhecer o usuário que está relizando pedido.\"" } Requirement ProcessOrdersFR ( 2.2 ) 
{ text = "\"O sistema deve permitir o gerenciamento de pedidos nas mais diversas máquinas e realizar a cobrança automática no método de pagamento registrado.\"" Requirement SelectPreparedFoodFR ( 2.2.1 ) 
{ text = "\"O usuário deve ser capaz de selecionar uma comida a ser preparada no cardápio exibido nos totens e ser capaz de retira-la em um ponto de coleta.\"" } Requirement DispenseCannedBeverage ( 2.2.2 ) 
{ text = "\"O usuário deve ser capaz de selecionar uma bebida em lata na máquina de bebidas e recebê-la.\"" } Requirement DispenseSnackFR ( 2.2.3 ) 
{ text = "\"O usuário deve ser capaz de selecionar um lanche em máquina e recebê-lo.\"" }  Requirement PourBeverageFR ( 2.2.4 ) 
{ text = "\"O sistema deve permitir que o usuário encha copos de bebidas livremente em máquinas com terneiras e cobre pela quantidade de bebida depositada em ml.\"" } Requirement ChargeOrderFR ( 2.2.5 ) { text = "\"O sistema deve realizar cobrança automaticamente após o usuário concluir o pedido, a partir dos dados previamente cadastrados no sistema\"" } } } } 

Requirement MonitorMenuAvailabilityFR ( 2.2.1.3 ) { text = "\"O toten de pedido deve receber informações contínuas de quais alimentos estão disponíveis no cardápio.\"" derive MonitorInvoicesFR.ManageOrdersFR.ProcessOrdersFR.SelectPreparedFoodFR ; } 

Requirement MonitorInventoryFR ( 2.2.2.1 ) { text = "\"As máquinas devem ser capazes de monitorar o inventário de lanches e bebidas para evitar o pedido de alimentos não disponíveis.\"" derive MonitorInvoicesFR.ManageOrdersFR.ProcessOrdersFR.DispenseSnackFR , MonitorInvoicesFR.ManageOrdersFR.ProcessOrdersFR.DispenseCannedBeverage ; } 

Requirement CalculateBeverageCostFR ( 2.2.4.1 ) 
{ text = "\"O sistema deve calcular o valor da bebida baseado nos ml depositados.\"" derive MonitorInvoicesFR.ManageOrdersFR.ProcessOrdersFR.PourBeverageFR ; } Requirement RouteOrderFR ( 2.2.1.2.1 ) 
{ text = "\"Encaminhar automaticamente o pedido para a cozinha mais próxima disponível com base na localização do ponto de venda. \"" derive ManagePickupFR.OpenConveyorCompartmentFR.SeparateConveyorItemsFR.GenerateReceiptFR ; } Requirement MeasureBeverageFlowFR ( 2.2.4.1.1 ) 
{ text = "\"O sistema deve controlar a quantidade de bebida em ml que sai da máquina.\"" derive MonitorInvoicesFR.ManageOrdersFR.ProcessOrdersFR.PourBeverageFR ; } Requirement UpdateOrderStatusFR ( 2.2.1.1.1 ) 
{ text = "\"O sistema deve permitir registrar e atualizar o estado de cada pedido (por exemplo: “Em espera”, “Em preparação”, “Pronto para retirada”, “Retirado”), com histórico de alterações.\"" derive ManagePickupFR.TrackOrderFR ; } Requirement ManagePickupFR ( 4 ) 
{ text = "\"O sistema deve gerenciar de forma integrada todo o processo de retirada de pedidos nos pontos de coleta, incluindo exibição de códigos, identificação do usuário, atualização de status e operação da esteira automatizada.\"" Requirement OpenConveyorCompartmentFR ( 4.1 ) 
{ text = "\"O sistema deve permitir que, após a identificação do usuário, a esteira circular e fechada abra automaticamente o compartimento correspondente ao pedido para retirada.\"" Requirement SeparateConveyorItemsFR ( 4.1.2 ) { text = "\"O sistema deve organizar os pedidos na esteira de forma que cada compartimento esteja identificado com o código único do pedido.\"" Requirement GenerateReceiptFR ( 2.2.1.2 ) 
{ text = "\"Gerar nota fiscal ou comprovante contendo código de barras, número do pedido e número do ponto de coleta.\"" derive MonitorInvoicesFR.ManageOrdersFR.ProcessOrdersFR.SelectPreparedFoodFR ; } } Requirement ValidateConveyorDeliveryFR ( 4.1.3 ) { text = "\"O sistema deve garantir que, ao liberar o compartimento, o pedido entregue corresponda exatamente ao código e identificação do usuário.\"" Requirement MoveConveyorFR ( 4.1.3.1 ) 
{ text = "\"O sistema deve movimentar a esteira de forma automática para posicionar o compartimento correto na frente do usuário após a identificação.\"" } } Requirement IdentifyUserForPickupFR ( 4.1.1 ) 
{ text = "\"A retirada do pedido só poderá ser realizada mediante a identificação do usuário por reconhecimento facial, digital ou pela apresentação da nota fiscal do pedido.\"" derive VerifyBarcodeFR , ManageUsersFR.AuthenticateWithBiometricsFR ; } } Requirement TrackOrderFR ( 2.2.1.1 ) 
{ text = "\"O sistema deve disponibilizar uma tela de acompanhamento que apresente ao usuário a lista de pedidos, indicando o status como “em preparo” ou “finalizado”.\"" derive MonitorInvoicesFR.ManageOrdersFR.ProcessOrdersFR.SelectPreparedFoodFR ; } } Requirement VerifyBarcodeFR ( 4.1.1.1.1 ) 
{ text = "\"O pedido do usuário poderá ser identificado pelo código de barras emitido na nota.\"" Requirement IdentifyInvoiceFR ( 4.1.1.1.2 ) 
{ text = "\"O servidor deve receber o código de barras pelo sensor e reconhecer corretamente o pedido.\"" } Requirement CaptureBarcodeFR ( 4.1.1.1.3 ) 
{ text = "text=\"O sensor de código de barras deve coletar corretamente a código digitalizado na frente dele.\"" } } package FoodFastComponents { import FoodFast.types ; import FoodFastPorts ; import FoodFastConnectors ; component def UserServerCP { configuration { components : RegisterUserDataFrontendCP : RegisterUserDataFrontendCP { using ports : userUF : UserDataIPT ; updateUserRequestUF : UserDataOPT ; } RegisterUserDataServiceCP : RegisterUserDataServiceCP { using ports : userUS : UserDataOPT ; updateUserRequestUS : UserDataIPT ; } RegisterUserAuthFrontendCP : RegisterUserAuthFrontendCP { using ports : registerCredentialsUF : CredentialAccessOPT ; registerCredentialsStatusUF : RegisterStatusIPT ; } RegisterUserAuthServiceCP : RegisterUserAuthServiceCP { using ports : registerCredentialsUS : CredentialAccessIPT ; registerCredentialsStatusUS : UserDataOPT ; } AuthUserServiceCP : AuthUserServiceCP { using ports : authUserUS : CredentialAccessIPT ; authUserResultUS : AuthResultOPT ; } AuthUserFrontendCP : AuthUserFrontendCP { using ports : authUserUF : CredentialAccessOPT ; authUserResultUF : AuthResultIPT ; } connectors : user : UserDataCN bindings userUS = userUF ; updateUserRequest : UserDataCN bindings updateUserRequestUF = updateUserRequestUS ; registerCredentials : CredentialAccessCN bindings registerCredentialsUF = registerCredentialsUS ; registerCredentialsStatus : RegisterStatusCN bindings registerCredentialsStatusUS = registerCredentialsStatusUF ; credentials : CredentialAccessCN bindings authUserUF = authUserUS ; authResult : AuthResultCN bindings authUserResultUS = authUserResultUF ; } } boundary
	component def RegisterUserDataFrontendCP { ports : userUF : UserDataIPT ; updateUserRequestUF : UserDataOPT ; } boundary
	component def RegisterUserDataServiceCP { ports : userUS : UserDataOPT ; updateUserRequestUS : UserDataIPT ; } boundary
	component def RegisterUserAuthFrontendCP { ports : registerCredentialsUF : CredentialAccessOPT ; registerCredentialsStatusUF : RegisterStatusIPT ; } boundary
	component def RegisterUserAuthServiceCP { ports : registerCredentialsUS : CredentialAccessIPT ; registerCredentialsStatusUS : UserDataOPT ; } boundary
	component def AuthUserFrontendCP { ports : authUserUF : CredentialAccessOPT ; authUserResultUF : AuthResultIPT ; } boundary
	component def AuthUserServiceCP { ports : authUserUS : CredentialAccessIPT ; authUserResultUS : AuthResultOPT ; }
	component def PaymentServerCP { configuration { components : PaymentMethodRegisterServiceCP : PaymentMethodRegisterServiceCP { using ports : registerCardRequestPS : RegisterCardRequestIPT ; registerCardResponsePS : RegisterCardResponseOPT ; } PaymentMethodRegisterFrontendCP : PaymentMethodRegisterFrontendCP { using ports : registerCardRequestPF : RegisterCardRequestOPT ; registerCardResponsePF : RegisterCardResponseIPT ; } ChargeServiceCP : ChargeServiceCP { using ports : chargeRequestPS : ChargeRequestIPT ; chargeResponsePS : ChargeResponseOPT ; } connectors : RegisterCardRequest : RegisterCardRequestCN bindings registerCardRequestPF = registerCardRequestPS ; RegisterCardResponse : RegisterCardResponseCN bindings registerCardResponsePS = registerCardResponsePF ; } } boundary
	component def PaymentMethodRegisterFrontendCP { ports : registerCardRequestPF : RegisterCardRequestOPT ; registerCardResponsePF : RegisterCardResponseIPT ; } boundary
	component def PaymentMethodRegisterServiceCP { ports : registerCardRequestPS : RegisterCardRequestIPT ; registerCardResponsePS : RegisterCardResponseOPT ; } boundary
	component def ChargeServiceCP { ports : chargeRequestPS : ChargeRequestIPT ; chargeResponsePS : ChargeResponseOPT ; }
	component def BiometricAuthServerCP { ports :  configuration { components : RegisterBiometricFrontendCP : RegisterBiometricFrontendCP { using ports : registerBiometricRequestBF : RegisterBiometricAuthRequestOPT ; registerBiometricResponseBF : RegisterBiometricAuthResponseIPT ; } RegisterBiometricServiceCP : RegisterBiometricServiceCP { using ports : registerBiometricRequestBS : RegisterBiometricAuthRequestIPT ; registerBiometricResponseBS : RegisterBiometricAuthResponseOPT ; } SensorFacialCP : SensorFacialCP { using ports : facialHashBSN : BiometricHashOPT ; } SensorFingerPrintCP : SensorFingerPrintCP { using ports : fingerPrintHashBSN : BiometricHashOPT ; } InterfaceAuthCP : InterfaceBiometricAuthCP { using ports : facialHashBI : BiometricHashIPT ; fingerPrintHashBI : BiometricHashIPT ; biometricAuthRequestBI : BiometricAuthRequestOPT ; biometricAuthResponseBI : BiometricAuthResponseIPT ; IdentifiedUserBI : UserDataOPT ; } AuthManagerServiceCP : BiometricAuthManagerServiceCP { using ports : biometricAuthRequestBM : BiometricAuthRequestIPT ; biometricAuthResponseBM : BiometricAuthResponseOPT ; } connectors : registerBiometricResponse : RegisterBiometricAuthResponseCN bindings registerBiometricResponseBS = registerBiometricResponseBF ; registerBiometricRequest : RegisterBiometricAuthRequestCN bindings registerBiometricRequestBF = registerBiometricRequestBS ; facialHash : BiometricHashCN bindings facialHashBSN = facialHashBI ; fingerPrintHash : BiometricHashCN bindings fingerPrintHashBSN = fingerPrintHashBI ; biometricAuthResponse : BiometricAuthResponseCN bindings biometricAuthResponseBM = biometricAuthResponseBI ; biometricAuthRequest : BiometricAuthRequestCN bindings biometricAuthRequestBI = biometricAuthRequestBM ; delegations :  } } boundary
	component def RegisterBiometricFrontendCP { ports : registerBiometricRequestBF : RegisterBiometricAuthRequestOPT ; registerBiometricResponseBF : RegisterBiometricAuthResponseIPT ; } boundary
	component def RegisterBiometricServiceCP { ports : registerBiometricRequestBS : RegisterBiometricAuthRequestIPT ; registerBiometricResponseBS : RegisterBiometricAuthResponseOPT ; } boundary
	component def SensorFacialCP { ports : facialHashBSN : BiometricHashOPT ; } boundary
	component def SensorFingerPrintCP { ports : fingerPrintHashBSN : BiometricHashOPT ; }
	component def InterfaceBiometricAuthCP { ports : facialHashBI : BiometricHashIPT ; fingerPrintHashBI : BiometricHashIPT ; biometricAuthRequestBI : BiometricAuthRequestOPT ; biometricAuthResponseBI : BiometricAuthResponseIPT ; IdentifiedUserBI : UserDataOPT ; } boundary
	component def BiometricAuthManagerServiceCP { ports : biometricAuthRequestBM : BiometricAuthRequestIPT ; biometricAuthResponseBM : BiometricAuthResponseOPT ; } component def OrderServerCP { ports :  configuration { components : OrderManagerServiceCP : OrderManagerServiceCP { using ports : chargeRequestOS : ChargeRequestOPT ; chargeResponseOS : ChargeResponseIPT ; orderRequestOS : OrderRequestIPT ; orderStatusOS : OrderStatusOPT ; updateOrderStatusOS : OrderStatusIPT ; kitchenOrdersOS : OrderDataOPT ; } UpdateOrderFrontendCP : UpdateOrderFrontendCP { using ports : updateOrderStatusOF : OrderStatusOPT ; } KitchenOrdersFrontendCP : KitchenOrdersFrontendCP [ 1 , 10 ] { using ports : kitchenOrdersOF : OrderDataIPT ; }  BarCodePrinter : BarCodePrinter [ 1 , 10 ] { using ports : barCodeOrderIdOP : BarCodeIPT ; } DigitalClockCP : DigitalClockCP [ 1 , 10 ] { using ports : timestamp : DateTimeOPT ; } TotemCP : TotemCP [ 1 , 10 ] { using ports : barCodeOrderIdOT : BarCodeOPT ; timestampOT : DateTimeIPT ; orderRequestOT : OrderRequestOPT ; orderStatusOT : OrderStatusIPT ; authenticatedUserOT : UserDataIPT ; menuOT : MenuItemIPT ; purchasedItemsOT : UserDataOPT ; } MenuItemServiceCP : MenuItemServiceCP { using ports : menuMS : MenuItemOPT ; purchasedItemsMS : OrderDataIPT ; } ChargeServiceCP : ChargeServiceCP { using ports : chargeRequestPS : ChargeRequestIPT ; chargeResponsePS : ChargeResponseOPT ; } DispenserFoodMachineCP : DispenserFoodMachineCP [ 1 , 10 ] { using ports : authenticatedUserOD : UserDataIPT ; orderRequestOD : OrderRequestOPT ; orderStatusOD : OrderStatusIPT ; } PourBeverageCP : PourBeverageCP [ 1 , 10 ] { using ports : authenticatedUserOP : UserDataIPT ; orderRequestOP : OrderRequestOPT ; orderStatusOP : OrderStatusIPT ; } connectors : updateOrderStatus : OrderStatusCN bindings updateOrderStatusOF = updateOrderStatusOS ; kitchenOrders : MenuCN bindings kitchenOrdersOS = kitchenOrdersOF ;     barCodeOrderTotem : BarCodeCN bindings barCodeOrderIdOT = barCodeOrderIdOP ; timestampOrderTotem : DateTimeCN bindings timestamp = timestampOT ; orderRequestTotem : OrderRequestCN bindings orderRequestOT = orderRequestOS ; orderResultTotem : OrderStatusCN bindings orderStatusOS = orderStatusOT ; purchasedItems : KitchenOrdersCN bindings purchasedItemsOT = purchasedItemsMS ; menuTotem : MenuCN bindings menuMS = menuOT ; chargeRequest : OrderRequestCN bindings chargeRequestOS = chargeRequestPS ; chargedOrderResult : OrderStatusCN bindings chargeResponsePS = chargeResponseOS ; orderRequestDispenser : OrderRequestCN bindings orderRequestOD = orderRequestOS ; orderResultDispenser : OrderStatusCN bindings orderStatusOS = orderStatusOD ; orderRequestPour : OrderRequestCN bindings orderRequestOP = orderRequestOS ; orderResultPour : OrderStatusCN bindings orderStatusOS = orderStatusOP ; } }
	component def OrderManagerServiceCP { ports : chargeRequestOS : ChargeRequestOPT ; chargeResponseOS : ChargeResponseIPT ; orderRequestOS : OrderRequestIPT ; orderStatusOS : OrderStatusOPT ; updateOrderStatusOS : OrderStatusIPT ; kitchenOrdersOS : OrderDataOPT [ 0 , 999 ] ; } boundary
	component def UpdateOrderFrontendCP { ports : updateOrderStatusOF : OrderStatusOPT ; } boundary
	component def KitchenOrdersFrontendCP { ports : kitchenOrdersOF : OrderDataIPT [ 0 , 999 ] ; } boundary
	component def DigitalClockCP { ports : timestamp : DateTimeOPT ; } boundary
	component def MenuItemServiceCP { ports : menuMS : MenuItemOPT [ 0 , 999 ] ; purchasedItemsMS : OrderDataIPT ; }
	component def TotemCP { ports : barCodeOrderIdOT : BarCodeOPT ; timestampOT : DateTimeIPT ; orderRequestOT : OrderRequestOPT ; orderStatusOT : OrderStatusIPT ; authenticatedUserOT : UserDataIPT ; menuOT : MenuItemIPT [ 0 , 999 ] ; purchasedItemsOT : UserDataOPT ; component def TotemCP { ports : barCodeOrderIdOT : BarCodeOPT ; timestampOT : DateTimeIPT ; orderRequestOT : OrderRequestOPT ; orderStatusOT : OrderStatusIPT ; authenticatedUserOT : UserDataIPT ; menuOT : MenuItemIPT [ 0 , 999 ] ; purchasedItemsOT : UserDataOPT ; configuration { components : InterfaceBiometricAuthCP : InterfaceBiometricAuthCP { using ports : facialHashBI : BiometricHashIPT ; fingerPrintHashBI : BiometricHashIPT ; biometricAuthRequestBI : BiometricAuthRequestOPT ; biometricAuthResponseBI : BiometricAuthResponseIPT ; IdentifiedUserBI : UserDataOPT ; } delegations : IdentifiedUserBI to authenticatedUserOT } } configuration { components : InterfaceBiometricAuthCP : InterfaceBiometricAuthCP { using ports : facialHashBI : BiometricHashIPT ; fingerPrintHashBI : BiometricHashIPT ; biometricAuthRequestBI : BiometricAuthRequestOPT ; biometricAuthResponseBI : BiometricAuthResponseIPT ; IdentifiedUserBI : UserDataOPT ; } delegations : IdentifiedUserBI to authenticatedUserOT } } boundary
	component def BarCodePrinter { ports : barCodeOrderIdOP : BarCodeIPT ; } component def DispenserFoodMachineCP { ports : authenticatedUserOD : UserDataIPT ; orderRequestOD : OrderRequestOPT ; orderStatusOD : OrderStatusIPT ; configuration { components : InterfaceBiometricAuthCP : InterfaceBiometricAuthCP { using ports : facialHashBI : BiometricHashIPT ; fingerPrintHashBI : BiometricHashIPT ; biometricAuthRequestBI : BiometricAuthRequestOPT ; biometricAuthResponseBI : BiometricAuthResponseIPT ; IdentifiedUserBI : UserDataOPT ; } delegations : IdentifiedUserBI to authenticatedUserOD } }
	component def PourBeverageCP { ports : authenticatedUserOP : UserDataIPT ; orderRequestOP : OrderRequestOPT ; orderStatusOP : OrderStatusIPT ; configuration { components : InterfaceBiometricAuthCP : InterfaceBiometricAuthCP { using ports : facialHashBI : BiometricHashIPT ; fingerPrintHashBI : BiometricHashIPT ; biometricAuthRequestBI : BiometricAuthRequestOPT ; biometricAuthResponseBI : BiometricAuthResponseIPT ; IdentifiedUserBI : UserDataOPT ; } BeverageFlowControllerCP : BeverageFlowControllerCP { using ports : orderBeverageRequest : OrderRequestOPT ; } delegations : IdentifiedUserBI to authenticatedUserOP orderBeverageRequest to orderRequestOP } } boundary
	component def BeverageFlowControllerCP { ports : orderBeverageRequest : OrderRequestOPT ; } } package FoodFastPorts { import FoodFast.types ; port def CredentialAccessIPT { flow in CredentialAccess } port def CredentialAccessOPT { flow out CredentialAccess } port def RegisterStatusIPT { flow in RegisterStatus } port def RegisterStatusOPT { flow out RegisterStatus } port def AuthResultIPT { flow in AuthResult } port def AuthResultOPT { flow out AuthResult } port def UserDataIPT { flow in UserData } port def UserDataOPT { flow out UserData } port def ChargeRequestIPT { flow in ChargeRequest } port def ChargeRequestOPT { flow out ChargeRequest } port def ChargeResponseIPT { flow in ChargeResponse } port def ChargeResponseOPT { flow out ChargeResponse } port def RegisterCardRequestIPT { flow in RegisterCardRequest } port def RegisterCardRequestOPT { flow out RegisterCardRequest } port def RegisterCardResponseIPT { flow in RegisterCardResponse } port def RegisterCardResponseOPT { flow out RegisterCardResponse } port def RegisterBiometricAuthResponseIPT { flow in RegisterBiometricAuthResponse } port def RegisterBiometricAuthResponseOPT { flow out RegisterBiometricAuthResponse } port def RegisterBiometricAuthRequestIPT { flow in RegisterBiometricAuthRequest } port def RegisterBiometricAuthRequestOPT { flow out RegisterBiometricAuthRequest } port def BiometricAuthRequestIPT { flow in BiometricAuthRequest } port def BiometricAuthRequestOPT { flow out BiometricAuthRequest } port def BiometricHashIPT { flow in String } port def BiometricHashOPT { flow out String } port def BiometricAuthResponseIPT { flow in BiometricAuthResponse } port def BiometricAuthResponseOPT { flow out BiometricAuthResponse } port def OrderRequestIPT { flow in OrderRequest } port def OrderRequestOPT { flow out OrderRequest } port def OrderStatusIPT { flow in UpdateOrderStatus } port def OrderStatusOPT { flow out UpdateOrderStatus } port def OrderDataIPT { flow in OrderData } port def OrderDataOPT { flow out OrderData } port def MenuItemIPT { flow in MenuItem } port def MenuItemOPT { flow out MenuItem } port def DateTimeIPT { flow in DateTime } port def DateTimeOPT { flow out DateTime } port def BarCodeIPT { flow in String } port def BarCodeOPT { flow out String } } package FoodFastConnectors { import FoodFastPorts ; connector def AuthResultCN { participants : ~ destination : AuthResultIPT ; ~ source : AuthResultOPT ; flows : AuthResult from source to destination } connector def CredentialAccessCN { participants : ~ source : CredentialAccessOPT ; ~ destination : CredentialAccessIPT ; flows : CredentialAccess from source to destination } connector def RegisterStatusCN { participants : ~ source : RegisterStatusOPT ; ~ destination : RegisterStatusIPT ; flows : RegisterStatus from source to destination } connector def UserDataCN { participants : ~ source : UserDataOPT ; ~ destination : UserDataIPT ; flows : UserData from source to destination } connector def ChargeRequestCN { participants : ~ source : ChargeRequestOPT ; ~ destination : ChargeRequestIPT ; flows : ChargeRequest from source to destination } connector def ChargeResponseCN { participants : ~ source : ChargeResponseOPT ; ~ destination : ChargeResponseIPT ; flows : ChargeResponse from source to destination } connector def RegisterCardRequestCN { participants : ~ source : RegisterCardRequestOPT ; ~ destination : RegisterCardRequestIPT ; flows : RegisterCardRequest from source to destination } connector def RegisterCardResponseCN { participants : ~ source : RegisterCardResponseOPT ; ~ destination : RegisterCardResponseIPT ; flows : RegisterCardResponse from source to destination } connector def RegisterBiometricAuthResponseCN { participants : ~ source : RegisterBiometricAuthResponseOPT ; ~ destination : RegisterBiometricAuthResponseIPT ; flows : RegisterBiometricAuthResponse from source to destination } connector def RegisterBiometricAuthRequestCN { participants : ~ source : RegisterBiometricAuthRequestOPT ; ~ destination : RegisterBiometricAuthRequestIPT ; flows : RegisterBiometricAuthRequest from source to destination } connector def BiometricAuthRequestCN { participants : ~ source : BiometricAuthRequestOPT ; ~ destination : BiometricAuthRequestIPT ; flows : BiometricAuthRequest from source to destination } connector def BiometricHashCN { participants : ~ source : BiometricHashOPT ; ~ destination : BiometricHashIPT ; flows : String from source to destination } connector def BiometricAuthResponseCN { participants : ~ source : BiometricAuthResponseOPT ; ~ destination : BiometricAuthResponseIPT ; flows : BiometricAuthResponse from source to destination } connector def OrderRequestCN { participants : ~ source : OrderRequestOPT ; ~ destination : OrderRequestIPT ; flows : OrderRequest from source to destination } connector def OrderStatusCN { participants : ~ source : OrderStatusOPT ; ~ destination : OrderStatusIPT ; flows : UpdateOrderStatus from source to destination } connector def KitchenOrdersCN { participants : ~ source : OrderDataOPT [ 0 , 999 ] ; ~ destination : OrderDataIPT [ 0 , 999 ] ; flows : OrderData from source to destination } connector def MenuCN { participants : ~ source : MenuItemOPT [ 0 , 999 ] ; ~ destination : MenuItemIPT [ 0 , 999 ] ; flows : MenuItem from source to destination } connector def DateTimeCN { participants : ~ source : DateTimeOPT ; ~ destination : DateTimeIPT ; flows : DateTime from source to destination } connector def BarCodeCN { participants : ~ source : BarCodeOPT ; ~ destination : BarCodeIPT ; flows : String from source to destination } } 

Requirement QualityNFR ( 5 ) { text = "\"O sistema deve garantir bons níveis de segurança, desempenho, disponibilidade, usabilidade, escalabilidade e manutenibilidade.\"" Requirement SecurityNFR ( 5.1 ) { text = "\"O sistema deve satisfazer requisitos de segurança contra fraudes, criptografia de dados e reconhecimento de usuários sem erro.\"" Requirement DataSecurityNFR ( 5.1.1 ) { text = "\"Todos os dados de usuários, incluindo informações de pagamento (cartões de crédito/débito), devem ser armazenados de forma segura, utilizando criptografia.\"" } Requirement FraudSecurityNFR ( 5.1.2 ) { text = "\"O sistema deve ser capaz de identificar e prevenir tentativas de fraude no processo de pagamento e autenticação.\"" } Requirement RecognitionSecurityNFR ( 5.1.3 ) { text = "\"Os métodos de reconhecimento devem ter garantir de precisão e segurança, minimizando erros de identificação.\"" } } Requirement PerformanceNFR ( 5.2 ) { text = "\"O sistema deve realizar processamento dos dados e requisições em tempo aceitável.\"" Requirement RecognitionTimeNFR ( 5.2.1 ) { text = "\"O reconhecimento facial ou digital deve ocorrer em menos de 3 segundos.\"" } Requirement PaymentTimeNFR ( 5.2.2 ) { text = "\"O sistema deve ser capaz de processar transações de pagamento de forma rápida, com tempo de resposta inferior a 5 segundos para cada transação de compra.\"" } } Requirement AvailableNFR ( 5.3 ) { text = "\"O sistema deve garantir a disponibilidade em 99.9% do tempo, e bom funcionamento do sistema, e das máquinas.\"" } Requirement UsabilityNFR ( 5.4 ) { text = "\"O sistema deve ser intuitivo, responsivo e acessível para pessoas de todas as idades e com quaisquer deficiências físicas ou cognitivas.\"" Requirement AccessibilityNFR ( 5.4.2 ) { text = "\"O sistema deve garantir que os usuários com deficiências físicas ou cognitivas possam utilizar os dispositivos de forma eficiente, com suporte para tecnologias assistivas (como leitores de tela e interfaces de fácil navegação).\"" } Requirement ResponsivenessNFR ( 5.4.1 ) { text = "\"A aplicação e os dispositivos de pagamento devem estar disponíveis em todos os aparelhos, e serem responsivos e adaptáveis a esses diferentes dispositivos.\"" } } Requirement ScalabilityNFR ( 5.5 ) { text = "\"O sistema deve ser projetado para ser escalável, podendo ser facilmente adaptado para eventos de diferentes tamanhos e em diferentes tipos de locais.\"" } Requirement MaintainabilityNFR ( 5.6 ) { text = "\"O sistema deve ser fácil de manter, com processos de atualização e correção de erros bem definidos.\"" } } Requirement MachineMonitoringNFR ( 5.3.1 ) { text = "\"As máquinas e totens devem ser monitorados para garantir que todos os componentes estejam funcionando adequadamente.\"" derive QualityNFR.AvailableNFR ; } Requirement CompatibilityNFR ( 5.4.1.1 ) { text = "\"O sistema deve ser compatível com diferentes tipos de dispositivos móveis (iOS, Android) e navegadores web.\"" derive QualityNFR.UsabilityNFR.ResponsivenessNFR ; }