Model SysADLModel ;

package SysADLTypes {
	value type Int { } 
	value type Boolean { } 
	value type String { } 
	value type Void { } 
	value type Real { } 
	
	dimension Time 
	
	unit Second { 
		dimension = Time
	} 
	unit Millisecond { 
		dimension = Time
	}
	unit Minute { 
		dimension = Time
	} 
	unit Hour { 
		dimension = Time
	} 
	
	dimension Date 
	
	unit Day { 
		dimension = Date
	} 
	unit Month { 
		dimension = Date
	} 
	unit Year { 
		dimension = Date
	} 
	
	value type MillisecondsVT { 
		unit = Millisecond 
		dimension = Time
	} 
	value type SecondsVT { 
		unit = Second 
		dimension = Time
	} 
	value type MinutesVT { 
		unit = Minute 
		dimension = Time
	} 
	value type HoursVT { 
		unit = Hour 
		dimension = Time
	} 
	
	value type DaysVT { 
		unit = Day 
		dimension = Date
	} 
	value type MonthsVT { 
		unit = Month 
		dimension = Date
	} 
	value type YearsVT { 
		unit = Year 
		dimension = Date
	} 
	
	datatype TimestampDT { 
		attributes : 
			^value : MillisecondsVT ;
	} 
	datatype DateDT { 
		attributes : 
			day : DaysVT ;
			month : MonthsVT ; 
			year : YearsVT ;
	} 
	datatype TimeDT { 
		attributes : 
			hour : HoursVT ; 
			minute : MinutesVT ; 
			second : SecondsVT ;
	} 
	datatype DateTimeDT { 
		attributes : 
			date : DateDT ; 
			time : TimeDT ;
	} 
	
	datatype DBQueryDT { 
		attributes : 
			operation : DBOperationEnum ; 
			target : String ; 
			content : String ;
	} 
	enum DBOperationEnum { 
		INSERT , 
		UPDATE , 
		DELETE , 
		SELECT
	} 
	datatype DBResponseDT { 
		attributes : 
			success : Boolean ; 
			content : String ; 
			error : String ;
	} 
	
	datatype HTTPHeaderDT { 
		attributes : 
			key : String ; 
			^value : String ;
	} 
	enum HTTPMethodEnum { 
		GET , 
		POST , 
		PUT , 
		DELETE , 
		PATCH
	} 
	datatype HTTPBodyDT { 
		attributes : 
			content : String ;
	} 
	
	datatype HTTPRequestDT { 
		attributes : 
			method : HTTPMethodEnum ; 
			path : String ; 
			header : HTTPHeaderDT ; 
			^body : HTTPBodyDT ;
	} 
	datatype HTTPResponseDT { 
		attributes : 
			statusCode : Int ; 
			header : HTTPHeaderDT ; 
			^body : HTTPBodyDT ;
	} 
	
	enum BiometricTypeEnum { 
		FINGERPRINT , 
		FACE , 
		BARCODE
	} 
	
	datatype UserDT { 
		attributes : 
			name : String ; 
			cpf : String ; 
			email : String ; 
			birthdate : DateDT ; 
			phone : String ;
	id : Int ; } 
	
	datatype BiometricRawDT { 
		attributes : 
			^type : BiometricTypeEnum ; 
			data : String ;
	} 
	
	enum ProductCategoryEnum { 
		SNACK , 
		DRINK_PACKAGED , 
		DRINK_TAP , 
		MEAL
	} 
	
	datatype ProductDT { 
		attributes : 
			id : Int ; 
			name : String ; 
			description : String ; 
			category : ProductCategoryEnum ; 
			price : Real ;
	} 
	
	datatype ProductArrayDT { }
	 
	datatype StockInfoDT {
		attributes : 
			productId : Int ; 
			quantity : Int ; 
			lastUpdate : DateTimeDT ;
	machineId : Int ; } 
	
	enum MachineTypeEnum { 
		TOTEM , 
		DISPENSER , 
		TAP
	} 
	
	enum PaymentStatusEnum {
		PENDING , 
		AUTHORIZED , 
		CANCELED
	} 
	
	enum OrderStatusEnum { 
		CREATED , 
		PROCESSING , 
		READY , 
		FINISHED, 
		CANCELED
	} 
	
	datatype OrderItemDT { 
		attributes : 
			productId : Int ;
		 	quantity : Int ; 
		 	unitPrice : Real ;
	} 
	
	datatype OrderDT { 
		attributes : 
			orderId : Int ; 
			customerId : Int ; 
			createdAt : DateTimeDT ; 
			updatedAt : DateTimeDT ; 
			machineType : MachineTypeEnum ; 
			paymentStatus : PaymentStatusEnum ; 
			orderStatus : OrderStatusEnum ; 
			items : OrderItemArrayDT ;
			kitchenId : Int ; machineId : Int ; 
	} 
	
	datatype OrderItemArrayDT { } 
	
	datatype OrderProcessingDT { 
		attributes : 
			finalPrice : Real ; 
			kitchenId : Int ;
	} 
	
	datatype OrderChargeDT { 
		attributes : 
			customerId : Int ; 
			^value : Real ;
	} 
	
	datatype StockInfoArrayDT { } 
	
	datatype DispenserProductDT { 
		attributes : 
			productId : Int ; 
			authorization : Boolean ;
	} 
	
	enum CompartmentCMDEnum { 
		OPEN, 
		CLOSE
	} 
	
	datatype PickupOrderAddedDT { 
		attributes : 
			orderId : Int ; 
			pickupId : Int ;
	} 
}

package FoodFastConnectors { 
	import FoodFastPorts ;
	
	connector def DBQueryCN { 
		participants : 
			~ destination : DBQueryIPT ; 
			~ source : DBQueryOPT ; 
		flows : 
			DBQueryDT from source to destination
	} 
	
	connector def DBResponseCN { 
		participants : 
			~ destination : DBResponseIPT ; 
			~ source : DBResponseOPT ; 
		flows : 
			DBResponseDT from source to destination
	} 
	
	connector def DatabaseCN { 
		participants : 
			~ service : DBServiceP ; 
			~ client : DBClientP ; 
		configuration { 
			connectors : 
				response : DBResponseCN bindings responseOPT = responseIPT ; 
				query : DBQueryCN bindings queryOPT = queryIPT ;
		}
	} 
	
	connector def HTTPRequestCN { 
		participants : 
			~ source : HTTPRequestOPT ; 
			~ destination : HTTPRequestIPT ; 
		flows : 
			HTTPRequestDT from source to destination
	} 
	connector def HTTPResponseCN { 
		participants : 
			~ destination : HTTPResponseIPT ; 
			~ source : HTTPResponseOPT ; 
		flows : 
			HTTPResponseDT from source to destination
	} 
	
	connector def HTTPCN { 
		participants : 
			~ service : HTTPServiceP ; 
			~ client : HTTPClientP ; 
			
			configuration { 
				connectors : 
					response : HTTPResponseCN bindings responseOPT = responseIPT ; 
					request : HTTPRequestCN bindings requestOPT = requestIPT ;
			}
	} 
	
	connector def BiometricTypeCN { 
		participants : 
			~ destination : BiometricTypeIPT ; 
			~ source : BiometricTypeOPT ; 
		flows : 
			BiometricTypeEnum from source to destination
	} 
	
	connector def BiometricRawCN { 
		participants : 
			~ destination : BiometricRawIPT ;
			~ source : BiometricRawOPT ; 
		flows : 
			BiometricRawDT from source to destination
	} 
	
	connector def UserCN { 
		participants : 
			~ destination : UserIPT ; 
			~ source : UserOPT ; 
		flows : 
			UserDT from source to destination
	} 
	
	connector def BooleanCN { 
		participants : 
			~ destination : BooleanIPT ; 
			~ source : BooleanOPT ; 
		flows : 
			Boolean from source to destination
	} 
	
	connector def SensorCN { 
		participants : 
			~ client : HTTPClientP ; 
			~ server : SensorIPT ; 
			
			configuration { 
				connectors : 
					httpToBiometricType : HTTPToBiometricTypeCN bindings requestOPT = biometricType ; 
					biometricRawToHTTP : BiometricRawToHTTPCN bindings biometriRaw = responseIPT ;
			}
	} 
	
	connector def HTTPToBiometricTypeCN { 
		participants : 
			~ source : HTTPRequestOPT ; 
			~ destination : BiometricTypeIPT ; 
			
		flows : 
			HTTPRequestDT from source to destination
	} 
	
	connector def BiometricRawToHTTPCN { 
		participants : 
			~ source : BiometricRawOPT ; 
			~ destination : HTTPResponseIPT ; 
			
		flows : 
			BiometricRawDT from source to destination
	} 
	
	connector def StringCN { 
		participants : 
			~ destination : StringIPT ; 
			~ source : StringOPT ; 
		
		flows : 
			String from source to destination
	} 
	
	connector def IntCN { 
		participants : 
			~ destination : IntIPT ; 
			~ source : IntOPT ; 
		flows : 
			Int from source to destination
	} 
	
	connector def OrderCN { 
		participants : 
			~ destination : OrderIPT ; 
			~ source : OrderOPT ; 
		flows : 
			OrderDT from source to destination
	} 
	
	connector def OrderProcessingCN { 
		participants : 
			~ destination : OrderProcessingIPT ; 
			~ source : OrderProcessingOPT ; 
		flows : 
			OrderProcessingDT from source to destination
	} 
	
	connector def OrderItemArrayCN { 
		participants : 
			~ destination : OrderItemArrayIPT ; 
			~ source : OrderItemArrayOPT ; 
		flows : 
			OrderItemArrayDT from source to destination
	} 
	
	connector def RealCN { 
		participants : 
			~ source : RealOPT ; 
			~ destination : RealIPT ; 
		flows : 
			Real from source to destination
	} 
	
	connector def OrderChargeCN { 
		participants : 
			~ destination : OrderChargeIPT ; 
			~ source : OrderChargeOPT ; 
		flows : 
			OrderChargeDT from source to destination
	} 
		
	connector def PaymentStatusCN { 
		participants : 
			~ destination : PaymentStatusIPT ; 
			~ source : PaymentStatusOPT ; 
		flows : 
			PaymentStatusEnum from source to destination
	} 
	
	connector def DispenserProductCN { 
		participants : 
			~ destination : DispenserProductIPT ; 
			~ source : DispenserProductOPT ; 
		flows : 
			DispenserProductDT from source to destination
	} 
	
	connector def CompartmentCMDCN { 
		participants : 
			~ destination : CompartmentCMDIPT ; 
			~ source : CompartmentCMDOPT ; 
		flows : 
			CompartmentCMDEnum from source to destination
	}
	
	connector def PickupOrderAddedCN { 
		participants : 
			~ destination : PickupOrderAddedIPT ; 
			~ source : PickupOrderAddedOPT ; 
		flows : 
			PickupOrderAddedDT from source to destination
	}
}

package FoodFastComponents { 
	import FoodFastConnectors ; 
	import FoodFastPorts ; 
	import SysADLTypes ;
	
	component def FoodFastARCH { 
		configuration { 
			components : 
				DatabaseCP : DatabaseCP { 
					using ports : 
						dbServiceP : DBServiceP ;
				} 
				
				UserServerCP : UserServerCP { 
					using ports : 
						dbClient_User : DBClientP ; 
						httpServer_User : HTTPServiceP ;
				} 
				
				FrontendCP : FrontendCP { 
					using ports : 
						httpClient_Frontend : HTTPClientP ;
				} 
				
				BiometricServerCP : BiometricServerCP { 
					using ports : 
						httpServer_Biometric : HTTPServiceP ; 
						dbClient_Biometric : DBClientP ;
				} 
				
				RegisterBiometricTotenCP : RegisterBiometricTotemCP { 
					using ports : 
						httpClient_BiometricToten : HTTPClientP ;
				} 
				
				AdminFrontendCP : AdminFrontendCP { 
					using ports : 
						httpClient_AdminFrontend : HTTPClientP ;
				} 
				
				ProductServerCP : ProductServerCP { 
					using ports : 
						httpServer_Product_private : HTTPServiceP ; 
						httpServer_Product_public : HTTPServiceP ; 
						dbClient_Product : DBClientP ;
				} 
			
				DispenserSnackMachineCP : DispenserSnackMachineCP { 
					using ports : 
						httpClient_DispenserSnackToOrderServer : HTTPClientP ; 
						httpClient_DispenserSnackToBiometricServer : HTTPClientP ;
				} 
				
				DispenserDrinkMachineCP : DispenserDrinkMachineCP { 
					using ports : 
						httpClient_DispenserDrinkToOrderServer : HTTPClientP ; 
						httpClient_DispenserDrinkToBiometricServer : HTTPClientP ;
				} 
				
				OrderServerCP : OrderServerCP { 
					using ports : 
						httpServer_Order_private : HTTPServiceP ; 
						httpServer_Order_public : HTTPServiceP ; 
						dbClient_Order : DBClientP ; 
						httpClient_CheckItemServer : HTTPClientP ;
				} 
				
				TapMachineCP : TapMachineCP { 
					using ports : 
						httpClient_TapToBiometricServer : HTTPClientP ; 
						httpClient_TapToOrderServer : HTTPClientP ; 
						httpClient_TapToProductServer : HTTPClientP ;
				} 
				
				TotemCP : TotemCP { 
					using ports : 
						httpClient_TotemToProductServer : HTTPClientP ; 
						httpClient_TotemToOrderServer : HTTPClientP ; 
						httpClient_TotemToBiometricServer : HTTPClientP ;
				} 
				
			PickupStationCP : PickupStationCP { 
				using ports : 
					httpClient_PickupToOrderServer : HTTPClientP ; 
					httpClient_PickupToBiometricServer : HTTPClientP ;
			} 
			
			connectors : 
				DB_UserServer : DatabaseCN bindings dbClient_User = dbServiceP ; 
				DB_BiometricServer : DatabaseCN bindings dbClient_Biometric = dbServiceP ; 
				Front_UserServer : HTTPCN bindings httpClient_Frontend = httpServer_User ; 
				Toten_BiometricServer : HTTPCN bindings httpClient_BiometricToten = httpServer_Biometric ; 
				DB_ProductServer : DatabaseCN bindings dbClient_Product = dbServiceP ; 
				FrontAdmin_ProductServer : HTTPCN bindings httpClient_AdminFrontend = httpServer_Product_private ; 
				DispenserSnack_BiometricServer : HTTPCN bindings httpClient_DispenserSnackToBiometricServer = httpServer_Biometric ; 
				DispenserDrink_BiometricServer : HTTPCN bindings httpClient_DispenserDrinkToBiometricServer = httpServer_Biometric ; 
				checkItems : HTTPCN bindings httpClient_CheckItemServer = httpServer_Product_private ; 
				Front_OrderServer : HTTPCN bindings httpClient_Frontend = httpServer_Order_public ; 
				DB_OrderServer : DatabaseCN bindings dbClient_Order = dbServiceP ; 
				DispenserSnack_OrderServer : HTTPCN bindings httpClient_DispenserSnackToOrderServer = httpServer_Order_private ; 
				DispenserDrink_OrderServer : HTTPCN bindings httpClient_DispenserDrinkToOrderServer = httpServer_Order_private ; 
				Tap_BiometricServer : HTTPCN bindings httpClient_TapToBiometricServer = httpServer_Biometric ; 
				Tap_OrderServer : HTTPCN bindings httpClient_TapToOrderServer = httpServer_Order_private ; 
				Tap_ProductServer : HTTPCN bindings httpClient_TapToProductServer = httpServer_Product_private ; 
				Totem_BiometricServer : HTTPCN bindings httpClient_TotemToBiometricServer = httpServer_Biometric ; 
				Totem_OrderServer : HTTPCN bindings httpClient_TotemToOrderServer = httpServer_Order_private ; 
				Totem_ProductServer : HTTPCN bindings httpClient_TotemToProductServer = httpServer_Product_private ; 
				PickupBiometricServer : HTTPCN bindings httpClient_PickupToBiometricServer = httpServer_Biometric ; 
				Pickup_OrderServer : HTTPCN bindings httpClient_PickupToOrderServer = httpServer_Order_private ; 
		}
	} 
	
	boundary component def DatabaseCP { 
		ports : 
			dbServiceP : DBServiceP [ 1 , 2 ] ;
	}
	
	component def UserServerCP { 
		ports : 
			dbClient_User : DBClientP ; 
			httpServer_User : HTTPServiceP ; 
			
			configuration { 
				components : 
					UserAuthCP : UserAuthCP { 
						using ports : 
							httpServer_UserAuth : HTTPServiceP ; 
							dbClient_UserAuth : DBClientP ;
					} 
					
					UserCreateCP : UserCreateCP { 
						using ports : 
							httpServer_UserCreate : HTTPServiceP ; 
							dbClient_UserCreate : DBClientP ;
					} 
					
					UserDeleteCP : UserDeleteCP { 
						using ports : 
							httpServer_UserDelete : HTTPServiceP ; 
							dbClient_UserDelete : DBClientP ;
					} 
					
					UserUpdateCP : UserUpdateCP { 
						using ports : httpServer_UserUpdate : HTTPServiceP ; 
						dbClient_UserUpdate : DBClientP ;
					} 
					
					UserRetrieveCP : UserRetrieveCP { 
						using ports : 
							httpServer_UserRetrieve : HTTPServiceP ; 
							dbClient_UserRetrieve : DBClientP ;
					} 
					
					delegations : 
						httpServer_UserAuth to httpServer_User
						httpServer_UserCreate to httpServer_User 
						httpServer_UserDelete to httpServer_User 
						httpServer_UserUpdate to httpServer_User 
						dbClient_UserUpdate to dbClient_User 
						dbClient_UserDelete to dbClient_User 
						dbClient_UserCreate to dbClient_User 
						dbClient_UserRetrieve to dbClient_User 
						httpServer_UserRetrieve to httpServer_User 
						dbClient_UserAuth to dbClient_User
			}
	}
	
	boundary component def UserCreateCP { 
		ports : 
			httpServer_UserCreate : HTTPServiceP ; 
			dbClient_UserCreate : DBClientP ;
	} 
	
	boundary component def UserUpdateCP { 
		ports : 
			httpServer_UserUpdate : HTTPServiceP ; 
			dbClient_UserUpdate : DBClientP ;
	} 
	
	boundary component def UserRetrieveCP { 
		ports : 
			httpServer_UserRetrieve : HTTPServiceP ; 
			dbClient_UserRetrieve : DBClientP ;
	} 
	
	boundary component def UserDeleteCP { 
		ports : 
			httpServer_UserDelete : HTTPServiceP ; 
			dbClient_UserDelete : DBClientP ; 
			
			port def DBResponseIPT { 
				flow in DBResponseDT
			}
	} 
	
	boundary component def UserAuthCP { 
		ports : 
			httpServer_UserAuth : HTTPServiceP ; 
			dbClient_UserAuth : DBClientP ;
	} 
	
	boundary component def FrontendCP { 
		ports : 
			httpClient_Frontend : HTTPClientP [ 1 , 2 ] ;
	} 
	
	boundary component def FingerprintSensorCP { 
		ports : 
			active_Fingerprint : BooleanIPT ; 
			biometricRaw_Fingerprint : BiometricRawOPT ;
	} 
	
	boundary component def FaceCameraCP { 
		ports : 
			active_Camera : BooleanIPT ; 
			biometricRaw_Camera : BiometricRawOPT ;
	} boundary
	component def RegisterBiometricCP { 
		ports : 
			dbClient_RegisterBiometric : DBClientP ; 
			httpService_RegisterBiometric : HTTPServiceP ;
	} boundary
	component def RemoveBiometricCP { 
		ports : 
			httpService_RemoveBiometric : HTTPServiceP ; 
			dbClient_RemoveBiometric : DBClientP ;
	} boundary
	component def BiometricRecognitionCP { 
		ports : 
			dbClient_BiometricRecognition : DBClientP ; 
			httpService_BiometricRecognition : HTTPServiceP ;
	}
	
	component def BiometricServerCP { 
		ports : 
			httpServer_Biometric : HTTPServiceP [ 1 , 2 ] ; 
			dbClient_Biometric : DBClientP ; 
		configuration { 
			components : 
				BiometricRecognitionCP : BiometricRecognitionCP { 
					using ports : 
						dbClient_BiometricRecognition : DBClientP ; 
						httpService_BiometricRecognition : HTTPServiceP ;
				} 
				
				RegisterBiometricCP : RegisterBiometricCP { 
					using ports : 
						dbClient_RegisterBiometric : DBClientP ; 
						httpService_RegisterBiometric : HTTPServiceP ;
				} 
				
				RemoveBiometricCP : RemoveBiometricCP { 
					using ports : 
						httpService_RemoveBiometric : HTTPServiceP ; 
						dbClient_RemoveBiometric : DBClientP ;
				} 
				
				delegations : 
					httpService_BiometricRecognition to httpServer_Biometric
					httpService_RegisterBiometric to httpServer_Biometric
					httpService_RemoveBiometric to httpServer_Biometric
					dbClient_BiometricRecognition to dbClient_Biometric
					dbClient_RegisterBiometric to dbClient_Biometric
					dbClient_RemoveBiometric to dbClient_Biometric
		}
		
	}
	
	component def BiometricSensorsCP { 
		ports : 
			sensors_Component : SensorIPT ; 
		 
		configuration { 
			components : 
				BiometricControllerCP : BiometricControllerCP { 
					using ports : 
						biometricRawIPT_Fingerprint : BiometricRawIPT ; 
						biometricRawIPT_Camera : BiometricRawIPT ; 
						sensorActive_Fingerprint : BooleanOPT ; 
						sensorActive_Camera : BooleanOPT ; 
						sensors_Controller : SensorIPT ;
				} 
				
				FaceCameraCP : FaceCameraCP { 
					using ports : 
						active_Camera : BooleanIPT ; 
						biometricRaw_Camera : BiometricRawOPT ;
				} 
				
				FingerprintSensorCP : FingerprintSensorCP { 
					using ports : 
						active_Fingerprint : BooleanIPT ; 
						biometricRaw_Fingerprint : BiometricRawOPT ;
				} 
				
			connectors : 
				biometricRaw_Camera : BiometricRawCN bindings biometricRaw_Camera = biometricRawIPT_Fingerprint ; 
				activeCamera : BooleanCN bindings sensorActive_Fingerprint = active_Camera ; 
				biometricRaw_FingerPrint : BiometricRawCN bindings biometricRaw_Fingerprint = biometricRawIPT_Camera ; 
				activeFingerprint : BooleanCN bindings active_Fingerprint = sensorActive_Camera ; 
			delegations : 
				sensors_Controller to sensors_Component 
		}
	}
	
	component def BiometricControllerCP { 
		ports : 
			 
			biometricRawIPT_Fingerprint : BiometricRawIPT ; 
			biometricRawIPT_Camera : BiometricRawIPT ; 
			 
			sensorActive_Fingerprint : BooleanOPT ; 
			sensorActive_Camera : BooleanOPT ;
	sensors_Controller : SensorIPT ; }
	
	component def RegisterBiometricTotemCP { 
		ports : 
			httpClient_BiometricTotem : HTTPClientP [ 1 , 2 ] ; 
		configuration { 
			components : 
				BiometricTotenProcessorCP : BiometricTotemProcessorCP { 
					using ports : 
						httpClient_BiometricTotenProcessor_external : HTTPClientP ; 
						httpClient_BiometricTotenProcessor_internal : HTTPClientP ; 
						cpfString_BiometricToten : StringIPT ;
				} 
				
				KeywordCP : KeywordCP { 
					using ports : keywordOutput : StringOPT ;
				} 
				
				BiometricSensorsCP : BiometricSensorsCP { 
					using ports : sensors_Component : SensorIPT ;
				} 
			
			connectors : 
				cpfConnector : StringCN bindings keywordOutput = cpfString_BiometricToten ; 
				sensorData : SensorCN bindings httpClient_BiometricTotenProcessor_internal = sensors_Component ;
				
			delegations : 
				httpClient_BiometricTotenProcessor_external to httpClient_BiometricTotem }
	}
	
	component def ProductServerCP { 
		ports : 
			httpServer_Product_private : HTTPServiceP ; 
			httpServer_Product_public : HTTPServiceP [ 1 , 2 ] ; 
			dbClient_Product : DBClientP ; 
		configuration { 
			components : 
				CreateProductCP : CreateProductCP { 
					using ports : 
						httpServer_CreateProduct : HTTPServiceP ; 
						dbClient_CreateProduct : DBClientP ;
				} 
				
				UpdateProductCP : UpdateProductCP { 
					using ports : 
						httpServer_UpdateProduct : HTTPServiceP ; 
						dbClient_UpdateProduct : DBClientP ;
				} 
				
				DeleteProductCP : DeleteProductCP { 
					using ports : 
						httpServer_DeleteProduct : HTTPServiceP ; 
						dbClient_DeleteProduct : DBClientP ;
				} 
				
				RetrieveProductCP : RetrieveProductCP { 
					using ports : 
						httpServer_RetrieveProduct : HTTPServiceP ; 
						dbClient_RetrieveProduct : DBClientP ;
				} 
				
				GetMachineStockCP : GetMachineStockCP { 
					using ports : 
						httpServer_CheckAvailabilityProduct : HTTPServiceP ; 
						dbClient_CheckAvailabilityProduct : DBClientP ;
				} 
			
			delegations : 
				httpServer_CreateProduct to httpServer_Product_private
				dbClient_CreateProduct to dbClient_Product
				httpServer_UpdateProduct to httpServer_Product_private
				dbClient_UpdateProduct to dbClient_Product
				httpServer_DeleteProduct to httpServer_Product_private
				dbClient_DeleteProduct to dbClient_Product
				httpServer_RetrieveProduct to httpServer_Product_private
				httpServer_RetrieveProduct to httpServer_Product_public
				dbClient_RetrieveProduct to dbClient_Product
				dbClient_CheckAvailabilityProduct to dbClient_Product
				httpServer_CheckAvailabilityProduct to httpServer_Product_private
				httpServer_CheckAvailabilityProduct to httpServer_Product_public
		}
	} 
	
	boundary component def AdminFrontendCP { 
		ports : httpClient_AdminFrontend : HTTPClientP ;
	} 
	
	boundary component def CreateProductCP { 
		ports : 
			httpServer_CreateProduct : HTTPServiceP ; 
			dbClient_CreateProduct : DBClientP ; 
	} 
	
	boundary component def UpdateProductCP { 
		ports : 
			httpServer_UpdateProduct : HTTPServiceP ; 
			dbClient_UpdateProduct : DBClientP ; 
	} 
	
	boundary component def DeleteProductCP { 
		ports : 
			httpServer_DeleteProduct : HTTPServiceP ; 
			dbClient_DeleteProduct : DBClientP ;
	} 
	
	boundary component def RetrieveProductCP { 
		ports : 
			httpServer_RetrieveProduct : HTTPServiceP ; 
			dbClient_RetrieveProduct : DBClientP ;
	}
	
	boundary component def GetMachineStockCP { 
		ports : 
			httpServer_CheckAvailabilityProduct : HTTPServiceP ; 
			dbClient_CheckAvailabilityProduct : DBClientP ;
	}
	
	component def BiometricTotemProcessorCP { 
		ports : 
			httpClient_BiometricTotemProcessor_external : HTTPClientP ; 
			httpClient_BiometricTotemProcessor_internal : HTTPClientP ; cpfString_BiometricTotem : StringIPT ;
	} 
	
	boundary component def KeywordCP { 
		ports : keywordOutput : StringOPT ;
	}
	
	component def OrderServerCP { 
		ports : 
			httpServer_Order_private : HTTPServiceP ; 
			httpServer_Order_public : HTTPServiceP ; 
			dbClient_Order : DBClientP ; httpClient_CheckItemServer : HTTPClientP ; 
		
		configuration { 
			components : 
				UpdateOrderCP : UpdateOrderCP { 
					using ports : 
						httpServer_UpdateOrder : HTTPServiceP ; 
						dbClient_UpdateOrder : DBClientP ;
				} 
				
				RetrieveOrderCP : RetrieveOrderCP { 
					using ports : 
						httpServer_RetrieveOrder : HTTPServiceP ; 
						dbClient_RetrieveOrder : DBClientP ;
				} 
			
				CheckDebtsCP : CheckDebtsCP { 
					using ports : 
					dbClient_CheckDebts : DBClientP ; 
					httpServer_CheckDebts : HTTPServiceP ;
				} 
				
				ProcessingOrderCP : ProcessingOrderCP { 
					using ports : 
						dbClient_ProcessingOrder : DBClientP ;
						httpServer_ProcessingOrder : HTTPServiceP ; 
						httpClient_CheckDebtsProcessing : HTTPClientP ; 
						httpClient_CheckItemsProcessing : HTTPClientP ;
				} 
				
				CreateOrderCP : CreateOrderCP { 
					using ports : 
						httpClient_CreateOrder : DBClientP ; 
						httpServer_CreateOrder : HTTPServiceP ; 
						dbClient_CreateOrder : DBClientP ;
				} 
			
			connectors : 
				hasDebitsCN : HTTPCN bindings httpClient_CheckDebtsProcessing = httpServer_CheckDebts ; 
				processingOrder : HTTPCN bindings httpClient_CreateOrder = httpServer_ProcessingOrder ; 
			
			delegations : 
				dbClient_UpdateOrder to dbClient_Order
				dbClient_RetrieveOrder to dbClient_Order 
				httpServer_RetrieveOrder to httpServer_Order_public 
				httpServer_UpdateOrder to httpServer_Order_private
				httpServer_CheckDebts to httpServer_Order_private 
				dbClient_CheckDebts to dbClient_Order 
				dbClient_ProcessingOrder to dbClient_Order 
				httpServer_ProcessingOrder to httpServer_Order_private 
				httpClient_CheckItemsProcessing to httpClient_CheckItemServer 
				dbClient_CreateOrder to dbClient_Order 
				httpServer_CreateOrder to httpServer_Order_private }
	} 
	
	boundary component def RetrieveOrderCP { 
		ports : 
			httpServer_RetrieveOrder : HTTPServiceP ; 
			dbClient_RetrieveOrder : DBClientP ;
	} 
	
	boundary component def UpdateOrderCP { 
		ports : 
			httpServer_UpdateOrder : HTTPServiceP ; 
			dbClient_UpdateOrder : DBClientP ;
	} 

	boundary component def CheckDebtsCP { 
		ports :  
			dbClient_CheckDebts : DBClientP ;  
			httpServer_CheckDebts : HTTPServiceP [ 1 , 2 ] ;
	}
	
	component def ProcessingOrderCP { 
		ports : 
			dbClient_ProcessingOrder : DBClientP ; 
			httpServer_ProcessingOrder : HTTPServiceP [ 1 , 2 ] ; 
			httpClient_CheckDebtsProcessing : HTTPClientP ; 
			httpClient_CheckItemsProcessing : HTTPClientP ; 
		configuration { 
			components :
				AdditionalProcessingCP : AdditionalProcessingCP { 
					using ports : 
						order_AdditionalProcessing : OrderIPT ; 
						orderProcessing_AdditionalProcessing : OrderProcessingOPT ;
				} 
				
				PaymentProcessingCP : PaymentProcessingCP { 
					using ports : 
						orderCharge_PaymentProcessing : OrderChargeIPT ; 
						paymentResult_PaymentProcessing : PaymentStatusOPT ; 
						dbClient_PaymentProcessig : DBClientP ;
				} 
				
				CheckItemsAvailabilityCP : CheckItemsAvailabilityCP { 
					using ports : 
						httpClient_CheckItemsAvailability : HTTPClientP ; 
						items_CheckItemsAvailability : OrderItemArrayIPT ; 
						availibility : BooleanOPT ;
				} 
				
				OrderProcessingCoordinatorCP : OrderProcessingCoordinatorCP { 
					using ports : 
						httpServer_ProcessingOrderCoordinator : HTTPServiceP ; 
						dbClient_ProcessingOrderCoordinator : DBClientP ; 
						order_OrderProcessingCoordinator : OrderOPT ; 
						orderProcessing_OrderProcessingCoordinator : OrderProcessingIPT ; 
						orderCharge_OrderProcessingCoordinator : OrderChargeOPT ; 
						paymentResult_OrderProcessingCoordinator : PaymentStatusIPT ; 
						httpClient_CheckDebtsPCoordinator : HTTPClientP ; 
						availibility_Coordinator : BooleanIPT ; 
						items_CIACoordinator : OrderItemArrayOPT ;
				} 
			
			connectors : 
				allProductsAvailable : BooleanCN bindings availibility = availibility_Coordinator ; 
				itemsToAvaluation : OrderItemArrayCN bindings items_CIACoordinator = items_CheckItemsAvailability ; 
				orderToAdditionalProcessing : OrderCN bindings order_OrderProcessingCoordinator = order_AdditionalProcessing ; 
				additionalProcessingResult : OrderProcessingCN bindings orderProcessing_AdditionalProcessing = orderProcessing_OrderProcessingCoordinator ; 
				paymentRequest : OrderChargeCN bindings orderCharge_OrderProcessingCoordinator = orderCharge_PaymentProcessing ; 
				paymentStatusResult : PaymentStatusCN bindings paymentResult_PaymentProcessing = paymentResult_OrderProcessingCoordinator ; 
			
			delegations : 
				dbClient_ProcessingOrderCoordinator to dbClient_ProcessingOrder 
				httpServer_ProcessingOrderCoordinator to httpServer_ProcessingOrder 
				httpClient_CheckDebtsPCoordinator to httpClient_CheckDebtsProcessing 
				httpClient_CheckItemsAvailability to httpClient_CheckItemsProcessing 
				dbClient_PaymentProcessig to dbClient_ProcessingOrder 
		}
	} 
	
	boundary component def KitchenRoutingCP { 
		ports : 
			orderItems_Routing : OrderItemArrayIPT ; 
			kitchenId_Routing : IntOPT ;
	}
	
	component def OrderProcessingCoordinatorCP { 
		ports :
			httpServer_ProcessingOrderCoordinator : HTTPServiceP ; 
			dbClient_ProcessingOrderCoordinator : DBClientP ; 
			order_OrderProcessingCoordinator : OrderOPT ;
			orderProcessing_OrderProcessingCoordinator : OrderProcessingIPT ; 
			orderCharge_OrderProcessingCoordinator : OrderChargeOPT ; 
			paymentResult_OrderProcessingCoordinator : PaymentStatusIPT ; 
			httpClient_CheckDebtsPCoordinator : HTTPClientP ; 
			availibility_Coordinator : BooleanIPT ; 
			items_CIACoordinator : OrderItemArrayOPT ;
	}
	
	component def AdditionalProcessingCP { 
		ports : 
			order_AdditionalProcessing : OrderIPT ; 
			orderProcessing_AdditionalProcessing : OrderProcessingOPT ; 
		
		configuration { 
			components : 
				AdditionalProcessingCoordinatorCP : AdditionalProcessingCoordinatorCP { 
					using ports : 
						orderProcessing_APCoordinator : OrderProcessingOPT ; 
						orderItems_ToRouting : OrderItemArrayOPT ; 
						orderItems_ToPricing : OrderItemArrayOPT ;
						kitchenId_ByRouting : IntIPT ; 
						orderPrice_ByPricing : RealIPT ; 
						order_APCoordinator : OrderIPT ;
				} 
				
				KitchenRoutingCP : KitchenRoutingCP { 
					using ports : 
						orderItems_Routing : OrderItemArrayIPT ; 
						kitchenId_Routing : IntOPT ;
				} 
				
				PriceCalculationCP : PriceCalculationCP { 
					using ports : 
						orderItems_Pricing : OrderItemArrayIPT ; 
						orderPrice_Pricing : RealOPT ;
				} 
			
			connectors : 
				kitchenId : IntCN bindings kitchenId_Routing = kitchenId_ByRouting ; 
				ordersToRouting : OrderItemArrayCN bindings orderItems_ToRouting = orderItems_Routing ; 
				orderPrice : RealCN bindings orderPrice_Pricing = orderPrice_ByPricing ; 
				ordersToPricing : OrderItemArrayCN bindings orderItems_ToPricing = orderItems_Pricing ; 
			
			delegations : 
				order_APCoordinator to order_AdditionalProcessing 
				orderProcessing_APCoordinator to orderProcessing_AdditionalProcessing
		}
	} 
	
	boundary component def PaymentProcessingCP { 
		ports : 
			orderCharge_PaymentProcessing : OrderChargeIPT ; 
			paymentResult_PaymentProcessing : PaymentStatusOPT ; 
			dbClient_PaymentProcessig : DBClientP ;
	} 
	
	boundary component def PriceCalculationCP { 
		ports : 
			orderItems_Pricing : OrderItemArrayIPT ; 
			orderPrice_Pricing : RealOPT ;
	}
	
	component def AdditionalProcessingCoordinatorCP { 
		ports : 
			orderProcessing_APCoordinator : OrderProcessingOPT ; 
			orderItems_ToRouting : OrderItemArrayOPT ; 
			orderItems_ToPricing : OrderItemArrayOPT ; 
			kitchenId_ByRouting : IntIPT ; orderPrice_ByPricing : RealIPT ; 
			order_APCoordinator : OrderIPT ;
	} 
	
	boundary component def CheckItemsAvailabilityCP { 
		ports : 
			httpClient_CheckItemsAvailability : HTTPClientP ; 
			items_CheckItemsAvailability : OrderItemArrayIPT ; 
			availibility : BooleanOPT ;
	} 
	
	boundary component def CreateOrderCP { 
		ports : 
			httpClient_CreateOrder : DBClientP ; 
			httpServer_CreateOrder : HTTPServiceP ; 
			dbClient_CreateOrder : DBClientP ;
	}
	
	component def DispenserSnackMachineCP { 
		ports : 
			httpClient_DispenserSnackToOrderServer : HTTPClientP ; 
			httpClient_DispenserSnackToBiometricServer : HTTPClientP ; 
		
		configuration { 
			components : 
				HardwareDispenserCP : HardwareDispenserCP { 
					using ports : 
						dispenserCommand : DispenserProductIPT ;
				} 
				
				ProductSelectionCP : ProductSelectionCP { 
					using ports : 
						selectionOn : BooleanIPT ; 
						snackId : IntOPT ;
				} 
				
				BiometricSensorsCP : BiometricSensorsCP { 
					using ports : 
						sensors_Component : SensorIPT ;
				} 
				
				DispenserMachineFlowCP : DispenserMachineFlowCP { 
					using ports : 
						selectionIsOn : BooleanOPT ; 
						selectedSnackId : IntIPT ; 
						dispenserCommandOut : DispenserProductOPT ; 
						httpClient_DMSnackSensors : HTTPClientP ; 
						httpClient_DMSnackBiometricServer : HTTPClientP ; 
						httpClient_DMSnackOrderServer : HTTPClientP ;
				} 
			
			connectors : 
				biometricData : SensorCN bindings httpClient_DMSnackSensors = sensors_Component ; 
				dispenserSnackCMD : DispenserProductCN bindings dispenserCommandOut = dispenserCommand ; 
				selectedSnackId : IntCN bindings snackId = selectedSnackId ; 
				authorizedSelection : BooleanCN bindings selectionIsOn = selectionOn ; 
			
			delegations : 
				httpClient_DMSnackBiometricServer to httpClient_DispenserSnackToBiometricServer
				 httpClient_DMSnackOrderServer to httpClient_DispenserSnackToOrderServer
		}
	} 
	
	boundary component def ProductSelectionCP { 
		ports : 
			selectionOn : BooleanIPT ; 
			snackId : IntOPT ;
	}
	
	component def DispenserMachineFlowCP { 
		ports : 
			selectionIsOn : BooleanOPT ; 
			selectedSnackId : IntIPT ; 
			dispenserCommandOut : DispenserProductOPT ; 
			httpClient_DMSnackSensors : HTTPClientP ; 
			httpClient_DMSnackBiometricServer : HTTPClientP ; 
			httpClient_DMSnackOrderServer : HTTPClientP ;
	} 
	
	boundary component def HardwareDispenserCP { 
		ports : 
			dispenserCommand : DispenserProductIPT ;
	}
	
	component def DispenserDrinkMachineCP { 
		ports : 
			httpClient_DispenserDrinkToOrderServer : HTTPClientP ; 
			httpClient_DispenserDrinkToBiometricServer : HTTPClientP ; 
		
		configuration { 
			components : 
				HardwareDispenserCP : HardwareDispenserCP { 
					using ports : 
						dispenserCommand : DispenserProductIPT ;
				} 
				
				ProductSelectionCP : ProductSelectionCP { 
					using ports : 
						selectionOn : BooleanIPT ; snackId : IntOPT ;
				} 
				
				BiometricSensorsCP : BiometricSensorsCP { 
					using ports : 
						sensors_Component : SensorIPT ;
				} 
				
				DispenserMachineFlowCP : DispenserMachineFlowCP { 
					using ports : 
						selectionIsOn : BooleanOPT ; 
						selectedSnackId : IntIPT ; 
						dispenserCommandOut : DispenserProductOPT ; 
						httpClient_DMSnackSensors : HTTPClientP ; 
						httpClient_DMSnackBiometricServer : HTTPClientP ; 
						httpClient_DMSnackOrderServer : HTTPClientP ;
				} 
			
			connectors : 
				biometricData : SensorCN bindings httpClient_DMSnackSensors = sensors_Component ; 
				dispenserSnackCMD : DispenserProductCN bindings dispenserCommandOut = dispenserCommand ; 
				selectedSnackId : IntCN bindings snackId = selectedSnackId ; 
				authorizedSelection : BooleanCN bindings selectionIsOn = selectionOn ; 
			
			delegations : 
				httpClient_DMSnackBiometricServer to httpClient_DispenserDrinkToBiometricServer 
				httpClient_DMSnackOrderServer to httpClient_DispenserDrinkToOrderServer
		}
	} 
	
	component def TapMachineCP { 
		ports : 
			httpClient_TapToBiometricServer : HTTPClientP ; 
			httpClient_TapToOrderServer : HTTPClientP ; 
			httpClient_TapToProductServer : HTTPClientP ; 
		
		configuration { 
			components : 
				BiometricSensorsCP : BiometricSensorsCP { 
					using ports : 
						sensors_Component : SensorIPT ;
				} 
				
				TapFlowControllerCP : TapFlowControllerCP { 
					using ports : 
						httpClient_TapControllerToProductServer : HTTPClientP ; 
						httpClient_TapControllerToOrderServer : HTTPClientP ; 
						httpClient_TapControllerToBiometricServer : HTTPClientP ; 
						tapReleasedCMD : BooleanOPT ; 
						amountOfDrink : IntIPT ; 
						httpClient_TapSensors : HTTPClientP ;
				} 
				
				TapActuatorCP : TapActuatorCP { 
					using ports : 
						tapReleased : BooleanIPT ; 
						amountDispensedTap : IntOPT ;
				} 
			
			connectors : 
				biometricData : SensorCN bindings httpClient_TapSensors = sensors_Component ; 
				tapReleased : BooleanCN bindings tapReleasedCMD = tapReleased ; 
				drinkAmount : IntCN bindings amountDispensedTap = amountOfDrink ; 
			
			delegations : 
				httpClient_TapControllerToBiometricServer to httpClient_TapToBiometricServer
				 httpClient_TapControllerToProductServer to httpClient_TapToProductServer
				  httpClient_TapControllerToOrderServer to httpClient_TapToOrderServer
		}
	} 
	
	boundary component def TapActuatorCP { 
		ports : 
			tapReleased : BooleanIPT ; 
			amountDispensedTap : IntOPT ;
	}
	
	component def TapFlowControllerCP { 
		ports : 
			httpClient_TapControllerToProductServer : HTTPClientP ; 
			httpClient_TapControllerToOrderServer : HTTPClientP ; 
			httpClient_TapControllerToBiometricServer : HTTPClientP ; 
			tapReleasedCMD : BooleanOPT ; 
			amountOfDrink : IntIPT ; 
			httpClient_TapSensors : HTTPClientP ;
	}
	
	component def TotemCP { 
		ports : 
			httpClient_TotemToProductServer : HTTPClientP ; 
			httpClient_TotemToOrderServer : HTTPClientP ; 
			httpClient_TotemToBiometricServer : HTTPClientP ; 
		
		configuration { 
			components : 
				TotemFlowControllerCP : TotemFlowControllerCP { 
					using ports : 
						httpClient_TotemControllerToOrderServer : HTTPClientP ; 
						httpClient_TotemControllerToProductServer : HTTPClientP ; 
						httpClient_TotemControllerToBiometricServer : HTTPClientP ; 
						httpClient_TotemSensors : HTTPClientP ; 
						selectedProducts : OrderItemArrayIPT ; 
						enableDisplay : BooleanOPT ; 
						orderToPrint : OrderOPT ;
				} 
				
				BiometricSensorsCP : BiometricSensorsCP { 
					using ports : 
						sensors_Component : SensorIPT ;
				} 
				
				ReceiptPrinterCP : ReceiptPrinterCP { 
					using ports : 
						printerData : OrderIPT ;
				} 
				
				MenuDisplayCP : MenuDisplayCP { 
					using ports : 
						enabled : BooleanIPT ; 
						orderProducts : OrderItemArrayOPT ;
				} 
			
			connectors : 
				sensorData : SensorCN bindings httpClient_TotemSensors = sensors_Component ; 
				printerData : OrderCN bindings orderToPrint = printerData ; 
				enabled : BooleanCN bindings enableDisplay = enabled ; 
				orderProducts : OrderItemArrayCN bindings orderProducts = selectedProducts ; 
			
			delegations : 
				httpClient_TotemControllerToProductServer to httpClient_TotemToProductServer 
				httpClient_TotemControllerToOrderServer to httpClient_TotemToOrderServer 
				httpClient_TotemControllerToBiometricServer to httpClient_TotemToBiometricServer
		}
	}
	
	component def TotemFlowControllerCP { 
		ports : 
			httpClient_TotemControllerToOrderServer : HTTPClientP ; 
			httpClient_TotemControllerToProductServer : HTTPClientP ; 
			httpClient_TotemControllerToBiometricServer : HTTPClientP ; 
			httpClient_TotemSensors : HTTPClientP ; 
			selectedProducts : OrderItemArrayIPT ; 
			enableDisplay : BooleanOPT ; 
			orderToPrint : OrderOPT ;
	} 
	
	boundary component def MenuDisplayCP { 
		ports : 
			enabled : BooleanIPT ; 
			orderProducts : OrderItemArrayOPT ;
	} 
	
	boundary component def ReceiptPrinterCP { 
		ports : 
			printerData : OrderIPT ;
	} 
	
	component def PickupStationCP { 
		ports : 
			httpClient_PickupToOrderServer : HTTPClientP ; 
			httpClient_PickupToBiometricServer : HTTPClientP ; 
			
		configuration { 
			components : 
				PickupDisplayCP : PickupDisplayCP { 
					using ports : 
						orderReadyList : OrderItemArrayIPT ;
				} 
				
				PickupFlowControllerCP : PickupFlowControllerCP { 
					using ports : 
						compartmentToMove : IntOPT ; 
						compartmentArrived : BooleanIPT ; 
						readyOrders : OrderItemArrayOPT ; 
						httpClient_PickupControllerToBiometricServer : HTTPClientP ; 
						biometricRawIPT_Barcode : BiometricRawIPT ; 
						sensorActive_Barcode : BooleanOPT ; 
						orderAvailableController : PickupOrderAddedIPT ; 
						compartmentCMDOpt : CompartmentCMDOPT ; 
						pickupDetectedController : BooleanIPT ; 
						httpClient_PickupSensors : HTTPClientP ; 
						httpClient_PickupControllerToOrderServer : HTTPClientP ;
				} 
				
				BiometricSensorsCP : BiometricSensorsCP { 
					using ports : 
						sensors_Component : SensorIPT ;
				} 
				
				BarcodeReaderCP : BarcodeReaderCP { 
					using ports : 
						active_Barcode : BooleanIPT ; 
						biometricRaw_Barcode : BiometricRawOPT ;
				} 
				
				PickupConveyorCP : PickupConveyorCP {
					using ports : 
						compartmentID : IntIPT ; 
						arrivedAtCompartment : BooleanOPT ;
				} 
				
				CompartmentActuatorCP : CompartmentActuatorCP { 
					using ports : 
						compartmentCMD : CompartmentCMDIPT ; 
						orderAvailable : PickupOrderAddedOPT ; 
						pickupDetectedActuator : BooleanOPT ;
				} 
			
			connectors : 
				sensorsData : SensorCN bindings httpClient_PickupSensors = sensors_Component ; 
				readyOrdersCN : OrderItemArrayCN bindings readyOrders = orderReadyList ; 
				barcodeData : BiometricRawCN bindings biometricRaw_Barcode = biometricRawIPT_Barcode ; 
				activeBarcode : BooleanCN bindings sensorActive_Barcode = active_Barcode ; 
				compartmentCommand : CompartmentCMDCN bindings compartmentCMDOpt = compartmentCMD ; 
				orderAdded : PickupOrderAddedCN bindings orderAvailable = orderAvailableController ; 
				pickupDetected : BooleanCN bindings pickupDetectedActuator = pickupDetectedController ; 
				compartment : IntCN bindings compartmentToMove = compartmentID ; 
				moved : BooleanCN bindings arrivedAtCompartment = compartmentArrived ; 
			
			delegations : 
				httpClient_PickupControllerToOrderServer to httpClient_PickupToOrderServer
				 httpClient_PickupControllerToBiometricServer to httpClient_PickupToBiometricServer
		}
	}
	
	component def PickupFlowControllerCP { 
		ports : 
			compartmentToMove : IntOPT ;
			compartmentArrived : BooleanIPT ; 
			readyOrders : OrderItemArrayOPT ; 
			httpClient_PickupControllerToBiometricServer : HTTPClientP ; 
			biometricRawIPT_Barcode : BiometricRawIPT ; 
			sensorActive_Barcode : BooleanOPT ; 
			orderAvailableController : PickupOrderAddedIPT ; 
			compartmentCMDOpt : CompartmentCMDOPT ; 
			pickupDetectedController : BooleanIPT ; 
			httpClient_PickupSensors : HTTPClientP ; 
			httpClient_PickupControllerToOrderServer : HTTPClientP ;
	}
	
	component def PickupConveyorCP { 
		ports : 
			compartmentID : IntIPT ; 
			arrivedAtCompartment : BooleanOPT ;
	}
	
	component def CompartmentActuatorCP {
		ports : 
			compartmentCMD : CompartmentCMDIPT ;
			orderAvailable : PickupOrderAddedOPT ; 
			pickupDetectedActuator : BooleanOPT ; 
		
		configuration { 
			components : 
				PickupSensorsCP : PickupSensorsCP { 
					using ports : 
						pickupDetected : BooleanOPT ;
				} 
			
			delegations : 
				pickupDetected to pickupDetectedActuator
		} 
	} 
	
	boundary component def PickupSensorsCP { 
		ports : 
			pickupDetected : BooleanOPT ;
	} 
	
	boundary component def BarcodeReaderCP { 
		ports : 
			active_Barcode : BooleanIPT ; 
			biometricRaw_Barcode : BiometricRawOPT ;
	}
	
	boundary component def PickupDisplayCP { 
		ports : 
			orderReadyList : OrderItemArrayIPT ;
	} 
	
	activity def RetrieveProductAC ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) { 
		body { 
			actions : 
				BuildRetrieveProductQueryAN : BuildRetrieveProductQueryAN { 
					using pins : 
						req : HTTPRequestDT ;
				} 
				
				BuildRetrieveProductResponseAN : BuildRetrieveProductResponseAN { 
					using pins : 
						res : DBResponseDT ;
				} 
			
			delegate p2 to BuildRetrieveProductQueryAN 
			delegate p0 to req 
			delegate p3 to res
			delegate p1 to BuildRetrieveProductResponseAN
		}
	} 
	
	action def BuildRetrieveProductQueryAN ( req : HTTPRequestDT ) : DBQueryDT { 
		constraint : 
			post-condition BuildRetrieveProductQueryEQ 
		delegate req to req 
		delegate BuildRetrieveProductQueryAN to query
	} 
	
	action def BuildRetrieveProductResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT { 
		constraint : 
			post-condition BuildRetrieveProductResponseEQ 
		delegate dbRes to dbRes 
		delegate BuildRetrieveProductResponseAN to res
	} 
	
	constraint BuildRetrieveProductQueryEQ ( req : HTTPRequestDT ) : ( query : DBQueryDT ) { } 
	constraint BuildRetrieveProductResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def DeleteProductAC ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) { 
		body { 
			actions : 
				BuildDeleteProductQueryAN : BuildDeleteProductQueryAN { 
					using pins : 
						req : HTTPRequestDT ;
				} 
				
				BuildDeleteProductResponseAN : BuildDeleteProductResponseAN { 
					using pins : 
						res : DBResponseDT ;
				} 
			
			delegate p2 to BuildDeleteProductQueryAN 
			delegate p0 to req 
			delegate p3 to res
			delegate p1 to BuildDeleteProductResponseAN
		}
	} 
	
	action def BuildDeleteProductQueryAN ( req : HTTPRequestDT ) : DBQueryDT { 
		constraint : 
			post-condition BuildDeleteProductQueryEQ 
		delegate req to req 
		delegate BuildDeleteProductQueryAN to qry
	} 
	
	action def BuildDeleteProductResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT { 
		constraint : 
			post-condition BuildDeleteProductResponseEQ 
		delegate dbRes to dbRes 
		delegate BuildDeleteProductResponseAN to res
	} 
	
	constraint BuildDeleteProductQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { } 
	constraint BuildDeleteProductResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def CreateProductCP ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) { 
		body { 
			actions : 
				BuildCreateProductQueryAN : BuildCreateProductQueryAN { 
					using pins : 
						req : HTTPRequestDT ;
				} 
				
				BuildCreateProductResponseAN : BuildCreateProductResponseAN { 
					using pins : 
						res : DBResponseDT ;
				} 
			
			delegate p2 to BuildCreateProductQueryAN
			delegate p0 to req
			delegate p3 to res
			delegate p1 to BuildCreateProductResponseAN
		}
	} 
	
	action def BuildCreateProductQueryAN ( req : HTTPRequestDT ) : DBQueryDT { 
		constraint : 
			post-condition BuildCreateProductQueryEQ 
			pre-condition BuildCreateProductQueryPriceGTZeroEQ
		delegate req to req 
		delegate BuildCreateProductQueryAN to qry
	delegate req to reqVerify } 
	
	action def BuildCreateProductResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT { 
		constraint : 
			post-condition BuildCreateProductResponseEQ 
		delegate dbRes to dbRes 
		delegate BuildCreateProductResponseAN to res
	} 
	
	constraint BuildCreateProductQueryPriceGTZeroEQ ( reqVerify : HTTPRequestDT ) { }
	constraint BuildCreateProductQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { } 
	constraint BuildCreateProductResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def UpdateProductCP ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) { 
		body { 
			actions : 
				BuildUpdateProductQueryAN : BuildUpdateProductQueryAN { 
					using pins : 
						req : HTTPRequestDT ;
				} 
				
				BuildUpdateProductResponseAN : BuildUpdateProductResponseAN { 
					using pins : 
						res : DBResponseDT ;
				} 
			
			delegate p2 to BuildUpdateProductQueryAN
			delegate p0 to req
			delegate p3 to res
			delegate p1 to BuildUpdateProductResponseAN
		}
	} 
	
	action def BuildUpdateProductQueryAN ( req : HTTPRequestDT ) : DBQueryDT { 
		constraint : 
			post-condition BuildUpdateProductQueryEQ 
			pre-condition BuildUpdateProductQueryPriceGTZeroEQ
		delegate req to req
		delegate BuildUpdateProductQueryAN to qry
		delegate req to reqVerify
	} 
	
	action def BuildUpdateProductResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT { 
		constraint : 
			post-condition BuildUpdateProductResponseEQ 
		delegate dbRes to dbRes 
		delegate BuildUpdateProductResponseAN to res
	} 
	
	constraint BuildUpdateProductQueryPriceGTZeroEQ ( reqVerify : HTTPRequestDT ) { }
	constraint BuildUpdateProductQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { } 
	constraint BuildUpdateProductResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }

	activity def GetMachineStockCP ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) { 
		body { 
			actions : 
				BuildGetMachineStockQueryAN : BuildGetMachineStockQueryAN { 
					using pins : 
						req : HTTPRequestDT ;
				} 
				
				BuildGetMachineStockResponseAN : BuildGetMachineStockResponseAN { 
					using pins : 
						res : DBResponseDT ;
				} 
			
			delegate p2 to BuildGetMachineStockQueryAN
			delegate p0 to req
			delegate p3 to res
			delegate p1 to BuildGetMachineStockResponseAN
		}
	} 
	
	action def BuildGetMachineStockQueryAN ( req : HTTPRequestDT ) : DBQueryDT { 
		constraint : 
			post-condition BuildGetMachineStockQueryEQ
		delegate req to req 
		delegate BuildGetMachineStockQueryAN to qry
	} 
	
	action def BuildGetMachineStockResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT { 
		constraint : 
			post-condition BuildGetMachineStockResponseEQ 
		delegate dbRes to dbRes 
		delegate BuildGetMachineStockResponseAN to res
	} 
	
	constraint BuildGetMachineStockQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { } 
	constraint BuildGetMachineStockResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
		
} 

package FoodFastPorts { 
	import SysADLTypes ;
	
	port def DBQueryIPT { 
		flow in DBQueryDT
	} 
	port def DBQueryOPT { 
		flow out DBQueryDT
	} 
	
	port def DBResponseIPT { 
		flow in DBResponseDT 
	} 
	port def DBResponseOPT { 
		flow out DBResponseDT
	} 
	
	port def DBServiceP { 
		ports : 
			queryIPT : DBQueryIPT ; 
			responseOPT : DBResponseOPT ;
	} 
	port def DBClientP { 
		ports : 
			queryOPT : DBQueryOPT ; 
			responseIPT : DBResponseIPT ;
	} 
	
	port def HTTPRequestIPT { 
		flow in HTTPRequestDT 
	} 
	port def HTTPRequestOPT { 
		flow out HTTPRequestDT
	} 
	
	port def HTTPResponseIPT { 
		flow in HTTPResponseDT 
	}
	port def HTTPResponseOPT { 
		flow out HTTPResponseDT
	} 
	
	port def HTTPServiceP {
		ports : 
			requestIPT : HTTPRequestIPT ; 
			responseOPT : HTTPResponseOPT ;
	} 
	port def HTTPClientP { 
		ports : 
			requestOPT : HTTPRequestOPT ;
			responseIPT : HTTPResponseIPT ;
	} 
	
	port def BiometricTypeIPT { 
		flow in BiometricTypeEnum
	} 
	port def BiometricTypeOPT { 
		flow out BiometricTypeEnum
	} 
	
	port def BiometricRawIPT {
		flow in BiometricRawDT
	} 
	port def BiometricRawOPT { 
		flow out BiometricRawDT
	} 
	
	port def UserIPT { 
		flow in UserDT
	} 
	port def UserOPT { 
		flow out UserDT
	} 
	
	port def BooleanIPT { 
		flow in Boolean
	} 
	port def BooleanOPT { 
		flow out Boolean
	} 
	
	port def SensorIPT { 
		ports : 
			biometricType : BiometricRawOPT ; 
			biometriRaw : BiometricTypeIPT ;
	} 
	
	port def StringIPT { 
		flow in String
	} 
	port def StringOPT { 
		flow out String
	}
	
	port def IntIPT { 
		flow in Int
	} 
	port def IntOPT { 
		flow out Int
	} 
	
	port def OrderIPT { 
		flow in OrderDT
	} 
	port def OrderOPT { 
		flow out OrderDT
	} 
	
	port def OrderProcessingIPT { 
		flow in OrderProcessingDT
	} 
	port def OrderProcessingOPT { 
		flow out OrderProcessingDT
	} 
	
	port def OrderItemArrayIPT { 
		flow in OrderItemArrayDT
	} 
	port def OrderItemArrayOPT { 
		flow out OrderItemArrayDT
	} 
	
	port def RealIPT { 
		flow in Real
	} 
	port def RealOPT { 
		flow out Real
	} 
	
	port def OrderChargeIPT { 
		flow in OrderChargeDT
	} 
	port def OrderChargeOPT { 
		flow out OrderChargeDT
	} 
	
	port def PaymentStatusIPT { 
		flow in PaymentStatusEnum
	} 
	port def PaymentStatusOPT { 
		flow out PaymentStatusEnum
	} 
	
	port def DispenserProductIPT { 
		flow in DispenserProductDT
	} 
	port def DispenserProductOPT { 
		flow out DispenserProductDT
	} 
	
	port def CompartmentCMDIPT { 
		flow in CompartmentCMDEnum
	} 
	port def CompartmentCMDOPT { 
		flow out CompartmentCMDEnum
	} 
	
	port def PickupOrderAddedIPT { 
		flow in PickupOrderAddedDT
	} 
	port def PickupOrderAddedOPT { 
		flow out PickupOrderAddedDT
	} 
} 

Requirement ManageUsersFR ( 1 ) { 
	text = "\"O sistema deve permitir o gerenciamento de usurios.\""
	
	Requirement UpdateUserFR ( 1.2 ) { 
		text = "O sistema deve permitir que o usurio atualize a conta no sistema com todos os dados necessrios." 
		satisfied by FoodFastComponents.UserUpdateCP ; 
		
		Requirement RegisterPaymentMethodsFR_ForUpdate ( 1.2.2 ) { 
			text = "O sistema deve permitir que o usurio atualize seus mtodos de pagamento." 
		} 
		
		Requirement RegisterPersonalInfoFR_ForUpdate ( 1.2.1 ) { 
			text = "O sistema deve permitir que o usurio atualize suas informaes pessoais."
		}
	}
	
	Requirement RegisterUserFR ( 1.1 ) { 
		text = "O sistema deve permitir que o usurio realize o cadastro no sistema com todos os dados necessrios." 
		satisfied by FoodFastComponents.UserCreateCP ; 
		
		Requirement RegisterPersonalInfoFR_ForRegister ( 1.1.1 ) { 
			text = "O sistema deve permitir que o usurio cadastre suas informaes pessoais." 
		} 
		
		Requirement RegisterPaymentMethodsFR_ForRegister ( 1.1.2 ) { 
			text = "O sistema deve permitir que o usurio cadastre seus mtodos de pagamento." 
		}
	}
	
	Requirement RetrieveUserFR ( 1.3 ) { 
		text = "O sistema deve permitir que o usurio visualize suas informaes cadastradas."
		satisfied by FoodFastComponents.UserRetrieveCP ; 
	} 
	
	Requirement DeleteUserFR ( 1.4 ) { 
		text = "O sistema deve permitir que o usurio remova sua conta."
		satisfied by FoodFastComponents.UserDeleteCP ; 
	} 

	Requirement LoginUserFR ( 1.5 ) { 
		text = "\"O sistema deve permitir que o usurio se autentique em sua conta com CPF e senha registrados.\""
		satisfied by FoodFastComponents.UserAuthCP ; 
	} 
} 

 
Requirement ManageBiometricDataFR ( 2 ) { 
	text = "\"O sistema deve permitir o gerenciamento dos dados biomtricos dos usurios.\"" 
	
	Requirement RegisterBiometricDataFR ( 2.1 ) { 
		text = "\"O sistema deve permitir que o usurio registre seus dados biomtricos no sistema.\""
		satisfied by FoodFastComponents.RegisterBiometricCP ; 
	} 
	
	Requirement RemoveBiometricDataFR ( 2.2 ) { 
		text = "\"O sistema deve permitir que o usurio remova seus dados biomtricos cadastrados no sistema.\""
		satisfied by FoodFastComponents.RemoveBiometricCP ; 
	}
} 

 
Requirement FingerprintAuthenticationFR ( 3.1 ) {
	text = "\"O sistema deve permitir que o usurio realize autenticao utilizando sua impresso digital.\"" 
	derive OrderManagementFR.CreateOrderInMachineFR.AuthenticateBiometricFR ; 
	
	Requirement CaptureFingerprintFR ( 3.1.1 ) { 
		text = "\"O sistema deve capturar a impresso digital do usurio utilizando o sensor biomtrico apropriado.\""
		satisfied by FoodFastComponents.FingerprintSensorCP ; 
	} 
	
	Requirement RecognizeFingerprintFR ( 3.1.2 ) { 
		text = "\"O sistema deve comparar a digital capturada com os dados biomtricos registrados para validar a identidade do usurio.\""
		satisfied by FoodFastComponents.BiometricRecognitionCP ; 
	}
} 

Requirement FacialAuthenticationFR ( 3.2 ) { 
	text = "\"O sistema deve permitir que o usurio realize autenticao utilizando reconhecimento facial.\"" 
	derive OrderManagementFR.CreateOrderInMachineFR.AuthenticateBiometricFR ;
	
	Requirement CaptureFaceFR ( 3.2.1 ) { 
		text = "\"O sistema deve capturar a imagem facial do usurio utilizando a cmera disponibilizada pelo dispositivo.\""
		satisfied by FoodFastComponents.FaceCameraCP ; 
	} 
	
	Requirement RecognizeFaceFR ( 3.2.2 ) { 
		text = "\"O sistema deve comparar a imagem facial capturada com os dados biomtricos registrados para validar a identidade do usurio.\""
		satisfied by FoodFastComponents.BiometricRecognitionCP ;
	}
}

Requirement OrderManagementFR ( 4 ) { 
	text = "\"O sistema deve permitir o gerenciamento completo dos pedidos realizados pelos usurios.\"" 
	
	Requirement UpdateOrderFR ( 4.3 ) { 
		text = "\"O sistema deve permitir que funcionrios ou subsistemas responsveis atualizem pedidos em processamento.\""
		satisfied by FoodFastComponents.UpdateOrderCP ; 
	}
	
	Requirement ViewOrderFR ( 4.2 ) { 
		text = "\"O sistema deve permitir que o usurio visualize seus pedidos.\""
		satisfied by FoodFastComponents.RetrieveOrderCP ; 
	} 
	
	Requirement CreateOrderInMachineFR ( 4.1 ) { 
		text = "\"O sistema deve permitir que o usurio crie pedidos em mquinas apropriadas, realizando o clculo do valor devido conforme os itens selecionados.\"" 
		satisfied by FoodFastComponents.CreateOrderCP ; 
		
		Requirement AuthenticateBiometricFR ( 3 ) { 
			text = "\"O sistema deve permitir que o usurio realize autenticao por biometria.\""
			derive OrderPickupFR.IdentifyUserForPickupFR.IdentifyPickupRequestFR ; 
		} 
	} 
	
	Requirement ProcessOrderFR ( 4.4 ) { 
		text = "\"O sistema deve processar pedidos conforme o tipo de mquina e o fluxo operacional necessrio.\"" 
		
		Requirement ChargeOrderFR ( 4.4.1 ) { 
			text = "\"O sistema deve realizar a cobrana do pedido conforme o fluxo operacional da mquina utilizada, podendo ocorrer antes ou depois do uso, conforme as regras do tipo de pedido.\""
			satisfied by FoodFastComponents.PaymentProcessingCP ; 
		} 
		
		Requirement CheckPendingPaymentsFR ( 4.4.2 ) { 
			text = "\"O sistema deve verificar se o usurio possui valores pendentes de pedidos anteriores que ainda no foram pagos, bloqueando a continuidade do processamento caso existam pendncias.\""
			satisfied by FoodFastComponents.CheckDebtsCP ; 
		} 
		
		Requirement MachineSpecificProcessingFR ( 4.4.3 ) {
			text = "\"O sistema deve executar o processamento adicional especfico ao tipo de mquina na qual o pedido foi realizado.\""
		}
	} 
} 

Requirement CreateOrderInTotemFR ( 4.1.1 ) { 
	text = "\"O sistema deve permitir que o usurio realize pedidos em totens, selecionando itens que sero preparados na cozinha.\"" 
	satisfied by FoodFastComponents.TotemCP ; 
	derive OrderManagementFR.CreateOrderInMachineFR ; 
	
	Requirement CheckItemAvailabilityFR ( 4.1.1.1 ) { 
		text = "\"O sistema deve verificar a disponibilidade dos itens selecionados antes de confirmar o pedido.\""
	} 
	
	Requirement GenerateOrderReceiptFR ( 4.1.1.2 ) { 
		text = "\"O sistema deve gerar a nota de compra contendo o nmero do pedido, a cozinha de roteamento e o cdigo de barras para retirada.\""
		satisfied by FoodFastComponents.ReceiptPrinterCP ; 
	} 
	
	Requirement ChargeBeforeConfirmationFR ( 4.1.1.3 ) { 
		text = "\"O sistema deve realizar a cobrana do pedido antes da confirmao final.\""
	}
} 

Requirement ProcessOrderFromTotemFR ( 4.4.3.1 ) { 
	text = "\"O sistema deve processar pedidos realizados em totens, encaminhando-os para a cozinha adequada aps a cobrana.\"" 
	derive OrderManagementFR.ProcessOrderFR.MachineSpecificProcessingFR ; 
	
	Requirement RouteOrderToKitchenFR ( 4.4.3.1.1 ) { 
		text = "\"O sistema deve encaminhar o pedido para a cozinha apropriada conforme sua categoria.\""
		satisfied by FoodFastComponents.KitchenRoutingCP ; 
	}
}

Requirement ProcessOrderFromDrinkDispenserFR ( 4.4.3.2 ) { 
	text = "\"O sistema deve processar pedidos realizados em mquinas de bebidas prontas, liberando a bebida aps a confirmao da cobrana.\"" 
	derive OrderManagementFR.ProcessOrderFR.MachineSpecificProcessingFR ;
} 

Requirement ProcessOrderFromSnackDispenserFR ( 4.4.3.3 ) { 
	text = "\"O sistema deve processar pedidos realizados em mquinas de lanches prontos, liberando o lanche aps a confirmao da cobrana.\"" 
	derive OrderManagementFR.ProcessOrderFR.MachineSpecificProcessingFR ;
} 

Requirement ProcessOrderFromTapFR ( 4.4.3.4 ) { 
	text = "\"O sistema deve processar pedidos realizados em torneiras de bebidas cobradas por volume, finalizando o clculo e cobrana aps o uso.\"" 
	derive OrderManagementFR.ProcessOrderFR.MachineSpecificProcessingFR ; 
	
	Requirement CalculateFinalTapCostFR ( 4.4.3.4.1 ) { 
		text = "\"O sistema deve calcular o custo final do pedido com base no volume total de bebida consumido.\""
		satisfied by FoodFastComponents.PriceCalculationCP ; 
	}
} 

Requirement CreateOrderInDrinkDispenserFR ( 4.1.2 ) { 
	text = "\"O sistema deve permitir que o usurio realize pedidos em mquinas de bebidas prontas (dispenser).\"" 
	satisfied by FoodFastComponents.DispenserDrinkMachineCP ; 
	derive OrderManagementFR.CreateOrderInMachineFR ; 
	
	Requirement CheckDrinkAvailabilityFR ( 4.1.2.1 ) { 
		text = "\"O sistema deve verificar a disponibilidade da bebida selecionada antes de permitir a confirmao.\""
	} 
	
	Requirement ChargeBeforeConfirmationFR ( 4.1.2.2 ) { 
		text = "\"O sistema deve realizar a cobrana do pedido antes da liberao da bebida.\""
	}
} 

Requirement CreateOrderInSnackDispenserFR ( 4.1.3 ) { 
	text = "\"O sistema deve permitir que o usurio realize pedidos em mquinas de lanches prontos.\"" 
	satisfied by FoodFastComponents.DispenserSnackMachineCP ; 
	derive OrderManagementFR.CreateOrderInMachineFR ; 
	
	Requirement CheckSnackAvailabilityFR ( 4.1.3.1 ) { 
		text = "\"O sistema deve verificar a disponibilidade do lanche selecionado antes de permitir a confirmao.\""
	} 
	
	Requirement ChargeBeforeConfirmationFR ( 4.1.3.2 ) { 
		text = "\"O sistema deve realizar a cobrana do pedido antes da liberao do lanche.\""
	}
} 

Requirement CreateOrderInTapFR ( 4.1.4 ) { 
	text = "\"O sistema deve permitir que o usurio realize pedidos em torneiras de bebidas cobradas por volume consumido.\"" 
	satisfied by FoodFastComponents.TapMachineCP ; 
	derive OrderManagementFR.CreateOrderInMachineFR ; 
	
	Requirement CheckTapAvailabilityFR ( 4.1.4.1 ) { 
		text = "\"O sistema deve verificar a disponibilidade da bebida na torneira antes ou durante o uso, conforme necessrio.\""
	} 
	
	Requirement MeasureDispensedVolumeFR ( 4.1.4.2 ) { 
		text = "\"O sistema deve medir o volume de bebida dispensado, em mililitros, durante o uso.\""
		satisfied by FoodFastComponents.TapActuatorCP ; 
	} 
	
	Requirement PostUseChargeFR ( 4.1.4.3 ) { 
		text = "\"O sistema deve realizar a cobrana do pedido somente aps o trmino do uso.\""
	}
} 

Requirement OrderPickupFR ( 5 ) { 
	text = "O sistema deve gerenciar todo o processo de retirada de pedidos utilizando a esteira automatizada, garantindo identificao segura do usurio, acesso controlado aos compartimentos e rastreabilidade completa do pedido." 
	
	Requirement ManageConveyorFR ( 5.1 ) { 
		text = "O sistema deve gerenciar a esteira automatizada, organizando compartimentos, exibindo pedidos disponveis e controlando o fluxo de entrega." 
		
		Requirement SeparateConveyorCompartmentsFR ( 5.1.1 ) { 
			text = "O sistema deve organizar a esteira em compartimentos individuais para armazenamento dos pedidos prontos."
			satisfied by FoodFastComponents.CompartmentActuatorCP ; 
		} 
		
		Requirement DisplayPickupOrdersFR ( 5.1.2 ) { 
			text = "O sistema deve exibir na interface da esteira todos os pedidos disponveis, pendentes ou em preparao relacionados ao ponto de retirada."
			satisfied by FoodFastComponents.PickupDisplayCP ; 
		} 
		
		Requirement UpdatePickupOrderStatusFR ( 5.1.3 ) { 
			text = "O sistema deve atualizar automaticamente o status do pedido de acordo com o fluxo da esteira e permitir ajustes pelos funcionrios."
		}
	} 
	
	Requirement IdentifyUserForPickupFR ( 5.2 ) { 
		text = "O sistema deve identificar qual pedido pertence ao usurio no ponto de retirada, utilizando mecanismos de autenticao biomtrica ou cdigo de barras." 
		
		Requirement IdentifyPickupRequestFR ( 5.2.1 ) { 
			text = "O sistema deve identificar o pedido associado ao usurio por meio de autenticao informada, como biometria ou cdigo de barras."
		} 
		
		Requirement VerifyPickupRequestFR ( 5.2.2 ) { 
			text = "O sistema deve verificar se o identificador obtido corresponde a um pedido disponvel e autorizado para retirada."
		}
	}
	
	Requirement LocatePickupOrderFR ( 5.3 ) { 
		text = "O sistema deve localizar o compartimento onde o pedido identificado est armazenado."
	} 
	
	Requirement ProcessConveyorDeliveryFR ( 5.4 ) {
		text = "O sistema deve executar as aes necessrias para entregar o pedido ao usurio, incluindo mover a esteira e abrir automaticamente o compartimento correspondente." 
		
		Requirement MoveConveyorToUserFR ( 5.4.1 ) { 
			text = "O sistema deve mover a esteira at que o compartimento do pedido esteja posicionado em frente ao usurio identificado."
			satisfied by FoodFastComponents.PickupConveyorCP ; 
		} 
		
		Requirement OpenConveyorCompartmentFR ( 5.4.2 ) { 
			text = "O sistema deve abrir automaticamente o compartimento correspondente ao pedido aps a identificao vlida do usurio."
			satisfied by FoodFastComponents.CompartmentActuatorCP ; 
		} 
		
		Requirement ConfirmOrderPickupFR ( 5.4.3 ) { 
			text = "O sistema deve detectar quando o pedido foi retirado e registrar a concluso da entrega."
		}
	} 
} 

Requirement IdentifyPickupByBarcodeFR ( 5.2.1.1 ) { 
	text = "O sistema deve identificar o pedido do usurio utilizando o cdigo de barras fornecido no momento da retirada." 
	satisfied by FoodFastComponents.BarcodeReaderCP ; 
	derive OrderPickupFR.IdentifyUserForPickupFR.IdentifyPickupRequestFR ; 
	
	Requirement CapturePickupBarcodeFR ( 5.2.1.1.1 ) { 
		text = "O sistema deve capturar o cdigo de barras apresentado pelo usurio no ponto de retirada."
	} 
	
	Requirement InterpretPickupBarcodeFR ( 5.2.1.1.2 ) { 
		text = "O sistema deve interpretar o cdigo de barras capturado e extrair o identificador do pedido associado ao usurio."
	}
}

Requirement QualityNFR ( 6 ) { 
	text = "O sistema deve atender requisitos robustos de segurana, desempenho, disponibilidade, usabilidade, escalabilidade e manutenibilidade, com nveis mensurveis definidos nos NFRs relacionados." 
	
	Requirement SecurityNFR ( 6.1 ) { 
		text = "O sistema deve implementar mecanismos de segurana que previnam acesso no autorizado, garantam criptografia dos dados sensveis e minimizem riscos de fraude e erros de identificao." 
		
		Requirement DataSecurityNFR ( 6.1.1 ) { 
			text = "Todos os dados sensveis dos usurios, incluindo informaes de pagamento, devem ser armazenados e transmitidos utilizando criptografia forte (mnimo AES-256 ou equivalente)."
		} 
		
		Requirement FraudSecurityNFR ( 6.1.2 ) { 
			text = "O sistema deve detectar e bloquear tentativas suspeitas de fraude durante os processos de autenticao e pagamento, registrando eventos para auditoria."
		} 
		
		Requirement RecognitionSecurityNFR ( 6.1.3 ) { 
			text = "Os mtodos de reconhecimento biomtrico devem manter preciso elevada, minimizando falsos positivos e falsos negativos conforme mtricas aceitas (FAR < 0.01%, FRR < 1%)."
		}
	} 
	
	Requirement PerformanceNFR ( 6.2 ) { 
		text = "O sistema deve realizar processamento de dados e atender requisies dentro dos tempos mximos especificados nos NFRs derivados." 
		
		Requirement RecognitionTimeNFR ( 6.2.1 ) { 
			text = "O reconhecimento facial ou digital deve ser concludo em at 3 segundos, considerando captura + processamento."
		} 
		
		Requirement PaymentTimeNFR ( 6.2.2 ) {
			text = "O sistema deve processar transaes de pagamento com tempo de resposta inferior a 5 segundos para cada requisio."
		}
	} 
	
	Requirement AvailableNFR ( 6.3 ) { 
		text = "O sistema deve manter disponibilidade mnima de 99,9% ao longo do ano, incluindo totens, mquinas de pedido e esteiras automatizadas." 
		
		Requirement MachineMonitoringNFR ( 6.3.1 ) { 
			text = "Totens, mquinas e mdulos de esteira devem ser monitorados constantemente para garantir que permaneam operacionais, com alertas automticos em caso de falhas."
		}
	} 
	
	Requirement UsabilityNFR ( 6.4 ) { 
		text = "O sistema deve ser intuitivo e fcil de usar para pblicos de diferentes idades e perfis, reduzindo a necessidade de interveno humana." 
		
		Requirement AccessibilityNFR ( 6.4.1 ) {
			text = "Os recursos do sistema devem ser acessveis a usurios com deficincias auditivas, visuais, motoras ou cognitivas, seguindo diretrizes WCAG 2.1 AA." 
		} 
		
		Requirement ResponsivenessNFR ( 6.4.2 ) { 
			text = "As interfaces do sistema devem ser responsivas e adaptveis a diferentes tamanhos e orientaes de tela, garantindo boa usabilidade em totens, dispositivos mveis e desktops."
		}
	} 
	
	Requirement ScalabilityNFR ( 6.5 ) { 
		text = "O sistema deve suportar aumento de carga, expanso de dispositivos e adio de novas mquinas sem necessidade de alteraes estruturais significativas."
	} 
	
	Requirement MaintainabilityNFR ( 6.6 ) { 
		text = "O sistema deve possuir processos bem definidos de atualizao, registro de erros e manuteno corretiva, permitindo intervenes rpidas sem comprometer a operao."
	}
} 

Requirement CompatibilityNFR ( 6.4.2.1 ) { 
	text = "O sistema deve ser compatvel com navegadores modernos e sistemas operacionais mveis (iOS e Android)." 
	derive QualityNFR.UsabilityNFR.ResponsivenessNFR ;
} 

Requirement ProductManagementFR ( 7 ) { 
	text = "\"O sistema deve oferecer um conjunto integrado de funcionalidades para cadastrar, atualizar, consultar e remover produtos, alm de permitir a verificao de disponibilidade conforme necessrio para operao das mquinas.\"" 
	
	Requirement CreateProductFR ( 7.1 ) { 
		text = "\"O sistema deve permitir o cadastro de um novo produto contendo nome, descrio, categoria e preo, garantindo a persistncia das informaes.\""
		satisfied by FoodFastComponents.CreateProductCP ; 
	} 
	
	Requirement UpdateProductFR ( 7.2 ) { 
		text = "\"O sistema deve permitir a modificao dos dados de um produto previamente cadastrado, mantendo histrico consistente no banco de dados.\""
		satisfied by FoodFastComponents.UpdateProductCP ; 
	} 
	
	Requirement RetrieveProductFR ( 7.3 ) { 
		text = "\"O sistema deve permitir a consulta de produtos individualmente ou em conjunto, retornando informaes essenciais como nome, descrio, categoria, preo e disponibilidade quando aplicvel.\""
		satisfied by FoodFastComponents.RetrieveProductCP ; 
	} 
	
	Requirement DeleteProductFR ( 7.4 ) { 
		text = "\"O sistema deve permitir a remoo de um produto do catlogo, garantindo que os dados sejam excludos de forma consistente.\""
		satisfied by FoodFastComponents.DeleteProductCP ; 
	} 
	
	Requirement CheckProductAvailabilityFR ( 7.5 ) { 
		text = "\"O sistema deve permitir a verificao da disponibilidade de um produto, considerando informaes provenientes de estoque interno ou processamento em mquinas especficas.\""
		satisfied by FoodFastComponents.GetMachineStockCP ; 
	}
}