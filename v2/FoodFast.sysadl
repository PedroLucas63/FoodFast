Model SysADLModel ;

package SysADLTypes {
	value type Int { } 
	value type Boolean { } 
	value type String { } 
	value type Void { } 
	value type Real { } 
	
	dimension Time 
	
	unit Second { 
		dimension = Time
	} 
	unit Millisecond { 
		dimension = Time
	}
	unit Minute { 
		dimension = Time
	} 
	unit Hour { 
		dimension = Time
	} 
	
	dimension Date 
	
	unit Day { 
		dimension = Date
	} 
	unit Month { 
		dimension = Date
	} 
	unit Year { 
		dimension = Date
	} 
	
	value type MillisecondsVT { 
		unit = Millisecond 
		dimension = Time
	} 
	value type SecondsVT { 
		unit = Second 
		dimension = Time
	} 
	value type MinutesVT { 
		unit = Minute 
		dimension = Time
	} 
	value type HoursVT { 
		unit = Hour 
		dimension = Time
	} 
	
	value type DaysVT { 
		unit = Day 
		dimension = Date
	} 
	value type MonthsVT { 
		unit = Month 
		dimension = Date
	} 
	value type YearsVT { 
		unit = Year 
		dimension = Date
	} 
	
	datatype TimestampDT { 
		attributes : 
			^value : MillisecondsVT ;
	} 
	datatype DateDT { 
		attributes : 
			day : DaysVT ;
			month : MonthsVT ; 
			year : YearsVT ;
	} 
	datatype TimeDT { 
		attributes : 
			hour : HoursVT ; 
			minute : MinutesVT ; 
			second : SecondsVT ;
	} 
	datatype DateTimeDT { 
		attributes : 
			date : DateDT ; 
			time : TimeDT ;
	} 
	
	datatype DBQueryDT { 
		attributes : 
			operation : DBOperationEnum ; 
			table : String ; 
			content : String ;
	} 
	enum DBOperationEnum { 
		INSERT , 
		UPDATE , 
		DELETE , 
		SELECT
	} 
	datatype DBResponseDT { 
		attributes : 
			success : Boolean ; 
			content : String ; 
			error : String ;
	} 
	
	datatype HTTPHeaderDT { 
		attributes : 
			key : String ; 
			^value : String ;
	} 
	enum HTTPMethodEnum { 
		GET , 
		POST , 
		PUT , 
		DELETE , 
		PATCH
	} 
	datatype HTTPBodyDT { 
		attributes : 
			content : String ;
	} 
	
	datatype HTTPRequestDT { 
		attributes : 
			method : HTTPMethodEnum ; 
			path : String ; 
			header : HTTPHeaderDT ; 
			^body : HTTPBodyDT ;
	} 
	datatype HTTPResponseDT { 
		attributes : 
			statusCode : Int ; 
			header : HTTPHeaderDT ; 
			^body : HTTPBodyDT ;
	} 
	
	enum BiometricTypeEnum { 
		FINGERPRINT , 
		FACE , 
		BARCODE
	} 
	
	datatype UserDT { 
		attributes : 
			name : String ; 
			cpf : String ; 
			email : String ; 
			birthdate : DateDT ; 
			phone : String ;
			id : Int ; 
	} 
	
	datatype BiometricRawDT { 
		attributes : 
			^type : BiometricTypeEnum ; 
			data : String ;
	} 
	
	enum ProductCategoryEnum { 
		SNACK , 
		DRINK_PACKAGED , 
		DRINK_TAP , 
		MEAL
	} 
	
	datatype ProductDT { 
		attributes : 
			id : Int ; 
			name : String ; 
			description : String ; 
			category : ProductCategoryEnum ; 
			price : Real ;
	} 
	
	datatype ProductArrayDT { }
	 
	datatype StockInfoDT {
		attributes : 
			productId : Int ; 
			quantity : Int ; 
			lastUpdate : DateTimeDT ;
	machineId : Int ; } 
	
	enum MachineTypeEnum { 
		TOTEM , 
		DISPENSER , 
		TAP
	} 
	
	enum PaymentStatusEnum {
		PENDING , 
		AUTHORIZED , 
		CANCELED
	} 
	
	enum OrderStatusEnum { 
		CREATED , 
		PROCESSING , 
		READY , 
		FINISHED, 
		CANCELED
	} 
	
	datatype OrderItemDT { 
		attributes : 
			productId : Int ;
		 	quantity : Int ; 
		 	unitPrice : Real ;
	} 
	
	datatype OrderDT { 
		attributes : 
			orderId : Int ; 
			customerId : Int ; 
			createdAt : DateTimeDT ; 
			updatedAt : DateTimeDT ; 
			machineType : MachineTypeEnum ; 
			paymentStatus : PaymentStatusEnum ; 
			orderStatus : OrderStatusEnum ; 
			items : OrderItemArrayDT ;
			kitchenId : Int ; machineId : Int ; 
	} 
	
	datatype OrderItemArrayDT { } 
	
	datatype OrderProcessingDT { 
		attributes : 
			finalPrice : Real ; 
			kitchenId : Int ;
	} 
	
	datatype OrderChargeDT { 
		attributes : 
			customerId : Int ; 
			^value : Real ;
	} 
	
	datatype StockInfoArrayDT { } 
	
	datatype DispenserProductDT { 
		attributes : 
			productId : Int ; 
			authorization : Boolean ;
	} 
	
	enum CompartmentCMDEnum { 
		OPEN, 
		CLOSE
	} 
	
	datatype PickupOrderAddedDT { 
		attributes : 
			orderId : Int ; 
			pickupId : Int ;
	} 
	
	enum PaymentMethodEnum { 
		DEBIT_CARD , 
		CREDIT_CARD
	} 
	
	datatype PaymentMethodDT { 
		attributes : 
			id : Int ; 
			number : String ;
			holderName : String ;
			expirationMonth : MonthsVT ;
			expirationYear : YearsVT ;
			CVV: String ;
			method: PaymentMethodEnum;
	}
	
	datatype CredentialAccessDT { 
		attributes : 
			cpf : String ;
			password : String ;
	} 
}

package FoodFastConnectors { 
	import FoodFastPorts ;
	
	connector def DBQueryCN { 
		participants : 
			~ destination : DBQueryIPT ; 
			~ source : DBQueryOPT ; 
		flows : 
			DBQueryDT from source to destination
	} 
	
	connector def DBResponseCN { 
		participants : 
			~ destination : DBResponseIPT ; 
			~ source : DBResponseOPT ; 
		flows : 
			DBResponseDT from source to destination
	} 
	
	connector def DatabaseCN { 
		participants : 
			~ service : DBServiceP ; 
			~ client : DBClientP ; 
		configuration { 
			connectors : 
				response : DBResponseCN bindings responseOPT = responseIPT ; 
				query : DBQueryCN bindings queryOPT = queryIPT ;
		}
	} 
	
	connector def HTTPRequestCN { 
		participants : 
			~ source : HTTPRequestOPT ; 
			~ destination : HTTPRequestIPT ; 
		flows : 
			HTTPRequestDT from source to destination
	} 
	connector def HTTPResponseCN { 
		participants : 
			~ destination : HTTPResponseIPT ; 
			~ source : HTTPResponseOPT ; 
		flows : 
			HTTPResponseDT from source to destination
	} 
	
	connector def HTTPCN { 
		participants : 
			~ service : HTTPServiceP ; 
			~ client : HTTPClientP ; 
			
			configuration { 
				connectors : 
					response : HTTPResponseCN bindings responseOPT = responseIPT ; 
					request : HTTPRequestCN bindings requestOPT = requestIPT ;
			}
	} 
	
	connector def BiometricTypeCN { 
		participants : 
			~ destination : BiometricTypeIPT ; 
			~ source : BiometricTypeOPT ; 
		flows : 
			BiometricTypeEnum from source to destination
	} 
	
	connector def BiometricRawCN { 
		participants : 
			~ destination : BiometricRawIPT ;
			~ source : BiometricRawOPT ; 
		flows : 
			BiometricRawDT from source to destination
	} 
	
	connector def UserCN { 
		participants : 
			~ destination : UserIPT ; 
			~ source : UserOPT ; 
		flows : 
			UserDT from source to destination
	} 
	
	connector def BooleanCN { 
		participants : 
			~ destination : BooleanIPT ; 
			~ source : BooleanOPT ; 
		flows : 
			Boolean from source to destination
	} 
	
	connector def SensorCN { 
		participants : 
			~ client : HTTPClientP ; 
			~ server : SensorIPT ; 
			
			configuration { 
				connectors : 
					httpToBiometricType : HTTPToBiometricTypeCN bindings requestOPT = biometricType ; 
					biometricRawToHTTP : BiometricRawToHTTPCN bindings biometriRaw = responseIPT ;
			}
	} 
	
	connector def HTTPToBiometricTypeCN { 
		participants : 
			~ source : HTTPRequestOPT ; 
			~ destination : BiometricTypeIPT ; 
			
		flows : 
			HTTPRequestDT from source to destination
	} 
	
	connector def BiometricRawToHTTPCN { 
		participants : 
			~ source : BiometricRawOPT ; 
			~ destination : HTTPResponseIPT ; 
			
		flows : 
			BiometricRawDT from source to destination
	} 
	
	connector def StringCN { 
		participants : 
			~ destination : StringIPT ; 
			~ source : StringOPT ; 
		
		flows : 
			String from source to destination
	} 
	
	connector def IntCN { 
		participants : 
			~ destination : IntIPT ; 
			~ source : IntOPT ; 
		flows : 
			Int from source to destination
	} 
	
	connector def OrderCN { 
		participants : 
			~ destination : OrderIPT ; 
			~ source : OrderOPT ; 
		flows : 
			OrderDT from source to destination
	} 
	
	connector def OrderProcessingCN { 
		participants : 
			~ destination : OrderProcessingIPT ; 
			~ source : OrderProcessingOPT ; 
		flows : 
			OrderProcessingDT from source to destination
	} 
	
	connector def OrderItemArrayCN { 
		participants : 
			~ destination : OrderItemArrayIPT ; 
			~ source : OrderItemArrayOPT ; 
		flows : 
			OrderItemArrayDT from source to destination
	} 
	
	connector def RealCN { 
		participants : 
			~ source : RealOPT ; 
			~ destination : RealIPT ; 
		flows : 
			Real from source to destination
	} 
	
	connector def OrderChargeCN { 
		participants : 
			~ destination : OrderChargeIPT ; 
			~ source : OrderChargeOPT ; 
		flows : 
			OrderChargeDT from source to destination
	} 
		
	connector def PaymentStatusCN { 
		participants : 
			~ destination : PaymentStatusIPT ; 
			~ source : PaymentStatusOPT ; 
		flows : 
			PaymentStatusEnum from source to destination
	} 
	
	connector def DispenserProductCN { 
		participants : 
			~ destination : DispenserProductIPT ; 
			~ source : DispenserProductOPT ; 
		flows : 
			DispenserProductDT from source to destination
	} 
	
	connector def CompartmentCMDCN { 
		participants : 
			~ destination : CompartmentCMDIPT ; 
			~ source : CompartmentCMDOPT ; 
		flows : 
			CompartmentCMDEnum from source to destination
	}
	
	connector def PickupOrderAddedCN { 
		participants : 
			~ destination : PickupOrderAddedIPT ; 
			~ source : PickupOrderAddedOPT ; 
		flows : 
			PickupOrderAddedDT from source to destination
	}
}

package FoodFastComponents { 
	import FoodFastConnectors ; 
	import FoodFastPorts ; 
	import SysADLTypes ;
	
	component def FoodFastARCH { 
		configuration { 
			components : 
				DatabaseCP : DatabaseCP { 
					using ports : 
						dbServiceP : DBServiceP ;
				} 
				
				UserServerCP : UserServerCP { 
					using ports : 
						dbClient_User : DBClientP ; 
						httpServer_User : HTTPServiceP ;
				} 
				
				FrontendCP : FrontendCP { 
					using ports : 
						httpClient_Frontend : HTTPClientP ;
				} 
				
				BiometricServerCP : BiometricServerCP { 
					using ports : 
						httpServer_Biometric : HTTPServiceP ; 
						dbClient_Biometric : DBClientP ;
				} 
				
				RegisterBiometricTotenCP : RegisterBiometricTotemCP { 
					using ports : 
						httpClient_BiometricToten : HTTPClientP ;
				} 
				
				AdminFrontendCP : AdminFrontendCP { 
					using ports : 
						httpClient_AdminFrontend : HTTPClientP ;
				} 
				
				ProductServerCP : ProductServerCP { 
					using ports : 
						httpServer_Product_private : HTTPServiceP ; 
						httpServer_Product_public : HTTPServiceP ; 
						dbClient_Product : DBClientP ;
				} 
			
				DispenserSnackMachineCP : DispenserSnackMachineCP { 
					using ports : 
						httpClient_DispenserSnackToOrderServer : HTTPClientP ; 
						httpClient_DispenserSnackToBiometricServer : HTTPClientP ;
				} 
				
				DispenserDrinkMachineCP : DispenserDrinkMachineCP { 
					using ports : 
						httpClient_DispenserDrinkToOrderServer : HTTPClientP ; 
						httpClient_DispenserDrinkToBiometricServer : HTTPClientP ;
				} 
				
				OrderServerCP : OrderServerCP { 
					using ports : 
						httpServer_Order_private : HTTPServiceP ; 
						httpServer_Order_public : HTTPServiceP ; 
						dbClient_Order : DBClientP ; 
						httpClient_CheckItemServer : HTTPClientP ;
				} 
				
				TapMachineCP : TapMachineCP { 
					using ports : 
						httpClient_TapToBiometricServer : HTTPClientP ; 
						httpClient_TapToOrderServer : HTTPClientP ; 
						httpClient_TapToProductServer : HTTPClientP ;
				} 
				
				TotemCP : TotemCP { 
					using ports : 
						httpClient_TotemToProductServer : HTTPClientP ; 
						httpClient_TotemToOrderServer : HTTPClientP ; 
						httpClient_TotemToBiometricServer : HTTPClientP ;
				} 
				
			PickupStationCP : PickupStationCP { 
				using ports : 
					httpClient_PickupToOrderServer : HTTPClientP ; 
					httpClient_PickupToBiometricServer : HTTPClientP ;
			} 
			
			connectors : 
				DB_UserServer : DatabaseCN bindings dbClient_User = dbServiceP ; 
				DB_BiometricServer : DatabaseCN bindings dbClient_Biometric = dbServiceP ; 
				Front_UserServer : HTTPCN bindings httpClient_Frontend = httpServer_User ; 
				Toten_BiometricServer : HTTPCN bindings httpClient_BiometricToten = httpServer_Biometric ; 
				DB_ProductServer : DatabaseCN bindings dbClient_Product = dbServiceP ; 
				FrontAdmin_ProductServer : HTTPCN bindings httpClient_AdminFrontend = httpServer_Product_private ; 
				DispenserSnack_BiometricServer : HTTPCN bindings httpClient_DispenserSnackToBiometricServer = httpServer_Biometric ; 
				DispenserDrink_BiometricServer : HTTPCN bindings httpClient_DispenserDrinkToBiometricServer = httpServer_Biometric ; 
				checkItems : HTTPCN bindings httpClient_CheckItemServer = httpServer_Product_private ; 
				Front_OrderServer : HTTPCN bindings httpClient_Frontend = httpServer_Order_public ; 
				DB_OrderServer : DatabaseCN bindings dbClient_Order = dbServiceP ; 
				DispenserSnack_OrderServer : HTTPCN bindings httpClient_DispenserSnackToOrderServer = httpServer_Order_private ; 
				DispenserDrink_OrderServer : HTTPCN bindings httpClient_DispenserDrinkToOrderServer = httpServer_Order_private ; 
				Tap_BiometricServer : HTTPCN bindings httpClient_TapToBiometricServer = httpServer_Biometric ; 
				Tap_OrderServer : HTTPCN bindings httpClient_TapToOrderServer = httpServer_Order_private ; 
				Tap_ProductServer : HTTPCN bindings httpClient_TapToProductServer = httpServer_Product_private ; 
				Totem_BiometricServer : HTTPCN bindings httpClient_TotemToBiometricServer = httpServer_Biometric ; 
				Totem_OrderServer : HTTPCN bindings httpClient_TotemToOrderServer = httpServer_Order_private ; 
				Totem_ProductServer : HTTPCN bindings httpClient_TotemToProductServer = httpServer_Product_private ; 
				PickupBiometricServer : HTTPCN bindings httpClient_PickupToBiometricServer = httpServer_Biometric ; 
				Pickup_OrderServer : HTTPCN bindings httpClient_PickupToOrderServer = httpServer_Order_private ; 
		Totem_UserServer : HTTPCN bindings httpClient_BiometricToten = httpServer_User ; }
	} 
	
	boundary component def DatabaseCP { 
		ports : 
			dbServiceP : DBServiceP [ 1 , 2 ] ;
	}
	
	component def UserServerCP { 
		ports : 
			dbClient_User : DBClientP ; 
			httpServer_User : HTTPServiceP ; 
			
			configuration { 
				components : 
					UserAuthCP : UserAuthCP { 
						using ports : 
							httpServer_UserAuth : HTTPServiceP ; 
							dbClient_UserAuth : DBClientP ;
					} 
					
					UserCreateCP : CreatePersonalInfoCP { 
						using ports : 
							httpServer_UserCreate : HTTPServiceP ; 
							dbClient_UserCreate : DBClientP ;
					} 
					
					UserDeleteCP : UserDeleteCP { 
						using ports : 
							httpServer_UserDelete : HTTPServiceP ; 
							dbClient_UserDelete : DBClientP ;
					} 
					
					UserUpdateCP : UpdatePersonalInfoCP { 
						using ports : httpServer_UserUpdate : HTTPServiceP ; 
						dbClient_UserUpdate : DBClientP ;
					} 
					
					UserRetrieveCP : UserRetrieveCP { 
						using ports : 
							httpServer_UserRetrieve : HTTPServiceP ; 
							dbClient_UserRetrieve : DBClientP ;
					} 
					
					CreatePaymentMethodsCP : CreatePaymentMethodsCP { 
						using ports : 
							httpServer_UserCreatePayment : HTTPServiceP ; 
							dbClient_UserCreatePayment : DBClientP ;
					} 
					
					UpdatePaymentMethodsCP : UpdatePaymentMethodsCP { 
						using ports : 
							dbClient_UserUpdatePayment : DBClientP ; 
							httpServer_UserUpdatePayment : HTTPServiceP ;
					} 
					
				delegations : 
					httpServer_UserAuth to httpServer_User
					httpServer_UserCreate to httpServer_User 
					httpServer_UserDelete to httpServer_User 
					httpServer_UserUpdate to httpServer_User 
					dbClient_UserUpdate to dbClient_User 
					dbClient_UserDelete to dbClient_User 
					dbClient_UserCreate to dbClient_User 
					dbClient_UserRetrieve to dbClient_User 
					httpServer_UserRetrieve to httpServer_User 
					dbClient_UserAuth to dbClient_User
					dbClient_UserCreatePayment to dbClient_User 
					dbClient_UserUpdatePayment to dbClient_User 
					httpServer_UserCreatePayment to httpServer_User 
					httpServer_UserUpdatePayment to httpServer_User 
			}
	}
	component def CreatePersonalInfoCP { 
		ports : 
			httpServer_UserCreate : HTTPServiceP ; 
			dbClient_UserCreate : DBClientP ;
	}
	component def UpdatePersonalInfoCP { 
		ports : 
			httpServer_UserUpdate : HTTPServiceP ; 
			dbClient_UserUpdate : DBClientP ;
	}
	component def UserRetrieveCP { 
		ports : 
			httpServer_UserRetrieve : HTTPServiceP ; 
			dbClient_UserRetrieve : DBClientP ;
	}
	component def UserDeleteCP { 
		ports : 
			httpServer_UserDelete : HTTPServiceP ; 
			dbClient_UserDelete : DBClientP ; 
			
			port def DBResponseIPT { 
				flow in DBResponseDT
			}
	}
	component def UserAuthCP { 
		ports : 
			httpServer_UserAuth : HTTPServiceP ; 
			dbClient_UserAuth : DBClientP ;
	} 
	
	boundary component def FrontendCP { 
		ports : 
			httpClient_Frontend : HTTPClientP [ 1 , 2 ] ;
	} 
	
	boundary component def FingerprintSensorCP { 
		ports : 
			active_Fingerprint : BooleanIPT ; 
			biometricRaw_Fingerprint : BiometricRawOPT ;
	} 
	
	boundary component def FaceCameraCP { 
		ports : 
			active_Camera : BooleanIPT ; 
			biometricRaw_Camera : BiometricRawOPT ;
	} 
	
	boundary component def RegisterBiometricCP { 
		ports : 
			dbClient_RegisterBiometric : DBClientP ; 
			httpService_RegisterBiometric : HTTPServiceP ;
	}
	boundary component def RemoveBiometricCP { 
		ports : 
			httpService_RemoveBiometric : HTTPServiceP ; 
			dbClient_RemoveBiometric : DBClientP ;
	} 
	boundary component def BiometricRecognitionCP { 
		ports : 
			dbClient_BiometricRecognition : DBClientP ; 
			httpService_BiometricRecognition : HTTPServiceP ;
	}
	
	component def BiometricServerCP { 
		ports : 
			httpServer_Biometric : HTTPServiceP [ 1 , 2 ] ; 
			dbClient_Biometric : DBClientP ; 
		configuration { 
			components : 
				BiometricRecognitionCP : BiometricRecognitionCP { 
					using ports : 
						dbClient_BiometricRecognition : DBClientP ; 
						httpService_BiometricRecognition : HTTPServiceP ;
				} 
				
				RegisterBiometricCP : RegisterBiometricCP { 
					using ports : 
						dbClient_RegisterBiometric : DBClientP ; 
						httpService_RegisterBiometric : HTTPServiceP ;
				} 
				
				RemoveBiometricCP : RemoveBiometricCP { 
					using ports : 
						httpService_RemoveBiometric : HTTPServiceP ; 
						dbClient_RemoveBiometric : DBClientP ;
				} 
				
				delegations : 
					httpService_BiometricRecognition to httpServer_Biometric
					httpService_RegisterBiometric to httpServer_Biometric
					httpService_RemoveBiometric to httpServer_Biometric
					dbClient_BiometricRecognition to dbClient_Biometric
					dbClient_RegisterBiometric to dbClient_Biometric
					dbClient_RemoveBiometric to dbClient_Biometric
		}
		
	}
	
	component def BiometricSensorsCP { 
		ports : 
			sensors_Component : SensorIPT ; 
		 
		configuration { 
			components : 
				BiometricControllerCP : BiometricControllerCP { 
					using ports : 
						biometricRawIPT_Fingerprint : BiometricRawIPT ; 
						biometricRawIPT_Camera : BiometricRawIPT ; 
						sensorActive_Fingerprint : BooleanOPT ; 
						sensorActive_Camera : BooleanOPT ; 
						sensors_Controller : SensorIPT ;
				} 
				
				FaceCameraCP : FaceCameraCP { 
					using ports : 
						active_Camera : BooleanIPT ; 
						biometricRaw_Camera : BiometricRawOPT ;
				} 
				
				FingerprintSensorCP : FingerprintSensorCP { 
					using ports : 
						active_Fingerprint : BooleanIPT ; 
						biometricRaw_Fingerprint : BiometricRawOPT ;
				} 
				
			connectors : 
				biometricRaw_Camera : BiometricRawCN bindings biometricRaw_Camera = biometricRawIPT_Fingerprint ; 
				activeCamera : BooleanCN bindings sensorActive_Fingerprint = active_Camera ; 
				biometricRaw_FingerPrint : BiometricRawCN bindings biometricRaw_Fingerprint = biometricRawIPT_Camera ; 
				activeFingerprint : BooleanCN bindings active_Fingerprint = sensorActive_Camera ; 
			delegations : 
				sensors_Controller to sensors_Component 
		}
	}
	
	component def BiometricControllerCP { 
		ports : 
			biometricRawIPT_Fingerprint : BiometricRawIPT ; 
			biometricRawIPT_Camera : BiometricRawIPT ; 
			sensorActive_Fingerprint : BooleanOPT ; 
			sensorActive_Camera : BooleanOPT ;
			sensors_Controller : SensorIPT ; 
	}
	
	component def RegisterBiometricTotemCP { 
		ports : 
			httpClient_BiometricTotem : HTTPClientP [ 1 , 2 ] ; 
		configuration { 
			components : 
				 
				
				KeywordCP : KeyboardCP { 
					using ports : keywordOutput : StringOPT ;
				} 
				
				BiometricSensorsCP : BiometricSensorsCP { 
					using ports : sensors_Component : SensorIPT ;
				} 
			
			BiometricTotemProcessorCP : BiometricTotemProcessorCP { using ports : httpClient_BiometricTotemProcessor_external : HTTPClientP ; httpClient_BiometricTotemProcessor_internal : HTTPClientP ; cpfString_BiometricTotem : StringIPT ; enableSelecion_Totem : BooleanOPT ; selectedBiometricType : BiometricTypeIPT ; } SelectBiometricTypeCP : SelectBiometricTypeCP { using ports : biometricType : BiometricTypeOPT ; enableSelection_BiometricType : BooleanIPT ; } connectors : sensorData : SensorCN bindings httpClient_BiometricTotemProcessor_internal = sensors_Component ; cpfConnector : StringCN bindings keywordOutput = cpfString_BiometricTotem ; biometricType : BiometricTypeCN bindings biometricType = selectedBiometricType ; enableSelection : BooleanCN bindings enableSelecion_Totem = enableSelection_BiometricType ; delegations : httpClient_BiometricTotemProcessor_external to httpClient_BiometricTotem }
	}
	
	component def ProductServerCP { 
		ports : 
			httpServer_Product_private : HTTPServiceP ; 
			httpServer_Product_public : HTTPServiceP [ 1 , 2 ] ; 
			dbClient_Product : DBClientP ; 
		configuration { 
			components : 
				CreateProductCP : CreateProductCP { 
					using ports : 
						httpServer_CreateProduct : HTTPServiceP ; 
						dbClient_CreateProduct : DBClientP ;
				} 
				
				UpdateProductCP : UpdateProductCP { 
					using ports : 
						httpServer_UpdateProduct : HTTPServiceP ; 
						dbClient_UpdateProduct : DBClientP ;
				} 
				
				DeleteProductCP : DeleteProductCP { 
					using ports : 
						httpServer_DeleteProduct : HTTPServiceP ; 
						dbClient_DeleteProduct : DBClientP ;
				} 
				
				RetrieveProductCP : RetrieveProductCP { 
					using ports : 
						httpServer_RetrieveProduct : HTTPServiceP ; 
						dbClient_RetrieveProduct : DBClientP ;
				} 
				
				GetMachineStockCP : GetMachineStockCP { 
					using ports : 
						httpServer_CheckAvailabilityProduct : HTTPServiceP ; 
						dbClient_CheckAvailabilityProduct : DBClientP ;
				} 
			
			delegations : 
				httpServer_CreateProduct to httpServer_Product_private
				dbClient_CreateProduct to dbClient_Product
				httpServer_UpdateProduct to httpServer_Product_private
				dbClient_UpdateProduct to dbClient_Product
				httpServer_DeleteProduct to httpServer_Product_private
				dbClient_DeleteProduct to dbClient_Product
				httpServer_RetrieveProduct to httpServer_Product_private
				httpServer_RetrieveProduct to httpServer_Product_public
				dbClient_RetrieveProduct to dbClient_Product
				dbClient_CheckAvailabilityProduct to dbClient_Product
				httpServer_CheckAvailabilityProduct to httpServer_Product_private
				httpServer_CheckAvailabilityProduct to httpServer_Product_public
		}
	} 
	
	boundary component def AdminFrontendCP { 
		ports : httpClient_AdminFrontend : HTTPClientP ;
	}
	component def CreateProductCP { 
		ports : 
			httpServer_CreateProduct : HTTPServiceP ; 
			dbClient_CreateProduct : DBClientP ; 
	}
	component def UpdateProductCP { 
		ports : 
			httpServer_UpdateProduct : HTTPServiceP ; 
			dbClient_UpdateProduct : DBClientP ; 
	}
	component def DeleteProductCP { 
		ports : 
			httpServer_DeleteProduct : HTTPServiceP ; 
			dbClient_DeleteProduct : DBClientP ;
	} 
	
	boundary component def RetrieveProductCP { 
		ports : 
			httpServer_RetrieveProduct : HTTPServiceP ; 
			dbClient_RetrieveProduct : DBClientP ;
	}
	component def GetMachineStockCP { 
		ports : 
			httpServer_CheckAvailabilityProduct : HTTPServiceP ; 
			dbClient_CheckAvailabilityProduct : DBClientP ;
	}
	
	component def BiometricTotemProcessorCP { 
		ports : 
			httpClient_BiometricTotemProcessor_external : HTTPClientP ; 
			httpClient_BiometricTotemProcessor_internal : HTTPClientP ; cpfString_BiometricTotem : StringIPT ;
	enableSelecion_Totem : BooleanOPT ; selectedBiometricType : BiometricTypeIPT ; } 
	
	boundary component def KeyboardCP { 
		ports : keywordOutput : StringOPT ;
	}
	
	component def OrderServerCP { 
		ports : 
			httpServer_Order_private : HTTPServiceP ; 
			httpServer_Order_public : HTTPServiceP ; 
			dbClient_Order : DBClientP ; httpClient_CheckItemServer : HTTPClientP ; 
		
		configuration { 
			components : 
				UpdateOrderCP : UpdateOrderCP { 
					using ports : 
						httpServer_UpdateOrder : HTTPServiceP ; 
						dbClient_UpdateOrder : DBClientP ;
				} 
				
				RetrieveOrderCP : RetrieveOrderCP { 
					using ports : 
						httpServer_RetrieveOrder : HTTPServiceP ; 
						dbClient_RetrieveOrder : DBClientP ;
				} 
			
				CheckDebtsCP : CheckDebtsCP { 
					using ports : 
					dbClient_CheckDebts : DBClientP ; 
					httpServer_CheckDebts : HTTPServiceP ;
				} 
				
				ProcessingOrderCP : ProcessingOrderCP { 
					using ports : 
						dbClient_ProcessingOrder : DBClientP ;
						httpServer_ProcessingOrder : HTTPServiceP ; 
						httpClient_CheckDebtsProcessing : HTTPClientP ; 
						httpClient_CheckItemsProcessing : HTTPClientP ;
				} 
				
				CreateOrderCP : CreateOrderCP { 
					using ports : 
						httpClient_CreateOrder : DBClientP ; 
						httpServer_CreateOrder : HTTPServiceP ; 
						dbClient_CreateOrder : DBClientP ;
				} 
			
			connectors : 
				hasDebitsCN : HTTPCN bindings httpClient_CheckDebtsProcessing = httpServer_CheckDebts ; 
				processingOrder : HTTPCN bindings httpClient_CreateOrder = httpServer_ProcessingOrder ; 
			
			delegations : 
				dbClient_UpdateOrder to dbClient_Order
				dbClient_RetrieveOrder to dbClient_Order 
				httpServer_RetrieveOrder to httpServer_Order_public 
				httpServer_UpdateOrder to httpServer_Order_private
				httpServer_CheckDebts to httpServer_Order_private 
				dbClient_CheckDebts to dbClient_Order 
				dbClient_ProcessingOrder to dbClient_Order 
				httpServer_ProcessingOrder to httpServer_Order_private 
				httpClient_CheckItemsProcessing to httpClient_CheckItemServer 
				dbClient_CreateOrder to dbClient_Order 
				httpServer_CreateOrder to httpServer_Order_private }
	}
	component def RetrieveOrderCP { 
		ports : 
			httpServer_RetrieveOrder : HTTPServiceP ; 
			dbClient_RetrieveOrder : DBClientP ;
	}
	component def UpdateOrderCP { 
		ports : 
			httpServer_UpdateOrder : HTTPServiceP ; 
			dbClient_UpdateOrder : DBClientP ;
	}
	component def CheckDebtsCP { 
		ports :  
			dbClient_CheckDebts : DBClientP ;  
			httpServer_CheckDebts : HTTPServiceP [ 1 , 2 ] ;
	}
	
	component def ProcessingOrderCP { 
		ports : 
			dbClient_ProcessingOrder : DBClientP ; 
			httpServer_ProcessingOrder : HTTPServiceP [ 1 , 2 ] ; 
			httpClient_CheckDebtsProcessing : HTTPClientP ; 
			httpClient_CheckItemsProcessing : HTTPClientP ; 
		configuration { 
			components :
				AdditionalProcessingCP : AdditionalProcessingCP { 
					using ports : 
						order_AdditionalProcessing : OrderIPT ; 
						orderProcessing_AdditionalProcessing : OrderProcessingOPT ;
				} 
				
				PaymentProcessingCP : PaymentProcessingCP { 
					using ports : 
						orderCharge_PaymentProcessing : OrderChargeIPT ; 
						paymentResult_PaymentProcessing : PaymentStatusOPT ; 
						dbClient_PaymentProcessig : DBClientP ;
				} 
				
				CheckItemsAvailabilityCP : CheckItemsAvailabilityCP { 
					using ports : 
						httpClient_CheckItemsAvailability : HTTPClientP ; 
						order_CheckItemsAvailability : OrderIPT ; 
						availibility : BooleanOPT ;
				} 
				
				OrderProcessingCoordinatorCP : OrderProcessingCoordinatorCP { 
					using ports : 
						httpServer_ProcessingOrderCoordinator : HTTPServiceP ; 
						dbClient_ProcessingOrderCoordinator : DBClientP ; 
						order_OrderProcessingCoordinator : OrderOPT ; 
						orderProcessing_OrderProcessingCoordinator : OrderProcessingIPT ; 
						orderCharge_OrderProcessingCoordinator : OrderChargeOPT ; 
						paymentResult_OrderProcessingCoordinator : PaymentStatusIPT ; 
						httpClient_CheckDebtsPCoordinator : HTTPClientP ; 
						availibility_Coordinator : BooleanIPT ; 
						order_CIACoordinator : OrderOPT ;
				} 
			
			connectors : 
				allProductsAvailable : BooleanCN bindings availibility = availibility_Coordinator ; 
				orderToAvaluation : OrderCN bindings order_CIACoordinator = order_CheckItemsAvailability ; 
				orderToAdditionalProcessing : OrderCN bindings order_OrderProcessingCoordinator = order_AdditionalProcessing ; 
				additionalProcessingResult : OrderProcessingCN bindings orderProcessing_AdditionalProcessing = orderProcessing_OrderProcessingCoordinator ; 
				paymentRequest : OrderChargeCN bindings orderCharge_OrderProcessingCoordinator = orderCharge_PaymentProcessing ; 
				paymentStatusResult : PaymentStatusCN bindings paymentResult_PaymentProcessing = paymentResult_OrderProcessingCoordinator ; 
			
			delegations : 
				dbClient_ProcessingOrderCoordinator to dbClient_ProcessingOrder 
				httpServer_ProcessingOrderCoordinator to httpServer_ProcessingOrder 
				httpClient_CheckDebtsPCoordinator to httpClient_CheckDebtsProcessing 
				httpClient_CheckItemsAvailability to httpClient_CheckItemsProcessing 
				dbClient_PaymentProcessig to dbClient_ProcessingOrder 
		}
	}
	component def KitchenRoutingCP { 
		ports : 
			orderItems_Routing : OrderItemArrayIPT ; 
			kitchenId_Routing : IntOPT ;
	}
	
	component def OrderProcessingCoordinatorCP { 
		ports :
			httpServer_ProcessingOrderCoordinator : HTTPServiceP ; 
			dbClient_ProcessingOrderCoordinator : DBClientP ; 
			order_OrderProcessingCoordinator : OrderOPT ;
			orderProcessing_OrderProcessingCoordinator : OrderProcessingIPT ; 
			orderCharge_OrderProcessingCoordinator : OrderChargeOPT ; 
			paymentResult_OrderProcessingCoordinator : PaymentStatusIPT ; 
			httpClient_CheckDebtsPCoordinator : HTTPClientP ; 
			availibility_Coordinator : BooleanIPT ; 
			order_CIACoordinator : OrderOPT ;
	}
	
	component def AdditionalProcessingCP { 
		ports : 
			order_AdditionalProcessing : OrderIPT ; 
			orderProcessing_AdditionalProcessing : OrderProcessingOPT ; 
		
		configuration { 
			components : 
				AdditionalProcessingCoordinatorCP : AdditionalProcessingCoordinatorCP { 
					using ports : 
						orderProcessing_APCoordinator : OrderProcessingOPT ; 
						orderItems_ToRouting : OrderItemArrayOPT ; 
						orderItems_ToPricing : OrderItemArrayOPT ;
						kitchenId_ByRouting : IntIPT ; 
						orderPrice_ByPricing : RealIPT ; 
						order_APCoordinator : OrderIPT ;
				} 
				
				KitchenRoutingCP : KitchenRoutingCP { 
					using ports : 
						orderItems_Routing : OrderItemArrayIPT ; 
						kitchenId_Routing : IntOPT ;
				} 
				
				PriceCalculationCP : PriceCalculationCP { 
					using ports : 
						orderItems_Pricing : OrderItemArrayIPT ; 
						orderPrice_Pricing : RealOPT ;
				} 
			
			connectors : 
				kitchenId : IntCN bindings kitchenId_Routing = kitchenId_ByRouting ; 
				ordersToRouting : OrderItemArrayCN bindings orderItems_ToRouting = orderItems_Routing ; 
				orderPrice : RealCN bindings orderPrice_Pricing = orderPrice_ByPricing ; 
				ordersToPricing : OrderItemArrayCN bindings orderItems_ToPricing = orderItems_Pricing ; 
			
			delegations : 
				order_APCoordinator to order_AdditionalProcessing 
				orderProcessing_APCoordinator to orderProcessing_AdditionalProcessing
		}
	}
	component def PaymentProcessingCP { 
		ports : 
			orderCharge_PaymentProcessing : OrderChargeIPT ; 
			paymentResult_PaymentProcessing : PaymentStatusOPT ; 
			dbClient_PaymentProcessig : DBClientP ;
	}
	component def PriceCalculationCP { 
		ports : 
			orderItems_Pricing : OrderItemArrayIPT ; 
			orderPrice_Pricing : RealOPT ;
	}
	
	component def AdditionalProcessingCoordinatorCP { 
		ports : 
			orderProcessing_APCoordinator : OrderProcessingOPT ; 
			orderItems_ToRouting : OrderItemArrayOPT ; 
			orderItems_ToPricing : OrderItemArrayOPT ; 
			kitchenId_ByRouting : IntIPT ; orderPrice_ByPricing : RealIPT ; 
			order_APCoordinator : OrderIPT ;
	}
	component def CheckItemsAvailabilityCP { 
		ports : 
			httpClient_CheckItemsAvailability : HTTPClientP ; 
			order_CheckItemsAvailability : OrderIPT ; 
			availibility : BooleanOPT ;
	}
	component def CreateOrderCP { 
		ports : 
			httpClient_CreateOrder : DBClientP ; 
			httpServer_CreateOrder : HTTPServiceP ; 
			dbClient_CreateOrder : DBClientP ;
	}
	
	component def DispenserSnackMachineCP { 
		ports : 
			httpClient_DispenserSnackToOrderServer : HTTPClientP ; 
			httpClient_DispenserSnackToBiometricServer : HTTPClientP ; 
		
		configuration { 
			components : 
				HardwareDispenserCP : HardwareDispenserCP { 
					using ports : 
						dispenserCommand : DispenserProductIPT ;
				} 
				
				ProductSelectionCP : ProductSelectionCP { 
					using ports : 
						selectionOn : BooleanIPT ; 
						snackId : IntOPT ;
				} 
				
				BiometricSensorsCP : BiometricSensorsCP { 
					using ports : 
						sensors_Component : SensorIPT ;
				} 
				
				DispenserMachineFlowCP : DispenserMachineFlowCP { 
					using ports : 
						selectionIsOn : BooleanOPT ; 
						selectedSnackId : IntIPT ; 
						dispenserCommandOut : DispenserProductOPT ; 
						httpClient_DMSnackSensors : HTTPClientP ; 
						httpClient_DMSnackBiometricServer : HTTPClientP ; 
						httpClient_DMSnackOrderServer : HTTPClientP ;
				} 
			
			connectors : 
				biometricData : SensorCN bindings httpClient_DMSnackSensors = sensors_Component ; 
				dispenserSnackCMD : DispenserProductCN bindings dispenserCommandOut = dispenserCommand ; 
				selectedSnackId : IntCN bindings snackId = selectedSnackId ; 
				authorizedSelection : BooleanCN bindings selectionIsOn = selectionOn ; 
			
			delegations : 
				httpClient_DMSnackBiometricServer to httpClient_DispenserSnackToBiometricServer
				 httpClient_DMSnackOrderServer to httpClient_DispenserSnackToOrderServer
		}
	} 
	
	boundary component def ProductSelectionCP { 
		ports : 
			selectionOn : BooleanIPT ; 
			snackId : IntOPT ;
	}
	
	component def DispenserMachineFlowCP { 
		ports : 
			selectionIsOn : BooleanOPT ; 
			selectedSnackId : IntIPT ; 
			dispenserCommandOut : DispenserProductOPT ; 
			httpClient_DMSnackSensors : HTTPClientP ; 
			httpClient_DMSnackBiometricServer : HTTPClientP ; 
			httpClient_DMSnackOrderServer : HTTPClientP ;
	} 
	
	boundary component def HardwareDispenserCP { 
		ports : 
			dispenserCommand : DispenserProductIPT ;
	}
	
	component def DispenserDrinkMachineCP { 
		ports : 
			httpClient_DispenserDrinkToOrderServer : HTTPClientP ; 
			httpClient_DispenserDrinkToBiometricServer : HTTPClientP ; 
		
		configuration { 
			components : 
				HardwareDispenserCP : HardwareDispenserCP { 
					using ports : 
						dispenserCommand : DispenserProductIPT ;
				} 
				
				ProductSelectionCP : ProductSelectionCP { 
					using ports : 
						selectionOn : BooleanIPT ; snackId : IntOPT ;
				} 
				
				BiometricSensorsCP : BiometricSensorsCP { 
					using ports : 
						sensors_Component : SensorIPT ;
				} 
				
				DispenserMachineFlowCP : DispenserMachineFlowCP { 
					using ports : 
						selectionIsOn : BooleanOPT ; 
						selectedSnackId : IntIPT ; 
						dispenserCommandOut : DispenserProductOPT ; 
						httpClient_DMSnackSensors : HTTPClientP ; 
						httpClient_DMSnackBiometricServer : HTTPClientP ; 
						httpClient_DMSnackOrderServer : HTTPClientP ;
				} 
			
			connectors : 
				biometricData : SensorCN bindings httpClient_DMSnackSensors = sensors_Component ; 
				dispenserSnackCMD : DispenserProductCN bindings dispenserCommandOut = dispenserCommand ; 
				selectedSnackId : IntCN bindings snackId = selectedSnackId ; 
				authorizedSelection : BooleanCN bindings selectionIsOn = selectionOn ; 
			
			delegations : 
				httpClient_DMSnackBiometricServer to httpClient_DispenserDrinkToBiometricServer 
				httpClient_DMSnackOrderServer to httpClient_DispenserDrinkToOrderServer
		}
	} 
	
	component def TapMachineCP { 
		ports : 
			httpClient_TapToBiometricServer : HTTPClientP ; 
			httpClient_TapToOrderServer : HTTPClientP ; 
			httpClient_TapToProductServer : HTTPClientP ; 
		
		configuration { 
			components : 
				BiometricSensorsCP : BiometricSensorsCP { 
					using ports : 
						sensors_Component : SensorIPT ;
				} 
				
				TapFlowControllerCP : TapFlowControllerCP { 
					using ports : 
						httpClient_TapControllerToProductServer : HTTPClientP ; 
						httpClient_TapControllerToOrderServer : HTTPClientP ; 
						httpClient_TapControllerToBiometricServer : HTTPClientP ; 
						tapReleasedCMD : BooleanOPT ; 
						amountOfDrink : IntIPT ; 
						httpClient_TapSensors : HTTPClientP ;
				} 
				
				TapActuatorCP : TapActuatorCP { 
					using ports : 
						tapReleased : BooleanIPT ; 
						amountDispensedTap : IntOPT ;
				} 
			
			connectors : 
				biometricData : SensorCN bindings httpClient_TapSensors = sensors_Component ; 
				tapReleased : BooleanCN bindings tapReleasedCMD = tapReleased ; 
				drinkAmount : IntCN bindings amountDispensedTap = amountOfDrink ; 
			
			delegations : 
				httpClient_TapControllerToBiometricServer to httpClient_TapToBiometricServer
				 httpClient_TapControllerToProductServer to httpClient_TapToProductServer
				  httpClient_TapControllerToOrderServer to httpClient_TapToOrderServer
		}
	} 
	
	boundary component def TapActuatorCP { 
		ports : 
			tapReleased : BooleanIPT ; 
			amountDispensedTap : IntOPT ;
	}
	
	component def TapFlowControllerCP { 
		ports : 
			httpClient_TapControllerToProductServer : HTTPClientP ; 
			httpClient_TapControllerToOrderServer : HTTPClientP ; 
			httpClient_TapControllerToBiometricServer : HTTPClientP ; 
			tapReleasedCMD : BooleanOPT ; 
			amountOfDrink : IntIPT ; 
			httpClient_TapSensors : HTTPClientP ;
	}
	
	component def TotemCP { 
		ports : 
			httpClient_TotemToProductServer : HTTPClientP ; 
			httpClient_TotemToOrderServer : HTTPClientP ; 
			httpClient_TotemToBiometricServer : HTTPClientP ; 
		
		configuration { 
			components : 
				TotemFlowControllerCP : TotemFlowControllerCP { 
					using ports : 
						httpClient_TotemControllerToOrderServer : HTTPClientP ; 
						httpClient_TotemControllerToProductServer : HTTPClientP ; 
						httpClient_TotemControllerToBiometricServer : HTTPClientP ; 
						httpClient_TotemSensors : HTTPClientP ; 
						selectedProducts : OrderItemArrayIPT ; 
						enableDisplay : BooleanOPT ; 
						orderToPrint : OrderOPT ;
				} 
				
				BiometricSensorsCP : BiometricSensorsCP { 
					using ports : 
						sensors_Component : SensorIPT ;
				} 
				
				ReceiptPrinterCP : ReceiptPrinterCP { 
					using ports : 
						printerData : OrderIPT ;
				} 
				
				MenuDisplayCP : MenuDisplayCP { 
					using ports : 
						enabled : BooleanIPT ; 
						orderProducts : OrderItemArrayOPT ;
				} 
			
			connectors : 
				sensorData : SensorCN bindings httpClient_TotemSensors = sensors_Component ; 
				printerData : OrderCN bindings orderToPrint = printerData ; 
				enabled : BooleanCN bindings enableDisplay = enabled ; 
				orderProducts : OrderItemArrayCN bindings orderProducts = selectedProducts ; 
			
			delegations : 
				httpClient_TotemControllerToProductServer to httpClient_TotemToProductServer 
				httpClient_TotemControllerToOrderServer to httpClient_TotemToOrderServer 
				httpClient_TotemControllerToBiometricServer to httpClient_TotemToBiometricServer
		}
	}
	
	component def TotemFlowControllerCP { 
		ports : 
			httpClient_TotemControllerToOrderServer : HTTPClientP ; 
			httpClient_TotemControllerToProductServer : HTTPClientP ; 
			httpClient_TotemControllerToBiometricServer : HTTPClientP ; 
			httpClient_TotemSensors : HTTPClientP ; 
			selectedProducts : OrderItemArrayIPT ; 
			enableDisplay : BooleanOPT ; 
			orderToPrint : OrderOPT ;
	} 
	
	boundary component def MenuDisplayCP { 
		ports : 
			enabled : BooleanIPT ; 
			orderProducts : OrderItemArrayOPT ;
	} 
	
	boundary component def ReceiptPrinterCP { 
		ports : 
			printerData : OrderIPT ;
	} 
	
	component def PickupStationCP { 
		ports : 
			httpClient_PickupToOrderServer : HTTPClientP ; 
			httpClient_PickupToBiometricServer : HTTPClientP ; 
			
		configuration { 
			components : 
				PickupDisplayCP : PickupDisplayCP { 
					using ports : 
						orderReadyList : OrderItemArrayIPT ;
				} 
				
				PickupFlowControllerCP : PickupFlowControllerCP { 
					using ports : 
						compartmentToMove : IntOPT ; 
						compartmentArrived : BooleanIPT ; 
						readyOrders : OrderItemArrayOPT ; 
						httpClient_PickupControllerToBiometricServer : HTTPClientP ; 
						biometricRawIPT_Barcode : BiometricRawIPT ; 
						sensorActive_Barcode : BooleanOPT ; 
						orderAvailableController : PickupOrderAddedIPT ; 
						compartmentCMDOpt : CompartmentCMDOPT ; 
						pickupDetectedController : BooleanIPT ; 
						httpClient_PickupSensors : HTTPClientP ; 
						httpClient_PickupControllerToOrderServer : HTTPClientP ;
						selectBiometric_Pickup : BooleanOPT ;
						selectedBiometricType_Pickup : BiometricTypeIPT ;
				} 
				
				BiometricSensorsCP : BiometricSensorsCP { 
					using ports : 
						sensors_Component : SensorIPT ;
				} 
				
				BarcodeReaderCP : BarcodeReaderCP { 
					using ports : 
						active_Barcode : BooleanIPT ; 
						biometricRaw_Barcode : BiometricRawOPT ;
				} 
				
				PickupConveyorCP : PickupConveyorCP {
					using ports : 
						compartmentID : IntIPT ; 
						arrivedAtCompartment : BooleanOPT ;
				} 
				
				CompartmentActuatorCP : CompartmentActuatorCP { 
					using ports : 
						compartmentCMD : CompartmentCMDIPT ; 
						orderAvailable : PickupOrderAddedOPT ; 
						pickupDetectedActuator : BooleanOPT ;
						orderId_CompartmentActuator : StringIPT ;
				} 
			
				KeywordCP : KeyboardCP { 
					using ports : keywordOutput : StringOPT ;
				} 
			SelectBiometricTypeCP : SelectBiometricTypeCP { using ports : biometricType : BiometricTypeOPT ; enableSelection_BiometricType : BooleanIPT ; } connectors : 
				sensorsData : SensorCN bindings httpClient_PickupSensors = sensors_Component ; 
				readyOrdersCN : OrderItemArrayCN bindings readyOrders = orderReadyList ; 
				barcodeData : BiometricRawCN bindings biometricRaw_Barcode = biometricRawIPT_Barcode ; 
				activeBarcode : BooleanCN bindings sensorActive_Barcode = active_Barcode ; 
				compartmentCommand : CompartmentCMDCN bindings compartmentCMDOpt = compartmentCMD ; 
				orderAdded : PickupOrderAddedCN bindings orderAvailable = orderAvailableController ; 
				pickupDetected : BooleanCN bindings pickupDetectedActuator = pickupDetectedController ; 
				compartment : IntCN bindings compartmentToMove = compartmentID ; 
				moved : BooleanCN bindings arrivedAtCompartment = compartmentArrived ; 
				orderId_Input : StringCN bindings keywordOutput = orderId_CompartmentActuator ; 
			
			enableSelection : BooleanCN bindings selectBiometric_Pickup = enableSelection_BiometricType ; biometricSelected : BiometricTypeCN bindings biometricType = selectedBiometricType_Pickup ; delegations : httpClient_PickupControllerToOrderServer to httpClient_PickupToOrderServer
				httpClient_PickupControllerToBiometricServer to httpClient_PickupToBiometricServer
		}
	}
	
	component def PickupFlowControllerCP { 
		ports : 
			compartmentToMove : IntOPT ;
			compartmentArrived : BooleanIPT ; 
			readyOrders : OrderItemArrayOPT ; 
			httpClient_PickupControllerToBiometricServer : HTTPClientP ; 
			biometricRawIPT_Barcode : BiometricRawIPT ; 
			sensorActive_Barcode : BooleanOPT ; 
			orderAvailableController : PickupOrderAddedIPT ; 
			compartmentCMDOpt : CompartmentCMDOPT ; 
			pickupDetectedController : BooleanIPT ; 
			httpClient_PickupSensors : HTTPClientP ; 
			httpClient_PickupControllerToOrderServer : HTTPClientP ;
			selectBiometric_Pickup : BooleanOPT ; 
			selectedBiometricType_Pickup : BiometricTypeIPT ; 
	}
	
	boundary component def PickupConveyorCP { 
		ports : 
			compartmentID : IntIPT ; 
			arrivedAtCompartment : BooleanOPT ;
	}
	
	boundary component def SelectBiometricTypeCP { 
		ports : 
			biometricType : BiometricTypeOPT ; 
			enableSelection_BiometricType : BooleanIPT ;
	} 
	
	component def CompartmentActuatorCP {
		ports : 
			compartmentCMD : CompartmentCMDIPT ;
			orderAvailable : PickupOrderAddedOPT ; 
			pickupDetectedActuator : BooleanOPT ; orderId_CompartmentActuator : StringIPT ; 
		
		configuration { 
			components : 
				PickupSensorsCP : PickupSensorsCP { 
					using ports : 
						pickupDetected : BooleanOPT ;
				} 
			
			delegations : 
				pickupDetected to pickupDetectedActuator
		} 
	} 
	
	boundary component def PickupSensorsCP { 
		ports : 
			pickupDetected : BooleanOPT ;
	} 
	
	boundary component def BarcodeReaderCP { 
		ports : 
			active_Barcode : BooleanIPT ; 
			biometricRaw_Barcode : BiometricRawOPT ;
	}
	
	boundary component def PickupDisplayCP { 
		ports : 
			orderReadyList : OrderItemArrayIPT ;
	} 
	
	
	component def CreatePaymentMethodsCP { 
		ports : 
			httpServer_UserCreatePayment : HTTPServiceP ; 
			dbClient_UserCreatePayment : DBClientP ;
	}
	component def UpdatePaymentMethodsCP { 
		ports :
			dbClient_UserUpdatePayment : DBClientP ; 
			httpServer_UserUpdatePayment : HTTPServiceP ;
	} 
	
	activity def RetrieveProductAC ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) { 
		body { 
			actions : 
				BuildRetrieveProductQueryAN : BuildRetrieveProductQueryAN { 
					using pins : 
						req : HTTPRequestDT ;
				} 
				
				BuildRetrieveProductResponseAN : BuildRetrieveProductResponseAN { 
					using pins : 
						res : DBResponseDT ;
				} 
			
			delegate p2 to BuildRetrieveProductQueryAN 
			delegate p0 to req 
			delegate p3 to res
			delegate p1 to BuildRetrieveProductResponseAN
		}
	} 
	
	action def BuildRetrieveProductQueryAN ( req : HTTPRequestDT ) : DBQueryDT { 
		constraint : 
			post-condition BuildRetrieveProductQueryEQ 
		delegate req to req 
		delegate BuildRetrieveProductQueryAN to query
	} 
	
	action def BuildRetrieveProductResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT { 
		constraint : 
			post-condition BuildRetrieveProductResponseEQ 
		delegate dbRes to dbRes 
		delegate BuildRetrieveProductResponseAN to res
	} 
	
	constraint BuildRetrieveProductQueryEQ ( req : HTTPRequestDT ) : ( query : DBQueryDT ) { } 
	constraint BuildRetrieveProductResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def DeleteProductAC ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) { 
		body { 
			actions : 
				BuildDeleteProductQueryAN : BuildDeleteProductQueryAN { 
					using pins : 
						req : HTTPRequestDT ;
				} 
				
				BuildDeleteProductResponseAN : BuildDeleteProductResponseAN { 
					using pins : 
						res : DBResponseDT ;
				} 
			
			delegate p2 to BuildDeleteProductQueryAN 
			delegate p0 to req 
			delegate p3 to res
			delegate p1 to BuildDeleteProductResponseAN
		}
	} 
	
	action def BuildDeleteProductQueryAN ( req : HTTPRequestDT ) : DBQueryDT { 
		constraint : 
			post-condition BuildDeleteProductQueryEQ 
		delegate req to req 
		delegate BuildDeleteProductQueryAN to qry
	} 
	
	action def BuildDeleteProductResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT { 
		constraint : 
			post-condition BuildDeleteProductResponseEQ 
		delegate dbRes to dbRes 
		delegate BuildDeleteProductResponseAN to res
	} 
	
	constraint BuildDeleteProductQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { } 
	constraint BuildDeleteProductResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def CreateProductCP ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) { 
		body { 
			actions : 
				BuildCreateProductQueryAN : BuildCreateProductQueryAN { 
					using pins : 
						req : HTTPRequestDT ;
				} 
				
				BuildCreateProductResponseAN : BuildCreateProductResponseAN { 
					using pins : 
						res : DBResponseDT ;
				} 
			
			delegate p2 to BuildCreateProductQueryAN
			delegate p0 to req
			delegate p3 to res
			delegate p1 to BuildCreateProductResponseAN
		}
	} 
	
	action def BuildCreateProductQueryAN ( req : HTTPRequestDT ) : DBQueryDT { 
		constraint : 
			post-condition BuildCreateProductQueryEQ 
			pre-condition BuildCreateProductQueryPriceGTZeroEQ
		delegate req to req 
		delegate BuildCreateProductQueryAN to qry
	delegate req to reqVerify } 
	
	action def BuildCreateProductResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT { 
		constraint : 
			post-condition BuildCreateProductResponseEQ 
		delegate dbRes to dbRes 
		delegate BuildCreateProductResponseAN to res
	} 
	
	constraint BuildCreateProductQueryPriceGTZeroEQ ( reqVerify : HTTPRequestDT ) { }
	constraint BuildCreateProductQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { } 
	constraint BuildCreateProductResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def UpdateProductCP ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) { 
		body { 
			actions : 
				BuildUpdateProductQueryAN : BuildUpdateProductQueryAN { 
					using pins : 
						req : HTTPRequestDT ;
				} 
				
				BuildUpdateProductResponseAN : BuildUpdateProductResponseAN { 
					using pins : 
						res : DBResponseDT ;
				} 
			
			delegate p2 to BuildUpdateProductQueryAN
			delegate p0 to req
			delegate p3 to res
			delegate p1 to BuildUpdateProductResponseAN
		}
	} 
	
	action def BuildUpdateProductQueryAN ( req : HTTPRequestDT ) : DBQueryDT { 
		constraint : 
			post-condition BuildUpdateProductQueryEQ 
			pre-condition BuildUpdateProductQueryPriceGTZeroEQ
		delegate req to req
		delegate BuildUpdateProductQueryAN to qry
		delegate req to reqVerify
	} 
	
	action def BuildUpdateProductResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT { 
		constraint : 
			post-condition BuildUpdateProductResponseEQ 
		delegate dbRes to dbRes 
		delegate BuildUpdateProductResponseAN to res
	} 
	
	constraint BuildUpdateProductQueryPriceGTZeroEQ ( reqVerify : HTTPRequestDT ) { }
	constraint BuildUpdateProductQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { } 
	constraint BuildUpdateProductResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }

	activity def GetMachineStockCP ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) { 
		body { 
			actions : 
				BuildGetMachineStockQueryAN : BuildGetMachineStockQueryAN { 
					using pins : 
						req : HTTPRequestDT ;
				} 
				
				BuildGetMachineStockResponseAN : BuildGetMachineStockResponseAN { 
					using pins : 
						res : DBResponseDT ;
				} 
			
			delegate p2 to BuildGetMachineStockQueryAN
			delegate p0 to req
			delegate p3 to res
			delegate p1 to BuildGetMachineStockResponseAN
		}
	} 
	
	action def BuildGetMachineStockQueryAN ( req : HTTPRequestDT ) : DBQueryDT { 
		constraint : 
			post-condition BuildGetMachineStockQueryEQ
		delegate req to req 
		delegate BuildGetMachineStockQueryAN to qry
	} 
	
	action def BuildGetMachineStockResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT { 
		constraint : 
			post-condition BuildGetMachineStockResponseEQ 
		delegate dbRes to dbRes 
		delegate BuildGetMachineStockResponseAN to res
	} 
	
	constraint BuildGetMachineStockQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { } 
	constraint BuildGetMachineStockResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def CreatePersonalInfoCP ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) {
	
	    body {
	        actions :
	            ValidateCreatePersonalInfoAN : ValidateCreatePersonalInfoAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildCreatePersonalInfoQueryAN : BuildCreatePersonalInfoQueryAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildCreatePersonalInfoResponseAN : BuildCreatePersonalInfoResponseAN {
	                using pins :
	                    res : DBResponseDT ;
	            }
	
	        delegate p0 to req
	        delegate p2 to BuildCreatePersonalInfoQueryAN
	        delegate p3 to res
	        delegate p1 to BuildCreatePersonalInfoResponseAN
	    }
	}
	
	action def ValidateCreatePersonalInfoAN ( req : HTTPRequestDT ) : HTTPRequestDT {
	    constraint :
	        pre-condition ValidateAgeEQ
	        pre-condition ValidateCPFEQ
	    delegate req to req
	}
	
	action def BuildCreatePersonalInfoQueryAN ( req : HTTPRequestDT ) : DBQueryDT {
	    constraint :
	        post-condition BuildCreatePersonalInfoQueryEQ
	    delegate req to req
	    delegate BuildCreatePersonalInfoQueryAN to qry
	}
	
	action def BuildCreatePersonalInfoResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT {
	    constraint :
	        post-condition BuildCreatePersonalInfoResponseEQ
	    delegate dbRes to dbRes
	    delegate BuildCreatePersonalInfoResponseAN to res
	}
	
	constraint ValidateAgeEQ ( req : HTTPRequestDT ) { }
	constraint ValidateCPFEQ ( req : HTTPRequestDT ) { }
	constraint BuildCreatePersonalInfoQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { }
	constraint BuildCreatePersonalInfoResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def UpdatePersonalInfoCP ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) {
	    body {
	        actions :
	            ValidateUpdatePersonalInfoAN : ValidateUpdatePersonalInfoAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildUpdatePersonalInfoQueryAN : BuildUpdatePersonalInfoQueryAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildUpdatePersonalInfoResponseAN : BuildUpdatePersonalInfoResponseAN {
	                using pins :
	                    res : DBResponseDT ;
	            }
	
	        delegate p0 to req
	        delegate p2 to BuildUpdatePersonalInfoQueryAN
	        delegate p3 to res
	        delegate p1 to BuildUpdatePersonalInfoResponseAN
	    }
	}
	
	action def ValidateUpdatePersonalInfoAN ( req : HTTPRequestDT ) : HTTPRequestDT {
	    constraint :
	        pre-condition ValidateAgeEQ
	        pre-condition ValidateCPFEQ
	    delegate req to req
	}
	
	action def BuildUpdatePersonalInfoQueryAN ( req : HTTPRequestDT ) : DBQueryDT {
	    constraint :
	        post-condition BuildUpdatePersonalInfoQueryEQ
	    delegate req to req
	    delegate BuildUpdatePersonalInfoQueryAN to qry
	}
	
	action def BuildUpdatePersonalInfoResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT {
	    constraint :
	        post-condition BuildUpdatePersonalInfoResponseEQ
	    delegate dbRes to dbRes
	    delegate BuildUpdatePersonalInfoResponseAN to res
	}
	
	constraint BuildUpdatePersonalInfoQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { }
	constraint BuildUpdatePersonalInfoResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def UserDeleteCP ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) {
	    body {
	        actions :
	            ValidateUserDeleteAN : ValidateUserDeleteAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildUserDeleteQueryAN : BuildUserDeleteQueryAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildUserDeleteResponseAN : BuildUserDeleteResponseAN {
	                using pins :
	                    res : DBResponseDT ;
	            }
	
	        delegate p0 to req
	        delegate p2 to BuildUserDeleteQueryAN
	        delegate p3 to res
	        delegate p1 to BuildUserDeleteResponseAN
	    }
	}
	
	action def ValidateUserDeleteAN ( req : HTTPRequestDT ) : HTTPRequestDT {
	    constraint :
	        pre-condition ValidateDeleteRequestEQ
	    delegate req to req
	}
	
	action def BuildUserDeleteQueryAN ( req : HTTPRequestDT ) : DBQueryDT {
	    constraint :
	        post-condition BuildUserDeleteQueryEQ
	    delegate req to req
	    delegate BuildUserDeleteQueryAN to qry
	}
	
	action def BuildUserDeleteResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT {
	    constraint :
	        post-condition BuildUserDeleteResponseEQ
	    delegate dbRes to dbRes
	    delegate BuildUserDeleteResponseAN to res
	}
	
	constraint ValidateDeleteRequestEQ ( req : HTTPRequestDT ) { }
	constraint BuildUserDeleteQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { }
	constraint BuildUserDeleteResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def UserRetrieveAC ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) {
	    body {
	        actions :
	            ValidateUserRetrieveAN : ValidateUserRetrieveAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildUserRetrieveQueryAN : BuildUserRetrieveQueryAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildUserRetrieveResponseAN : BuildUserRetrieveResponseAN {
	                using pins :
	                    res : DBResponseDT ;
	            }
	
	        delegate p0 to req
	        delegate p2 to BuildUserRetrieveQueryAN
	        delegate p3 to res
	        delegate p1 to BuildUserRetrieveResponseAN
	    }
	}
	
	action def ValidateUserRetrieveAN ( req : HTTPRequestDT ) : HTTPRequestDT {
	    constraint :
	        pre-condition ValidateRetrieveIdEQ
	    delegate req to req
	}
	
	action def BuildUserRetrieveQueryAN ( req : HTTPRequestDT ) : DBQueryDT {
	    constraint :
	        post-condition BuildUserRetrieveQueryEQ
	    delegate req to req
	    delegate BuildUserRetrieveQueryAN to qry
	}
	
	action def BuildUserRetrieveResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT {
	    constraint :
	        post-condition BuildUserRetrieveResponseEQ
	    delegate dbRes to dbRes
	    delegate BuildUserRetrieveResponseAN to res
	}
	activity def UserAuthAC ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) {
	    body {
	        actions :
	            ValidateUserAuthAN : ValidateUserAuthAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildUserAuthQueryAN : BuildUserAuthQueryAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildUserAuthResponseAN : BuildUserAuthResponseAN {
	                using pins :
	                    res : DBResponseDT ;
	            }
	
	        delegate p0 to req
	        delegate p2 to BuildUserAuthQueryAN
	        delegate p3 to res
	        delegate p1 to BuildUserAuthResponseAN
	    }
	}
	
	action def ValidateUserAuthAN ( req : HTTPRequestDT ) : HTTPRequestDT {
	    constraint :
	        pre-condition ValidateCredentialsFormatEQ
	    delegate req to req
	}
	
	action def BuildUserAuthQueryAN ( req : HTTPRequestDT ) : DBQueryDT {
	    constraint :
	        post-condition BuildUserAuthQueryEQ
	    delegate req to req
	    delegate BuildUserAuthQueryAN to qry
	}
	
	action def BuildUserAuthResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT {
	    constraint :
	        post-condition BuildUserAuthResponseEQ
	    delegate dbRes to dbRes
	    delegate BuildUserAuthResponseAN to res
	}
	
	constraint ValidateRetrieveIdEQ ( req : HTTPRequestDT ) { }
	constraint BuildUserRetrieveQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { }
	constraint BuildUserRetrieveResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	constraint ValidateCredentialsFormatEQ ( req : HTTPRequestDT ) { }
	constraint BuildUserAuthQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { }
	constraint BuildUserAuthResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def CreatePaymentMethodsAC ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) {
	    body {
	        actions :
	            ValidateCreatePaymentMethodAN : ValidateCreatePaymentMethodAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildCreatePaymentMethodQueryAN : BuildCreatePaymentMethodQueryAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildCreatePaymentMethodResponseAN : BuildCreatePaymentMethodResponseAN {
	                using pins :
	                    res : DBResponseDT ;
	            }
	
	        delegate p0 to req
	        delegate p2 to BuildCreatePaymentMethodQueryAN
	        delegate p3 to res
	        delegate p1 to BuildCreatePaymentMethodResponseAN
	    }
	}
	
	action def ValidateCreatePaymentMethodAN ( req : HTTPRequestDT ) : HTTPRequestDT {
	    constraint :
	        pre-condition ValidateCardNumberEQ
	        pre-condition ValidateCardExpirationEQ
	        pre-condition ValidateCardCVVEQ
	    delegate req to req
	}
	
	action def BuildCreatePaymentMethodQueryAN ( req : HTTPRequestDT ) : DBQueryDT {
	    constraint :
	        post-condition BuildCreatePaymentMethodQueryEQ
	    delegate req to req
	    delegate BuildCreatePaymentMethodQueryAN to qry
	}
	
	action def BuildCreatePaymentMethodResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT {
	    constraint :
	        post-condition BuildCreatePaymentMethodResponseEQ
	    delegate dbRes to dbRes
	    delegate BuildCreatePaymentMethodResponseAN to res
	}
	
	activity def UpdatePaymentMethodsAC ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) {
	    body {
	        actions :
	            ValidateUpdatePaymentMethodAN : ValidateUpdatePaymentMethodAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildUpdatePaymentMethodQueryAN : BuildUpdatePaymentMethodQueryAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildUpdatePaymentMethodResponseAN : BuildUpdatePaymentMethodResponseAN {
	                using pins :
	                    res : DBResponseDT ;
	            }
	
	        delegate p0 to req
	        delegate p2 to BuildUpdatePaymentMethodQueryAN
	        delegate p3 to res
	        delegate p1 to BuildUpdatePaymentMethodResponseAN
	    }
	}
	
	action def ValidateUpdatePaymentMethodAN ( req : HTTPRequestDT ) : HTTPRequestDT {
	    constraint :
	        pre-condition ValidatePaymentIdEQ
	        pre-condition ValidateCardNumberEQ
	        pre-condition ValidateCardExpirationEQ
	        pre-condition ValidateCardCVVEQ
	    delegate req to req
	}
	
	action def BuildUpdatePaymentMethodQueryAN ( req : HTTPRequestDT ) : DBQueryDT {
	    constraint :
	        post-condition BuildUpdatePaymentMethodQueryEQ
	    delegate req to req
	    delegate BuildUpdatePaymentMethodQueryAN to qry
	}
	
	action def BuildUpdatePaymentMethodResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT {
	    constraint :
	        post-condition BuildUpdatePaymentMethodResponseEQ
	    delegate dbRes to dbRes
	    delegate BuildUpdatePaymentMethodResponseAN to res
	}
	
	constraint ValidateCardNumberEQ ( req : HTTPRequestDT ) { }
	constraint ValidateCardExpirationEQ ( req : HTTPRequestDT ) { }
	constraint ValidateCardCVVEQ ( req : HTTPRequestDT ) { }
	constraint BuildCreatePaymentMethodQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { }
	constraint BuildCreatePaymentMethodResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	constraint ValidatePaymentIdEQ ( req : HTTPRequestDT ) { }
	constraint BuildUpdatePaymentMethodQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { }
	constraint BuildUpdatePaymentMethodResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def RegisterBiometricAC ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) {
	    body {
	        actions :
	            ValidateRegisterBiometricAN : ValidateRegisterBiometricAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildRegisterBiometricQueryAN : BuildRegisterBiometricQueryAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildRegisterBiometricResponseAN : BuildRegisterBiometricResponseAN {
	                using pins :
	                    res : DBResponseDT ;
	            }
	
	        delegate p0 to req
	        delegate p2 to BuildRegisterBiometricQueryAN
	        delegate p3 to res
	        delegate p1 to BuildRegisterBiometricResponseAN
	    }
	}
	
	action def ValidateRegisterBiometricAN ( req : HTTPRequestDT ) : HTTPRequestDT {
	    constraint :
	        pre-condition ValidateBiometricDataEQ
	        pre-condition ValidateUserExistsEQ
	    delegate req to req
	}
	
	action def BuildRegisterBiometricQueryAN ( req : HTTPRequestDT ) : DBQueryDT {
	    constraint :
	        post-condition BuildRegisterBiometricQueryEQ
	    delegate req to req
	    delegate BuildRegisterBiometricQueryAN to qry
	}
	
	action def BuildRegisterBiometricResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT {
	    constraint :
	        post-condition BuildRegisterBiometricResponseEQ
	    delegate dbRes to dbRes
	    delegate BuildRegisterBiometricResponseAN to res
	}
	
	constraint ValidateBiometricDataEQ ( req : HTTPRequestDT ) { }
	constraint ValidateUserExistsEQ ( req : HTTPRequestDT ) { }
	constraint BuildRegisterBiometricQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { }
	constraint BuildRegisterBiometricResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def RemoveBiometricAC ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) {
	    body {
	        actions :
	            ValidateRemoveBiometricAN : ValidateRemoveBiometricAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildRemoveBiometricQueryAN : BuildRemoveBiometricQueryAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildRemoveBiometricResponseAN : BuildRemoveBiometricResponseAN {
	                using pins :
	                    res : DBResponseDT ;
	            }
	
	        delegate p0 to req
	        delegate p2 to BuildRemoveBiometricQueryAN
	        delegate p3 to res
	        delegate p1 to BuildRemoveBiometricResponseAN
	    }
	}
	
	action def ValidateRemoveBiometricAN ( req : HTTPRequestDT ) : HTTPRequestDT {
	    constraint :
	        pre-condition ValidateRemoveBiometricRequestEQ
	    delegate req to req
	}
	
	action def BuildRemoveBiometricQueryAN ( req : HTTPRequestDT ) : DBQueryDT {
	    constraint :
	        post-condition BuildRemoveBiometricQueryEQ
	    delegate req to req
	    delegate BuildRemoveBiometricQueryAN to qry
	}
	
	action def BuildRemoveBiometricResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT {
	    constraint :
	        post-condition BuildRemoveBiometricResponseEQ
	    delegate dbRes to dbRes
	    delegate BuildRemoveBiometricResponseAN to res
	}
	
	constraint ValidateRemoveBiometricRequestEQ ( req : HTTPRequestDT ) { }
	constraint BuildRemoveBiometricQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { }
	constraint BuildRemoveBiometricResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def BiometricRecognitionAC ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) {
	    body {
	        actions :
	            ValidateRecognitionInputAN : ValidateRecognitionInputAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildIdentifyBiometricQueryAN : BuildIdentifyBiometricQueryAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            // Ao 1: Processa os dados e retorna o ID ou -1
	            VerifyBiometricMatchAN : VerifyBiometricMatchAN {
	                using pins :
	                    dbRes : DBResponseDT ;
	                    originalReq : HTTPRequestDT ;
	            }
	
	            // Ao 2: Recebe o ID e constri a resposta HTTP
	            BuildBiometricResponseAN : BuildBiometricResponseAN {
	                using pins :
	                    userId : Int ;
	            }
	
	        // Fluxo de entrada e Query
	        delegate p0 to req
	        delegate p0 to originalReq // Para a verificao
	        delegate p2 to BuildIdentifyBiometricQueryAN
	        delegate p3 to dbRes
	    }
	}
	
	action def ValidateRecognitionInputAN ( req : HTTPRequestDT ) : HTTPRequestDT {
	    constraint :
	        pre-condition ValidateRecognitionDataEQ
	    delegate req to req
	}
	
	action def BuildIdentifyBiometricQueryAN ( req : HTTPRequestDT ) : DBQueryDT {
	    constraint :
	        post-condition BuildIdentifyBiometricQueryEQ
	    delegate req to req
	    delegate BuildIdentifyBiometricQueryAN to qry
	}
	
	action def VerifyBiometricMatchAN ( dbRes : DBResponseDT, originalReq : HTTPRequestDT ) : Int {
	    constraint :
	        post-condition VerifyBiometricMatchEQ
	    delegate dbRes to dbRes
	    delegate originalReq to originalReq
	    delegate VerifyBiometricMatchAN to userIdFound
	}
	
	action def BuildBiometricResponseAN ( userId : Int ) : HTTPResponseDT {
	    constraint :
	        post-condition BuildBiometricResponseEQ
	    delegate userId to userId
	    delegate BuildBiometricResponseAN to res
	}
	
	constraint ValidateRecognitionDataEQ ( req : HTTPRequestDT ) { }
	constraint BuildIdentifyBiometricQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { }
	constraint VerifyBiometricMatchEQ ( dbRes : DBResponseDT, originalReq : HTTPRequestDT ) : ( userIdFound : Int ) { }
	constraint BuildBiometricResponseEQ ( userId : Int ) : ( res : HTTPResponseDT ) { }
	
	activity def UpdateOrderAC ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) {
	    body {
	        actions :
	            ValidateUpdateOrderAN : ValidateUpdateOrderAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildUpdateOrderQueryAN : BuildUpdateOrderQueryAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildUpdateOrderResponseAN : BuildUpdateOrderResponseAN {
	                using pins :
	                    res : DBResponseDT ;
	            }
	
	        delegate p0 to req
	        delegate p2 to BuildUpdateOrderQueryAN
	        delegate p3 to res
	        delegate p1 to BuildUpdateOrderResponseAN
	    }
	}
	
	action def ValidateUpdateOrderAN ( req : HTTPRequestDT ) : HTTPRequestDT {
	    constraint :
	        pre-condition ValidateUpdateOrderRequestEQ
	    delegate req to req
	}
	
	action def BuildUpdateOrderQueryAN ( req : HTTPRequestDT ) : DBQueryDT {
	    constraint :
	        post-condition BuildUpdateOrderQueryEQ
	    delegate req to req
	    delegate BuildUpdateOrderQueryAN to qry
	}
	
	action def BuildUpdateOrderResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT {
	    constraint :
	        post-condition BuildUpdateOrderResponseEQ
	    delegate dbRes to dbRes
	    delegate BuildUpdateOrderResponseAN to res
	}
	
	constraint ValidateUpdateOrderRequestEQ ( req : HTTPRequestDT ) { }
	constraint BuildUpdateOrderQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { }
	constraint BuildUpdateOrderResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def CheckDebtsAC ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) {
	    body {
	        actions :
	            ValidateCheckDebtsRequestAN : ValidateCheckDebtsRequestAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildCheckDebtsQueryAN : BuildCheckDebtsQueryAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildCheckDebtsResponseAN : BuildCheckDebtsResponseAN {
	                using pins :
	                    res : DBResponseDT ;
	            }
	
	        delegate p0 to req
	        delegate p2 to BuildCheckDebtsQueryAN
	        delegate p3 to res
	        delegate p1 to BuildCheckDebtsResponseAN
	    }
	}
	
	action def ValidateCheckDebtsRequestAN ( req : HTTPRequestDT ) : HTTPRequestDT {
	    constraint :
	        pre-condition ValidateCheckDebtsRequestEQ
	    delegate req to req
	}
	
	action def BuildCheckDebtsQueryAN ( req : HTTPRequestDT ) : DBQueryDT {
	    constraint :
	        post-condition BuildCheckDebtsQueryEQ
	    delegate req to req
	    delegate BuildCheckDebtsQueryAN to qry
	}
	
	action def BuildCheckDebtsResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT {
	    constraint :
	        post-condition BuildCheckDebtsResponseEQ
	    delegate dbRes to dbRes
	    delegate BuildCheckDebtsResponseAN to res
	}
	
	constraint ValidateCheckDebtsRequestEQ ( req : HTTPRequestDT ) { }
	constraint BuildCheckDebtsQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { }
	constraint BuildCheckDebtsResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def RetrieveOrderAC ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) : ( p1 : HTTPResponseDT , p2 : DBQueryDT ) {
	    body {
	        actions :
	            ValidateRetrieveOrderAN : ValidateRetrieveOrderAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildRetrieveOrderQueryAN : BuildRetrieveOrderQueryAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildRetrieveOrderResponseAN : BuildRetrieveOrderResponseAN {
	                using pins :
	                    res : DBResponseDT ;
	            }
	
	        delegate p0 to req
	        delegate p2 to BuildRetrieveOrderQueryAN
	        delegate p3 to res
	        delegate p1 to BuildRetrieveOrderResponseAN
	    }
	}
	
	action def ValidateRetrieveOrderAN ( req : HTTPRequestDT ) : HTTPRequestDT {
	    constraint :
	        pre-condition ValidateRetrieveOrderRequestEQ
	    delegate req to req
	}
	
	action def BuildRetrieveOrderQueryAN ( req : HTTPRequestDT ) : DBQueryDT {
	    constraint :
	        post-condition BuildRetrieveOrderQueryEQ
	    delegate req to req
	    delegate BuildRetrieveOrderQueryAN to qry
	}
	
	action def BuildRetrieveOrderResponseAN ( dbRes : DBResponseDT ) : HTTPResponseDT {
	    constraint :
	        post-condition BuildRetrieveOrderResponseEQ
	    delegate dbRes to dbRes
	    delegate BuildRetrieveOrderResponseAN to res
	}
	
	constraint ValidateRetrieveOrderRequestEQ ( req : HTTPRequestDT ) { }
	constraint BuildRetrieveOrderQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { }
	constraint BuildRetrieveOrderResponseEQ ( dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def CreateOrderAC ( p0 : HTTPRequestDT ) ( p3 : DBResponseDT ) ( p5 : HTTPResponseDT ) : ( p1 : HTTPResponseDT, p2 : DBQueryDT, p4 : HTTPRequestDT ) {
	    body {
	        actions :
	            ValidateCreateOrderAN : ValidateCreateOrderAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildCreateOrderQueryAN : BuildCreateOrderQueryAN {
	                using pins :
	                    req : HTTPRequestDT ;
	            }
	
	            BuildProcessingRequestAN : BuildProcessingRequestAN {
	                using pins :
	                    dbRes : DBResponseDT ;
	                    originalReq : HTTPRequestDT ;
	            }
	
	            BuildFinalOrderResponseAN : BuildFinalOrderResponseAN {
	                using pins :
	                    procRes : HTTPResponseDT ;
	                    dbRes : DBResponseDT ;
	            }
	
	        delegate p0 to req
	        delegate p0 to originalReq
	        delegate p3 to dbRes
	        delegate p5 to procRes
	        delegate p2 to BuildCreateOrderQueryAN
	        delegate p4 to BuildProcessingRequestAN
	        delegate p1 to BuildFinalOrderResponseAN
	    }
	}
	
	action def ValidateCreateOrderAN ( req : HTTPRequestDT ) : HTTPRequestDT {
	    constraint :
	        pre-condition ValidateCreateOrderRequestEQ
	    delegate req to req
	}
	
	action def BuildCreateOrderQueryAN ( req : HTTPRequestDT ) : DBQueryDT {
	    constraint :
	        post-condition BuildCreateOrderQueryEQ
	    delegate req to req
	    delegate BuildCreateOrderQueryAN to qry
	}
	
	action def BuildProcessingRequestAN ( dbRes : DBResponseDT, originalReq : HTTPRequestDT ) : HTTPRequestDT {
	    constraint :
	        post-condition BuildProcessingRequestEQ
	    delegate dbRes to dbRes
	    delegate originalReq to originalReq
	    delegate BuildProcessingRequestAN to procReq
	}
	
	action def BuildFinalOrderResponseAN ( procRes : HTTPResponseDT, dbRes : DBResponseDT ) : HTTPResponseDT {
	    constraint :
	        post-condition BuildFinalOrderResponseEQ
	    delegate procRes to procRes
	    delegate dbRes to dbRes
	    delegate BuildFinalOrderResponseAN to res
	}
	
	constraint ValidateCreateOrderRequestEQ ( req : HTTPRequestDT ) { }
	constraint BuildCreateOrderQueryEQ ( req : HTTPRequestDT ) : ( qry : DBQueryDT ) { }
	constraint BuildProcessingRequestEQ ( dbRes : DBResponseDT, originalReq : HTTPRequestDT ) : ( procReq : HTTPRequestDT ) { }
	constraint BuildFinalOrderResponseEQ ( procRes : HTTPResponseDT, dbRes : DBResponseDT ) : ( res : HTTPResponseDT ) { }
	
	activity def CheckItemsAvailabilityAC ( order : OrderDT ) ( stockRes : HTTPResponseDT ) : ( available : Boolean, stockReq : HTTPRequestDT ) {
	    body {
	        actions :
	            BuildStockCheckQueryAN : BuildStockCheckQueryAN {
	                using pins :
	                    order : OrderDT ;
	            }
	
	            VerifyStockAvailabilityAN : VerifyStockAvailabilityAN {
	                using pins :
	                    stockRes : HTTPResponseDT ;
	                    originalOrder : OrderDT ;
	            }
	
	        delegate order to order
	        delegate order to originalOrder
	        delegate stockRes to stockRes
	    }
	}
	
	action def BuildStockCheckQueryAN ( order : OrderDT ) : HTTPRequestDT {
	    constraint :
	        post-condition BuildStockCheckQueryEQ
	    delegate order to order
	    delegate BuildStockCheckQueryAN to req
	}
	
	action def VerifyStockAvailabilityAN ( stockRes : HTTPResponseDT, originalOrder : OrderDT ) : Boolean {
	    constraint :
	        post-condition VerifyStockAvailabilityEQ
	    delegate stockRes to stockRes
	    delegate originalOrder to originalOrder
	    delegate VerifyStockAvailabilityAN to available
	}
	
	constraint BuildStockCheckQueryEQ ( order : OrderDT ) : ( req : HTTPRequestDT ) { }
	constraint VerifyStockAvailabilityEQ ( stockRes : HTTPResponseDT, originalOrder : OrderDT ) : ( available : Boolean ) { }
	
	activity def PaymentProcessingAC ( chargeReq : OrderChargeDT ) ( dbRes : DBResponseDT ) : ( status : PaymentStatusEnum, qry : DBQueryDT ) {
	    body {
	        actions :
	            BuildGetPaymentMethodQueryAN : BuildGetPaymentMethodQueryAN {
	                using pins :
	                    chargeReq : OrderChargeDT ;
	            }
	
	            ExecutePaymentTransactionAN : ExecutePaymentTransactionAN {
	                using pins :
	                    dbRes : DBResponseDT ;
	                    chargeReq : OrderChargeDT ;
	            }
	
	            BuildPaymentStatusAN : BuildPaymentStatusAN {
	                using pins :
	                    rawResult : Boolean ;
	            }
	
	        delegate chargeReq to chargeReq
	        delegate dbRes to dbRes
	    }
	}
	
	action def BuildGetPaymentMethodQueryAN ( chargeReq : OrderChargeDT ) : DBQueryDT {
	    constraint :
	        post-condition BuildGetPaymentMethodQueryEQ
	    delegate chargeReq to chargeReq
	    delegate BuildGetPaymentMethodQueryAN to qry
	}
	
	action def ExecutePaymentTransactionAN ( dbRes : DBResponseDT, chargeReq : OrderChargeDT ) : Boolean {
	    constraint :
	        post-condition ExecutePaymentTransactionEQ
	    delegate dbRes to dbRes
	    delegate chargeReq to chargeReq
	    delegate ExecutePaymentTransactionAN to success
	}
	
	action def BuildPaymentStatusAN ( rawResult : Boolean ) : PaymentStatusEnum {
	    constraint :
	        post-condition BuildPaymentStatusEQ
	    delegate rawResult to rawResult
	    delegate BuildPaymentStatusAN to status
	}
	
	constraint BuildGetPaymentMethodQueryEQ ( chargeReq : OrderChargeDT ) : ( qry : DBQueryDT ) { }
	constraint ExecutePaymentTransactionEQ ( dbRes : DBResponseDT, chargeReq : OrderChargeDT ) : ( success : Boolean ) { }
	constraint BuildPaymentStatusEQ ( rawResult : Boolean ) : ( status : PaymentStatusEnum ) { }
	
	activity def PriceCalculationAC ( items : OrderItemArrayDT ) : ( totalPrice : Real ) {
	    body {
	        actions :
	            CalculateTotalAN : CalculateTotalAN {
	                using pins :
	                    items : OrderItemArrayDT ;
	            }
	
	        delegate items to items
	    }
	}
	
	action def CalculateTotalAN ( items : OrderItemArrayDT ) : Real {
	    constraint :
	        post-condition CalculateTotalEQ
	    delegate items to items
	    delegate CalculateTotalAN to total
	}
	
	constraint CalculateTotalEQ ( items : OrderItemArrayDT ) : ( total : Real ) { }
	
	activity def AdditionalProcessingCoordinatorAC (
	    order : OrderDT ) (
	    calculatedPrice : Real ) (
	    routedKitchenId : Int
	) : (
	    processingResult : OrderProcessingDT,
	    itemsForPricing : OrderItemArrayDT,
	    itemsForRouting : OrderItemArrayDT
	) {
	    body {
	        actions :
	            DistributeItemsToPricingAN : DistributeItemsToPricingAN {
	                using pins :
	                    orderPricing : OrderDT ;
	            }
	            
	            DistributeItemsToRoutingAN : DistributeItemsToRoutingAN {
	                using pins :
	                    orderRouting : OrderDT ;
	            }
	
	            BuildProcessingResultAN : BuildProcessingResultAN {
	                using pins :
	                    price : Real ;
	                    kitchenId : Int ;
	            }
	
	        delegate order to orderPricing
	        delegate order to orderRouting
	        delegate calculatedPrice to price
	        delegate routedKitchenId to kitchenId
	        
	    delegate processingResult to BuildProcessingResultAN delegate itemsForRouting to DistributeItemsToRoutingAN delegate itemsForPricing to DistributeItemsToPricingAN }
	}
	
	action def DistributeItemsToPricingAN ( order : OrderDT ) : OrderItemArrayDT {
	    constraint :
	        post-condition DistributeItemsEQ
	    	delegate order to order
			delegate DistributeItemsToPricingAN to items 
		}
	
	action def DistributeItemsToRoutingAN ( order : OrderDT ) : OrderItemArrayDT {
	    constraint :
	        post-condition DistributeItemsEQ
	    delegate order to order
	delegate DistributeItemsToRoutingAN to items }
	
	action def BuildProcessingResultAN ( price : Real, kitchenId : Int ) : OrderProcessingDT {
	    constraint :
	        post-condition BuildProcessingResultEQ
	    delegate price to price
	    delegate kitchenId to kitchenId
	    delegate BuildProcessingResultAN to result
	}
	
	constraint DistributeItemsEQ ( order : OrderDT ) : ( items : OrderItemArrayDT) { }
	constraint BuildProcessingResultEQ ( price : Real, kitchenId : Int ) : ( result : OrderProcessingDT ) { }
	
	activity def OrderProcessingCoordinatorAC (
	    order : OrderDT ) (
	    debtsRes : HTTPResponseDT ) (
	    availResult : Boolean ) (
	    procResult : OrderProcessingDT ) (
	    payResult : PaymentStatusEnum
	) : (
	    debtsReq : HTTPRequestDT,
	    itemsForCheck : OrderItemArrayDT,
	    orderForProc : OrderDT,
	    chargeReq : OrderChargeDT,
	    finalResponse : HTTPResponseDT
	) {
	    body {
	        actions :
	            BuildCheckDebtsRequestAN : BuildCheckDebtsRequestAN {
	                using pins :
	                    order : OrderDT ;
	            }
	
	            ExtractItemsForAvailabilityAN : ExtractItemsForAvailabilityAN {
	                using pins :
	                    order : OrderDT ;
	            }
	
	            ForwardOrderToProcessingAN : ForwardOrderToProcessingAN {
	                using pins :
	                    order : OrderDT ;
	            }
	
	            PreparePaymentChargeAN : PreparePaymentChargeAN {
	                using pins :
	                    order : OrderDT ;
	                    procResult : OrderProcessingDT ;
	            }
	
	            EvaluateProcessingResultAN : EvaluateProcessingResultAN {
	                using pins :
	                    debtsRes : HTTPResponseDT ;
	                    availResult : Boolean ;
	                    payResult : PaymentStatusEnum ;
	            }
	
	        delegate order to order
	        delegate debtsRes to debtsRes
	        delegate availResult to availResult
	        delegate procResult to procResult
	        delegate payResult to payResult
	    }
	}
	
	action def BuildCheckDebtsRequestAN ( order : OrderDT ) : HTTPRequestDT {
	    constraint :
	        post-condition BuildCheckDebtsRequestEQ
	    delegate order to order
	    delegate BuildCheckDebtsRequestAN to req
	}
	
	action def ExtractItemsForAvailabilityAN ( order : OrderDT ) : OrderItemArrayDT {
	    constraint :
	        post-condition ExtractItemsForAvailabilityEQ
	    delegate order to order
	    delegate ExtractItemsForAvailabilityAN to items
	}
	
	action def ForwardOrderToProcessingAN ( order : OrderDT ) : OrderDT {
	    constraint :
	        post-condition ForwardOrderToProcessingEQ
	    delegate order to order
	    delegate ForwardOrderToProcessingAN to orderOut
	}
	
	action def PreparePaymentChargeAN ( order : OrderDT, procResult : OrderProcessingDT ) : OrderChargeDT {
	    constraint :
	        post-condition PreparePaymentChargeEQ
	    delegate order to order
	    delegate procResult to procResult
	    delegate PreparePaymentChargeAN to charge
	}
	
	action def EvaluateProcessingResultAN (
	    debtsRes : HTTPResponseDT,
	    availResult : Boolean,
	    payResult : PaymentStatusEnum
	) : HTTPResponseDT {
	    constraint :
	        post-condition EvaluateProcessingResultEQ
	    delegate debtsRes to debtsRes
	    delegate availResult to availResult
	    delegate payResult to payResult
	    delegate EvaluateProcessingResultAN to res
	}
	
	constraint BuildCheckDebtsRequestEQ ( order : OrderDT ) : ( req : HTTPRequestDT ) { }
	constraint ExtractItemsForAvailabilityEQ ( order : OrderDT ) : ( items : OrderItemArrayDT ) { }
	constraint ForwardOrderToProcessingEQ ( order : OrderDT ) : ( orderOut : OrderDT ) { }
	constraint PreparePaymentChargeEQ ( order : OrderDT, procResult : OrderProcessingDT ) : ( charge : OrderChargeDT ) { }
	constraint EvaluateProcessingResultEQ (
	    debtsRes : HTTPResponseDT,
	    availResult : Boolean,
	    payResult : PaymentStatusEnum
	) : (
	    res : HTTPResponseDT
	) { }
	
	activity def BiometricControllerAC ( reqType : BiometricTypeEnum ) : ( activateFP : Boolean, activateCam : Boolean ) {
	    body {
	        actions :
	            RouteSensorActivationAN : RouteFingerprintActivationAN {
	                using pins :
	                    reqTypeFinger : BiometricTypeEnum ;
	            } RouteCameraActivationAN : RouteCameraActivationAN { using pins : reqTypeCam : BiometricTypeEnum ; }
	
	        delegate reqType to reqTypeFinger
	    delegate reqType to reqTypeCam delegate activateFP to RouteSensorActivationAN delegate activateCam to RouteCameraActivationAN }
	}
	
	action def RouteFingerprintActivationAN ( reqType : BiometricTypeEnum ) : Boolean {
	    constraint :
	        post-condition RouteFingerprintActivationEQ
	    delegate reqType to reqType
	    delegate RouteFingerprintActivationAN to activateFP
	}
	
	constraint RouteFingerprintActivationEQ ( reqType : BiometricTypeEnum ) : ( activateFP : Boolean ) { }
	
	activity def BiometricTotemProcessorAC (
	    cpf : String ) (
	    userRes : HTTPResponseDT ) (
	    selectedType : BiometricTypeEnum ) (
	    sensorRes : HTTPResponseDT ) (
	    regRes : HTTPResponseDT
	) : (
	    userReq : HTTPRequestDT,
	    enableSel : Boolean,
	    sensorReq : HTTPRequestDT,
	    regReq : HTTPRequestDT
	) {
	    body {
	        actions :
	            BuildUserCheckRequestAN : BuildUserCheckRequestAN {
	                using pins :
	                    cpf : String ;
	            }
	
	            EvaluateUserAndEnableSelAN : EvaluateUserAndEnableSelAN {
	                using pins :
	                    userRes : HTTPResponseDT ;
	            }
	
	            BuildSensorCaptureRequestAN : BuildSensorCaptureRequestAN {
	                using pins :
	                    selectedType : BiometricTypeEnum ;
	            }
	
	            BuildRegisterRequestAN : BuildRegisterRequestAN {
	                using pins :
	                    sensorRes : HTTPResponseDT ;
	                    cpf : String ;
	            }
	
	        delegate cpf to cpf
	        delegate userRes to userRes
	        delegate selectedType to selectedType
	        delegate sensorRes to sensorRes
	    }
	}
	
	action def BuildUserCheckRequestAN ( cpf : String ) : HTTPRequestDT {
	    constraint :
	        post-condition BuildUserCheckRequestEQ
	    delegate cpf to cpf
	    delegate BuildUserCheckRequestAN to req
	}
	
	action def EvaluateUserAndEnableSelAN ( userRes : HTTPResponseDT ) : Boolean {
	    constraint :
	        post-condition EvaluateUserAndEnableSelEQ
	    delegate userRes to userRes
	    delegate EvaluateUserAndEnableSelAN to enable
	}
	
	action def BuildSensorCaptureRequestAN ( selectedType : BiometricTypeEnum ) : HTTPRequestDT {
	    constraint :
	        post-condition BuildSensorCaptureRequestEQ
	    delegate selectedType to selectedType
	    delegate BuildSensorCaptureRequestAN to req
	}
	
	action def BuildRegisterRequestAN ( sensorRes : HTTPResponseDT, cpf : String ) : HTTPRequestDT {
	    constraint :
	        post-condition BuildRegisterRequestEQ
	    delegate sensorRes to sensorRes
	    delegate cpf to cpf
	    delegate BuildRegisterRequestAN to req
	}
	
	constraint BuildUserCheckRequestEQ ( cpf : String ) : ( req : HTTPRequestDT ) { }
	constraint EvaluateUserAndEnableSelEQ ( userRes : HTTPResponseDT ) : ( enable : Boolean ) { }
	constraint BuildSensorCaptureRequestEQ ( selectedType : BiometricTypeEnum ) : ( req : HTTPRequestDT ) { }
	constraint BuildRegisterRequestEQ ( sensorRes : HTTPResponseDT, cpf : String ) : ( req : HTTPRequestDT ) { }
	
	activity def CompartmentActuatorAC ( cmd : CompartmentCMDEnum ) ( orderIdInput : String ) : ( orderAvailable : PickupOrderAddedDT ) {
	    body {
	        actions :
	            ExecuteCompartmentCommandAN : ExecuteCompartmentCommandAN {
	                using pins :
	                    cmd : CompartmentCMDEnum ;
	            }
	
	            RegisterOrderPlacementAN : RegisterOrderPlacementAN {
	                using pins :
	                    orderIdInput : String ;
	                    compartmentId : Int ;
	            }
	
	        delegate cmd to cmd
	        delegate orderIdInput to orderIdInput
	    	delegate orderAvailable to RegisterOrderPlacementAN 
	    	flow from id to compartmentId 
	    	datastore id : Int 
	    }
	}
	
	action def ExecuteCompartmentCommandAN ( cmd : CompartmentCMDEnum ) : Void {
	    constraint :
	        post-condition ExecuteCompartmentCommandEQ
	    delegate cmd to cmd
	}
	
	action def RegisterOrderPlacementAN ( orderIdInput : String, compartmentId : Int ) : PickupOrderAddedDT {
	    constraint :
	        post-condition RegisterOrderPlacementEQ
	    delegate orderIdInput to orderIdInput
	    delegate compartmentId to compartmentId
	    delegate RegisterOrderPlacementAN to orderInfo
	}
	
	constraint ExecuteCompartmentCommandEQ ( cmd : CompartmentCMDEnum ) { }
	constraint RegisterOrderPlacementEQ ( orderIdInput : String, compartmentId : Int ) : ( orderInfo : PickupOrderAddedDT ) { }
	
	action def RouteCameraActivationAN ( reqType : BiometricTypeEnum ) : Boolean { 
		constraint : 
			post-condition RouteCameraActivationEQ 
		delegate reqType to reqType 
		delegate RouteCameraActivationAN to activateCam
	} 
	
	constraint RouteCameraActivationEQ ( reqType : BiometricTypeEnum ) : ( activateCam : Boolean ) { } 
	
	activity def PickupFlowControllerAC (
	    compartmentArrived : Boolean ) (
	    biometricRawIPT_Barcode : BiometricRawDT ) (
	    orderAvailableController : PickupOrderAddedDT ) (
	    pickupDetectedController : Boolean ) (
	    selectedBiometricType_Pickup : BiometricTypeEnum ) (
	    sensorRes : HTTPResponseDT ) (
	    bioServerRes : HTTPResponseDT ) (
	    orderServerRes : HTTPResponseDT ) (
	    readyOrdersRes : HTTPResponseDT
	) : (
	    compartmentToMove : Int,
	    selectBiometric_Pickup : Boolean,
	    sensorActive_Barcode : Boolean,
	    compartmentCMDOpt : CompartmentCMDEnum,
	    pickupSensorReq : HTTPRequestDT,
	    identifyUserReq : HTTPRequestDT,
	    findOrderReq : HTTPRequestDT,
	    updateOrderReq : HTTPRequestDT,
	    fetchOrdersReq : HTTPRequestDT,
	    readyOrders : OrderItemArrayDT
	) {
	    body {
	        actions :
	            // Ao 1: Mantm seleo ativa
	            EnableSelectionAN : EnableSelectionAN {
	                using pins :
	                    triggerEnable : Boolean ;
	            }
	
	            // Ao 2: Ativa sensor Barcode se selecionado
	            ActivateBarcodeAN : ActivateBarcodeAN {
	                using pins :
	                    selectedTypeBarcode : BiometricTypeEnum ;
	            }
	
	            // Ao 3: Requisita sensor Biomtrico (HTTP) se Face/Digital
	            BuildSensorRequestAN : BuildSensorRequestAN {
	                using pins :
	                    selectedTypeSensor : BiometricTypeEnum ;
	            }
	
	            // Ao 4: Identifica usurio no BioServer com dados do Sensor
	            BuildIdentifyUserReqAN : BuildIdentifyUserReqAN {
	                using pins :
	                    userIdentifiedResponse : HTTPResponseDT ;
	            }
	
	            // Ao 5: Busca pedido do usurio no local atual
	            FindOrderByUserAN : FindOrderByUserAN {
	                using pins :
	                    bioServerRes : HTTPResponseDT ;
	                    currentLocation : Int ;
	            }
	
	            // Ao 6: Busca pedido pelo Barcode lido
	            FindOrderByBarcodeAN : FindOrderByBarcodeAN {
	                using pins :
	                    barcodeData : BiometricRawDT ;
	            }
	
	            // Ao 7: Move a esteira para o compartimento do pedido
	            CalculateMovementAN : CalculateMovementAN {
	                using pins :
	                    orderServerRes : HTTPResponseDT ;
	            }
	
	            // Ao 10 e 11: Controla porta (Abre ao chegar, Fecha ao retirar)
	            ControlDoorAN : ControlDoorAN {
	                using pins :
	                    arrived : Boolean ;
	                    pickupDetected : Boolean ;
	                    orderServerResponse : HTTPResponseDT ;
	            }
	
	            // Ao 8 (Parte A): Requisita lista de pedidos prontos
	            BuildFetchOrdersReqAN : BuildFetchOrdersReqAN {
	                using pins :
	                    triggerFetchOrders : Boolean ;
	            }
	
	            // Ao 8 (Parte B): Atualiza lista de pedidos prontos
	            UpdateDisplayListAN : UpdateDisplayListAN {
	                using pins :
	                    readyOrdersRes : HTTPResponseDT ;
	            }
	
	            // Ao 9: Atualiza status de novo pedido colocado (Staff)
	            BuildOrderPlacedUpdateReqAN : BuildOrderPlacedUpdateReqAN {
	                using pins :
	                    newOrder : PickupOrderAddedDT ;
	            }
	
	        // --- Ligaes ---
	
	        // Ao 1
	        flow from alwaysTrue to triggerEnable
	
	        // Ao 2 e 3 (Split da seleo)
	        delegate selectedBiometricType_Pickup to selectedTypeBarcode
	
	        // Ao 4
	        delegate sensorRes to userIdentifiedResponse
	
	        // Ao 5
	        delegate bioServerRes to bioServerRes
	        
	
	        // Ao 6
	        delegate biometricRawIPT_Barcode to barcodeData
	
	        // Ao 7
	        delegate orderServerRes to orderServerRes
	
	        // Ao 10 e 11
	        delegate compartmentArrived to arrived
	        delegate pickupDetectedController to pickupDetected
	
	        
	        delegate readyOrdersRes to readyOrdersRes
	
	        // Ao 9
	        delegate orderAvailableController to newOrder
	
	        // Datastores
	        delegate readyOrders to UpdateDisplayListAN 
	        delegate selectBiometric_Pickup to EnableSelectionAN 
	        
	        delegate updateOrderReq to BuildOrderPlacedUpdateReqAN flow from fetchTrigger to triggerFetchOrders delegate fetchOrdersReq to BuildFetchOrdersReqAN delegate sensorActive_Barcode to ActivateBarcodeAN delegate pickupSensorReq to BuildSensorRequestAN delegate selectedBiometricType_Pickup to selectedTypeSensor delegate identifyUserReq to BuildIdentifyUserReqAN flow from pickupId to currentLocation delegate findOrderReq to FindOrderByUserAN delegate findOrderReq to FindOrderByBarcodeAN delegate compartmentToMove to CalculateMovementAN delegate compartmentCMDOpt to ControlDoorAN delegate orderServerRes to orderServerResponse datastore alwaysTrue : Boolean
	        
	        datastore fetchTrigger : Boolean
	    datastore pickupId : Int
	    }
	}
	
	action def EnableSelectionAN ( trigger : Boolean ) : Boolean {
	    constraint :
	        post-condition EnableSelectionEQ
	    delegate trigger to trigger
	    delegate EnableSelectionAN to enabled
	}
	
	action def ActivateBarcodeAN ( selectedType : BiometricTypeEnum ) : Boolean {
	    constraint :
	        post-condition ActivateBarcodeEQ
	    delegate selectedType to selectedType
	    delegate ActivateBarcodeAN to isActive
	}
	
	action def BuildSensorRequestAN ( selectedType : BiometricTypeEnum ) : HTTPRequestDT {
	    constraint :
	        post-condition BuildSensorRequestEQ
	    delegate selectedType to selectedType
	    delegate BuildSensorRequestAN to req
	}
	
	action def BuildIdentifyUserReqAN ( sensorRes : HTTPResponseDT ) : HTTPRequestDT {
	    constraint :
	        post-condition BuildIdentifyUserReqEQ
	    delegate sensorRes to sensorRes
	    delegate BuildIdentifyUserReqAN to req
	}
	
	action def FindOrderByUserAN ( bioServerRes : HTTPResponseDT, currentLocation : Int ) : HTTPRequestDT {
	    constraint :
	        post-condition FindOrderByUserEQ
	    delegate bioServerRes to bioServerRes
	    delegate currentLocation to currentLocation
	    delegate FindOrderByUserAN to req
	}
	
	action def FindOrderByBarcodeAN ( barcodeData : BiometricRawDT ) : HTTPRequestDT {
	    constraint :
	        post-condition FindOrderByBarcodeEQ
	    delegate barcodeData to barcodeData
	    delegate FindOrderByBarcodeAN to req
	}
	
	action def CalculateMovementAN ( orderServerRes : HTTPResponseDT ) : Int {
	    constraint :
	        post-condition CalculateMovementEQ
	    delegate orderServerRes to orderServerRes
	    delegate CalculateMovementAN to moveCmd
	}
	
	action def ControlDoorAN ( orderServerRes : HTTPResponseDT, arrived : Boolean, pickupDetected : Boolean ) : CompartmentCMDEnum {
	    constraint :
	        post-condition ControlDoorEQ
	    delegate orderServerRes to orderServerRes
	    delegate arrived to arrived
	    delegate pickupDetected to pickupDetected
	    delegate ControlDoorAN to cmd
	}
	
	action def BuildFetchOrdersReqAN ( trigger : Boolean ) : HTTPRequestDT {
	    constraint :
	        post-condition BuildFetchOrdersReqEQ
	    delegate trigger to trigger
	    delegate BuildFetchOrdersReqAN to req
	}
	
	action def UpdateDisplayListAN ( readyOrdersRes : HTTPResponseDT ) : OrderItemArrayDT {
	    constraint :
	        post-condition UpdateDisplayListEQ
	    delegate readyOrdersRes to readyOrdersRes
	    delegate UpdateDisplayListAN to list
	}
	
	action def BuildOrderPlacedUpdateReqAN ( newOrder : PickupOrderAddedDT ) : HTTPRequestDT {
	    constraint :
	        post-condition BuildOrderPlacedUpdateReqEQ
	    delegate newOrder to newOrder
	    delegate BuildOrderPlacedUpdateReqAN to req
	}
	
	constraint EnableSelectionEQ ( trigger : Boolean ) : ( enabled : Boolean ) { }
	constraint ActivateBarcodeEQ ( selectedType : BiometricTypeEnum ) : ( isActive : Boolean ) { }
	constraint BuildSensorRequestEQ ( selectedType : BiometricTypeEnum ) : ( req : HTTPRequestDT ) { }
	constraint BuildIdentifyUserReqEQ ( sensorRes : HTTPResponseDT ) : ( req : HTTPRequestDT ) { }
	constraint FindOrderByUserEQ ( bioServerRes : HTTPResponseDT, currentLocation : Int ) : ( req : HTTPRequestDT ) { }
	constraint FindOrderByBarcodeEQ ( barcodeData : BiometricRawDT ) : ( req : HTTPRequestDT ) { }
	constraint CalculateMovementEQ ( orderServerRes : HTTPResponseDT ) : ( moveCmd : Int ) { }
	constraint ControlDoorEQ ( orderServerRes : HTTPResponseDT, arrived : Boolean, pickupDetected : Boolean ) : ( cmd : CompartmentCMDEnum ) { }
	constraint BuildFetchOrdersReqEQ ( trigger : Boolean ) : ( req : HTTPRequestDT ) { }
	constraint UpdateDisplayListEQ ( readyOrdersRes : HTTPResponseDT ) : ( list : OrderItemArrayDT ) { }
	constraint BuildOrderPlacedUpdateReqEQ ( newOrder : PickupOrderAddedDT ) : ( req : HTTPRequestDT ) { }
} 

package FoodFastPorts { 
	import SysADLTypes ;
	
	port def DBQueryIPT { 
		flow in DBQueryDT
	} 
	port def DBQueryOPT { 
		flow out DBQueryDT
	} 
	
	port def DBResponseIPT { 
		flow in DBResponseDT 
	} 
	port def DBResponseOPT { 
		flow out DBResponseDT
	} 
	
	port def DBServiceP { 
		ports : 
			queryIPT : DBQueryIPT ; 
			responseOPT : DBResponseOPT ;
	} 
	port def DBClientP { 
		ports : 
			queryOPT : DBQueryOPT ; 
			responseIPT : DBResponseIPT ;
	} 
	
	port def HTTPRequestIPT { 
		flow in HTTPRequestDT 
	} 
	port def HTTPRequestOPT { 
		flow out HTTPRequestDT
	} 
	
	port def HTTPResponseIPT { 
		flow in HTTPResponseDT 
	}
	port def HTTPResponseOPT { 
		flow out HTTPResponseDT
	} 
	
	port def HTTPServiceP {
		ports : 
			requestIPT : HTTPRequestIPT ; 
			responseOPT : HTTPResponseOPT ;
	} 
	port def HTTPClientP { 
		ports : 
			requestOPT : HTTPRequestOPT ;
			responseIPT : HTTPResponseIPT ;
	} 
	
	port def BiometricTypeIPT { 
		flow in BiometricTypeEnum
	} 
	port def BiometricTypeOPT { 
		flow out BiometricTypeEnum
	} 
	
	port def BiometricRawIPT {
		flow in BiometricRawDT
	} 
	port def BiometricRawOPT { 
		flow out BiometricRawDT
	} 
	
	port def UserIPT { 
		flow in UserDT
	} 
	port def UserOPT { 
		flow out UserDT
	} 
	
	port def BooleanIPT { 
		flow in Boolean
	} 
	port def BooleanOPT { 
		flow out Boolean
	} 
	
	port def SensorIPT { 
		ports : 
			biometricType : BiometricRawOPT ; 
			biometriRaw : BiometricTypeIPT ;
	} 
	
	port def StringIPT { 
		flow in String
	} 
	port def StringOPT { 
		flow out String
	}
	
	port def IntIPT { 
		flow in Int
	} 
	port def IntOPT { 
		flow out Int
	} 
	
	port def OrderIPT { 
		flow in OrderDT
	} 
	port def OrderOPT { 
		flow out OrderDT
	} 
	
	port def OrderProcessingIPT { 
		flow in OrderProcessingDT
	} 
	port def OrderProcessingOPT { 
		flow out OrderProcessingDT
	} 
	
	port def OrderItemArrayIPT { 
		flow in OrderItemArrayDT
	} 
	port def OrderItemArrayOPT { 
		flow out OrderItemArrayDT
	} 
	
	port def RealIPT { 
		flow in Real
	} 
	port def RealOPT { 
		flow out Real
	} 
	
	port def OrderChargeIPT { 
		flow in OrderChargeDT
	} 
	port def OrderChargeOPT { 
		flow out OrderChargeDT
	} 
	
	port def PaymentStatusIPT { 
		flow in PaymentStatusEnum
	} 
	port def PaymentStatusOPT { 
		flow out PaymentStatusEnum
	} 
	
	port def DispenserProductIPT { 
		flow in DispenserProductDT
	} 
	port def DispenserProductOPT { 
		flow out DispenserProductDT
	} 
	
	port def CompartmentCMDIPT { 
		flow in CompartmentCMDEnum
	} 
	port def CompartmentCMDOPT { 
		flow out CompartmentCMDEnum
	} 
	
	port def PickupOrderAddedIPT { 
		flow in PickupOrderAddedDT
	} 
	port def PickupOrderAddedOPT { 
		flow out PickupOrderAddedDT
	} 
} 

Requirement ManageUsersFR ( 1 ) { 
	text = "\"O sistema deve permitir o gerenciamento de usurios.\""
	
	Requirement UpdateUserFR ( 1.2 ) { 
		text = "O sistema deve permitir que o usurio atualize a conta no sistema com todos os dados necessrios." 
		Requirement RegisterPaymentMethodsFR_ForUpdate ( 1.2.2 ) { 
			text = "O sistema deve permitir que o usurio atualize seus mtodos de pagamento." 
			satisfied by FoodFastComponents.CreatePaymentMethodsCP ; 
		} 
		
		Requirement RegisterPersonalInfoFR_ForUpdate ( 1.2.1 ) { 
			text = "O sistema deve permitir que o usurio atualize suas informaes pessoais."
			satisfied by FoodFastComponents.CreatePersonalInfoCP ; 
		}
	}
	
	Requirement RegisterUserFR ( 1.1 ) { 
		text = "O sistema deve permitir que o usurio realize o cadastro no sistema com todos os dados necessrios." 
		Requirement RegisterPersonalInfoFR_ForRegister ( 1.1.1 ) { 
			text = "O sistema deve permitir que o usurio cadastre suas informaes pessoais." 
			satisfied by FoodFastComponents.UpdatePersonalInfoCP ; 
		} 
		
		Requirement RegisterPaymentMethodsFR_ForRegister ( 1.1.2 ) { 
			text = "O sistema deve permitir que o usurio cadastre seus mtodos de pagamento." 
			satisfied by FoodFastComponents.UpdatePaymentMethodsCP ; 
		}
	}
	
	Requirement RetrieveUserFR ( 1.3 ) { 
		text = "O sistema deve permitir que o usurio visualize suas informaes cadastradas."
		satisfied by FoodFastComponents.UserRetrieveCP ; 
	} 
	
	Requirement DeleteUserFR ( 1.4 ) { 
		text = "O sistema deve permitir que o usurio remova sua conta."
		satisfied by FoodFastComponents.UserDeleteCP ; 
	} 

	Requirement LoginUserFR ( 1.5 ) { 
		text = "\"O sistema deve permitir que o usurio se autentique em sua conta com CPF e senha registrados.\""
		satisfied by FoodFastComponents.UserAuthCP ; 
	} 
} 

 
Requirement ManageBiometricDataFR ( 2 ) { 
	text = "\"O sistema deve permitir o gerenciamento dos dados biomtricos dos usurios.\"" 
	
	Requirement RegisterBiometricDataFR ( 2.1 ) { 
		text = "\"O sistema deve permitir que o usurio registre seus dados biomtricos no sistema.\""
		satisfied by FoodFastComponents.RegisterBiometricCP ; 
	} 
	
	Requirement RemoveBiometricDataFR ( 2.2 ) { 
		text = "\"O sistema deve permitir que o usurio remova seus dados biomtricos cadastrados no sistema.\""
		satisfied by FoodFastComponents.RemoveBiometricCP ; 
	}
} 

 
Requirement FingerprintAuthenticationFR ( 3.1 ) {
	text = "\"O sistema deve permitir que o usurio realize autenticao utilizando sua impresso digital.\"" 
	derive OrderManagementFR.CreateOrderInMachineFR.AuthenticateBiometricFR ; 
	
	Requirement CaptureFingerprintFR ( 3.1.1 ) { 
		text = "\"O sistema deve capturar a impresso digital do usurio utilizando o sensor biomtrico apropriado.\""
		satisfied by FoodFastComponents.FingerprintSensorCP ; 
	} 
	
	Requirement RecognizeFingerprintFR ( 3.1.2 ) { 
		text = "\"O sistema deve comparar a digital capturada com os dados biomtricos registrados para validar a identidade do usurio.\""
		satisfied by FoodFastComponents.BiometricRecognitionCP ; 
	}
} 

Requirement FacialAuthenticationFR ( 3.2 ) { 
	text = "\"O sistema deve permitir que o usurio realize autenticao utilizando reconhecimento facial.\"" 
	derive OrderManagementFR.CreateOrderInMachineFR.AuthenticateBiometricFR ;
	
	Requirement CaptureFaceFR ( 3.2.1 ) { 
		text = "\"O sistema deve capturar a imagem facial do usurio utilizando a cmera disponibilizada pelo dispositivo.\""
		satisfied by FoodFastComponents.FaceCameraCP ; 
	} 
	
	Requirement RecognizeFaceFR ( 3.2.2 ) { 
		text = "\"O sistema deve comparar a imagem facial capturada com os dados biomtricos registrados para validar a identidade do usurio.\""
		satisfied by FoodFastComponents.BiometricRecognitionCP ;
	}
}

Requirement OrderManagementFR ( 4 ) { 
	text = "\"O sistema deve permitir o gerenciamento completo dos pedidos realizados pelos usurios.\"" 
	
	Requirement UpdateOrderFR ( 4.3 ) { 
		text = "\"O sistema deve permitir que funcionrios ou subsistemas responsveis atualizem pedidos em processamento.\""
		satisfied by FoodFastComponents.UpdateOrderCP ; 
	}
	
	Requirement ViewOrderFR ( 4.2 ) { 
		text = "\"O sistema deve permitir que o usurio visualize seus pedidos.\""
		satisfied by FoodFastComponents.RetrieveOrderCP ; 
	} 
	
	Requirement CreateOrderInMachineFR ( 4.1 ) { 
		text = "\"O sistema deve permitir que o usurio crie pedidos em mquinas apropriadas, realizando o clculo do valor devido conforme os itens selecionados.\"" 
		satisfied by FoodFastComponents.CreateOrderCP ; 
		
		Requirement AuthenticateBiometricFR ( 3 ) { 
			text = "\"O sistema deve permitir que o usurio realize autenticao por biometria.\""
			derive OrderPickupFR.IdentifyUserForPickupFR.IdentifyPickupRequestFR ; 
		} 
	} 
	
	Requirement ProcessOrderFR ( 4.4 ) { 
		text = "\"O sistema deve processar pedidos conforme o tipo de mquina e o fluxo operacional necessrio.\"" 
		
		Requirement ChargeOrderFR ( 4.4.1 ) { 
			text = "\"O sistema deve realizar a cobrana do pedido conforme o fluxo operacional da mquina utilizada, podendo ocorrer antes ou depois do uso, conforme as regras do tipo de pedido.\""
			satisfied by FoodFastComponents.PaymentProcessingCP ; 
		} 
		
		Requirement CheckPendingPaymentsFR ( 4.4.2 ) { 
			text = "\"O sistema deve verificar se o usurio possui valores pendentes de pedidos anteriores que ainda no foram pagos, bloqueando a continuidade do processamento caso existam pendncias.\""
			satisfied by FoodFastComponents.CheckDebtsCP ; 
		} 
		
		Requirement MachineSpecificProcessingFR ( 4.4.3 ) {
			text = "\"O sistema deve executar o processamento adicional especfico ao tipo de mquina na qual o pedido foi realizado.\""
		}
	} 
} 

Requirement CreateOrderInTotemFR ( 4.1.1 ) { 
	text = "\"O sistema deve permitir que o usurio realize pedidos em totens, selecionando itens que sero preparados na cozinha.\"" 
	satisfied by FoodFastComponents.TotemCP ; 
	derive OrderManagementFR.CreateOrderInMachineFR ; 
	
	Requirement CheckItemAvailabilityFR ( 4.1.1.1 ) { 
		text = "\"O sistema deve verificar a disponibilidade dos itens selecionados antes de confirmar o pedido.\""
	} 
	
	Requirement GenerateOrderReceiptFR ( 4.1.1.2 ) { 
		text = "\"O sistema deve gerar a nota de compra contendo o nmero do pedido, a cozinha de roteamento e o cdigo de barras para retirada.\""
		satisfied by FoodFastComponents.ReceiptPrinterCP ; 
	} 
	
	Requirement ChargeBeforeConfirmationFR ( 4.1.1.3 ) { 
		text = "\"O sistema deve realizar a cobrana do pedido antes da confirmao final.\""
	}
} 

Requirement ProcessOrderFromTotemFR ( 4.4.3.1 ) { 
	text = "\"O sistema deve processar pedidos realizados em totens, encaminhando-os para a cozinha adequada aps a cobrana.\"" 
	derive OrderManagementFR.ProcessOrderFR.MachineSpecificProcessingFR ; 
	
	Requirement RouteOrderToKitchenFR ( 4.4.3.1.1 ) { 
		text = "\"O sistema deve encaminhar o pedido para a cozinha apropriada conforme sua categoria.\""
		satisfied by FoodFastComponents.KitchenRoutingCP ; 
	}
}

Requirement ProcessOrderFromDrinkDispenserFR ( 4.4.3.2 ) { 
	text = "\"O sistema deve processar pedidos realizados em mquinas de bebidas prontas, liberando a bebida aps a confirmao da cobrana.\"" 
	derive OrderManagementFR.ProcessOrderFR.MachineSpecificProcessingFR ;
} 

Requirement ProcessOrderFromSnackDispenserFR ( 4.4.3.3 ) { 
	text = "\"O sistema deve processar pedidos realizados em mquinas de lanches prontos, liberando o lanche aps a confirmao da cobrana.\"" 
	derive OrderManagementFR.ProcessOrderFR.MachineSpecificProcessingFR ;
} 

Requirement ProcessOrderFromTapFR ( 4.4.3.4 ) { 
	text = "\"O sistema deve processar pedidos realizados em torneiras de bebidas cobradas por volume, finalizando o clculo e cobrana aps o uso.\"" 
	derive OrderManagementFR.ProcessOrderFR.MachineSpecificProcessingFR ; 
	
	Requirement CalculateFinalTapCostFR ( 4.4.3.4.1 ) { 
		text = "\"O sistema deve calcular o custo final do pedido com base no volume total de bebida consumido.\""
		satisfied by FoodFastComponents.PriceCalculationCP ; 
	}
} 

Requirement CreateOrderInDrinkDispenserFR ( 4.1.2 ) { 
	text = "\"O sistema deve permitir que o usurio realize pedidos em mquinas de bebidas prontas (dispenser).\"" 
	satisfied by FoodFastComponents.DispenserDrinkMachineCP ; 
	derive OrderManagementFR.CreateOrderInMachineFR ; 
	
	Requirement CheckDrinkAvailabilityFR ( 4.1.2.1 ) { 
		text = "\"O sistema deve verificar a disponibilidade da bebida selecionada antes de permitir a confirmao.\""
	} 
	
	Requirement ChargeBeforeConfirmationFR ( 4.1.2.2 ) { 
		text = "\"O sistema deve realizar a cobrana do pedido antes da liberao da bebida.\""
	}
} 

Requirement CreateOrderInSnackDispenserFR ( 4.1.3 ) { 
	text = "\"O sistema deve permitir que o usurio realize pedidos em mquinas de lanches prontos.\"" 
	satisfied by FoodFastComponents.DispenserSnackMachineCP ; 
	derive OrderManagementFR.CreateOrderInMachineFR ; 
	
	Requirement CheckSnackAvailabilityFR ( 4.1.3.1 ) { 
		text = "\"O sistema deve verificar a disponibilidade do lanche selecionado antes de permitir a confirmao.\""
	} 
	
	Requirement ChargeBeforeConfirmationFR ( 4.1.3.2 ) { 
		text = "\"O sistema deve realizar a cobrana do pedido antes da liberao do lanche.\""
	}
} 

Requirement CreateOrderInTapFR ( 4.1.4 ) { 
	text = "\"O sistema deve permitir que o usurio realize pedidos em torneiras de bebidas cobradas por volume consumido.\"" 
	satisfied by FoodFastComponents.TapMachineCP ; 
	derive OrderManagementFR.CreateOrderInMachineFR ; 
	
	Requirement CheckTapAvailabilityFR ( 4.1.4.1 ) { 
		text = "\"O sistema deve verificar a disponibilidade da bebida na torneira antes ou durante o uso, conforme necessrio.\""
	} 
	
	Requirement MeasureDispensedVolumeFR ( 4.1.4.2 ) { 
		text = "\"O sistema deve medir o volume de bebida dispensado, em mililitros, durante o uso.\""
		satisfied by FoodFastComponents.TapActuatorCP ; 
	} 
	
	Requirement PostUseChargeFR ( 4.1.4.3 ) { 
		text = "\"O sistema deve realizar a cobrana do pedido somente aps o trmino do uso.\""
	}
} 

Requirement OrderPickupFR ( 5 ) { 
	text = "O sistema deve gerenciar todo o processo de retirada de pedidos utilizando a esteira automatizada, garantindo identificao segura do usurio, acesso controlado aos compartimentos e rastreabilidade completa do pedido." 
	
	Requirement ManageConveyorFR ( 5.1 ) { 
		text = "O sistema deve gerenciar a esteira automatizada, organizando compartimentos, exibindo pedidos disponveis e controlando o fluxo de entrega." 
		
		Requirement SeparateConveyorCompartmentsFR ( 5.1.1 ) { 
			text = "O sistema deve organizar a esteira em compartimentos individuais para armazenamento dos pedidos prontos."
			satisfied by FoodFastComponents.CompartmentActuatorCP ; 
		} 
		
		Requirement DisplayPickupOrdersFR ( 5.1.2 ) { 
			text = "O sistema deve exibir na interface da esteira todos os pedidos disponveis, pendentes ou em preparao relacionados ao ponto de retirada."
			satisfied by FoodFastComponents.PickupDisplayCP ; 
		} 
		
		Requirement UpdatePickupOrderStatusFR ( 5.1.3 ) { 
			text = "O sistema deve atualizar automaticamente o status do pedido de acordo com o fluxo da esteira e permitir ajustes pelos funcionrios."
		}
	} 
	
	Requirement IdentifyUserForPickupFR ( 5.2 ) { 
		text = "O sistema deve identificar qual pedido pertence ao usurio no ponto de retirada, utilizando mecanismos de autenticao biomtrica ou cdigo de barras." 
		
		Requirement IdentifyPickupRequestFR ( 5.2.1 ) { 
			text = "O sistema deve identificar o pedido associado ao usurio por meio de autenticao informada, como biometria ou cdigo de barras."
		} 
		
		Requirement VerifyPickupRequestFR ( 5.2.2 ) { 
			text = "O sistema deve verificar se o identificador obtido corresponde a um pedido disponvel e autorizado para retirada."
		}
	}
	
	Requirement LocatePickupOrderFR ( 5.3 ) { 
		text = "O sistema deve localizar o compartimento onde o pedido identificado est armazenado."
	} 
	
	Requirement ProcessConveyorDeliveryFR ( 5.4 ) {
		text = "O sistema deve executar as aes necessrias para entregar o pedido ao usurio, incluindo mover a esteira e abrir automaticamente o compartimento correspondente." 
		
		Requirement MoveConveyorToUserFR ( 5.4.1 ) { 
			text = "O sistema deve mover a esteira at que o compartimento do pedido esteja posicionado em frente ao usurio identificado."
			satisfied by FoodFastComponents.PickupConveyorCP ; 
		} 
		
		Requirement OpenConveyorCompartmentFR ( 5.4.2 ) { 
			text = "O sistema deve abrir automaticamente o compartimento correspondente ao pedido aps a identificao vlida do usurio."
			satisfied by FoodFastComponents.CompartmentActuatorCP ; 
		} 
		
		Requirement ConfirmOrderPickupFR ( 5.4.3 ) { 
			text = "O sistema deve detectar quando o pedido foi retirado e registrar a concluso da entrega."
		}
	} 
} 

Requirement IdentifyPickupByBarcodeFR ( 5.2.1.1 ) { 
	text = "O sistema deve identificar o pedido do usurio utilizando o cdigo de barras fornecido no momento da retirada." 
	satisfied by FoodFastComponents.BarcodeReaderCP ; 
	derive OrderPickupFR.IdentifyUserForPickupFR.IdentifyPickupRequestFR ; 
	
	Requirement CapturePickupBarcodeFR ( 5.2.1.1.1 ) { 
		text = "O sistema deve capturar o cdigo de barras apresentado pelo usurio no ponto de retirada."
	} 
	
	Requirement InterpretPickupBarcodeFR ( 5.2.1.1.2 ) { 
		text = "O sistema deve interpretar o cdigo de barras capturado e extrair o identificador do pedido associado ao usurio."
	}
}

Requirement QualityNFR ( 6 ) { 
	text = "O sistema deve atender requisitos robustos de segurana, desempenho, disponibilidade, usabilidade, escalabilidade e manutenibilidade, com nveis mensurveis definidos nos NFRs relacionados." 
	
	Requirement SecurityNFR ( 6.1 ) { 
		text = "O sistema deve implementar mecanismos de segurana que previnam acesso no autorizado, garantam criptografia dos dados sensveis e minimizem riscos de fraude e erros de identificao." 
		
		Requirement DataSecurityNFR ( 6.1.1 ) { 
			text = "Todos os dados sensveis dos usurios, incluindo informaes de pagamento, devem ser armazenados e transmitidos utilizando criptografia forte (mnimo AES-256 ou equivalente)."
		} 
		
		Requirement FraudSecurityNFR ( 6.1.2 ) { 
			text = "O sistema deve detectar e bloquear tentativas suspeitas de fraude durante os processos de autenticao e pagamento, registrando eventos para auditoria."
		} 
		
		Requirement RecognitionSecurityNFR ( 6.1.3 ) { 
			text = "Os mtodos de reconhecimento biomtrico devem manter preciso elevada, minimizando falsos positivos e falsos negativos conforme mtricas aceitas (FAR < 0.01%, FRR < 1%)."
		}
	} 
	
	Requirement PerformanceNFR ( 6.2 ) { 
		text = "O sistema deve realizar processamento de dados e atender requisies dentro dos tempos mximos especificados nos NFRs derivados." 
		
		Requirement RecognitionTimeNFR ( 6.2.1 ) { 
			text = "O reconhecimento facial ou digital deve ser concludo em at 3 segundos, considerando captura + processamento."
		} 
		
		Requirement PaymentTimeNFR ( 6.2.2 ) {
			text = "O sistema deve processar transaes de pagamento com tempo de resposta inferior a 5 segundos para cada requisio."
		}
	} 
	
	Requirement AvailableNFR ( 6.3 ) { 
		text = "O sistema deve manter disponibilidade mnima de 99,9% ao longo do ano, incluindo totens, mquinas de pedido e esteiras automatizadas." 
		
		Requirement MachineMonitoringNFR ( 6.3.1 ) { 
			text = "Totens, mquinas e mdulos de esteira devem ser monitorados constantemente para garantir que permaneam operacionais, com alertas automticos em caso de falhas."
		}
	} 
	
	Requirement UsabilityNFR ( 6.4 ) { 
		text = "O sistema deve ser intuitivo e fcil de usar para pblicos de diferentes idades e perfis, reduzindo a necessidade de interveno humana." 
		
		Requirement AccessibilityNFR ( 6.4.1 ) {
			text = "Os recursos do sistema devem ser acessveis a usurios com deficincias auditivas, visuais, motoras ou cognitivas, seguindo diretrizes WCAG 2.1 AA." 
		} 
		
		Requirement ResponsivenessNFR ( 6.4.2 ) { 
			text = "As interfaces do sistema devem ser responsivas e adaptveis a diferentes tamanhos e orientaes de tela, garantindo boa usabilidade em totens, dispositivos mveis e desktops."
		}
	} 
	
	Requirement ScalabilityNFR ( 6.5 ) { 
		text = "O sistema deve suportar aumento de carga, expanso de dispositivos e adio de novas mquinas sem necessidade de alteraes estruturais significativas."
	} 
	
	Requirement MaintainabilityNFR ( 6.6 ) { 
		text = "O sistema deve possuir processos bem definidos de atualizao, registro de erros e manuteno corretiva, permitindo intervenes rpidas sem comprometer a operao."
	}
} 

Requirement CompatibilityNFR ( 6.4.2.1 ) { 
	text = "O sistema deve ser compatvel com navegadores modernos e sistemas operacionais mveis (iOS e Android)." 
	derive QualityNFR.UsabilityNFR.ResponsivenessNFR ;
} 

Requirement ProductManagementFR ( 7 ) { 
	text = "\"O sistema deve oferecer um conjunto integrado de funcionalidades para cadastrar, atualizar, consultar e remover produtos, alm de permitir a verificao de disponibilidade conforme necessrio para operao das mquinas.\"" 
	
	Requirement CreateProductFR ( 7.1 ) { 
		text = "\"O sistema deve permitir o cadastro de um novo produto contendo nome, descrio, categoria e preo, garantindo a persistncia das informaes.\""
		satisfied by FoodFastComponents.CreateProductCP ; 
	} 
	
	Requirement UpdateProductFR ( 7.2 ) { 
		text = "\"O sistema deve permitir a modificao dos dados de um produto previamente cadastrado, mantendo histrico consistente no banco de dados.\""
		satisfied by FoodFastComponents.UpdateProductCP ; 
	} 
	
	Requirement RetrieveProductFR ( 7.3 ) { 
		text = "\"O sistema deve permitir a consulta de produtos individualmente ou em conjunto, retornando informaes essenciais como nome, descrio, categoria, preo e disponibilidade quando aplicvel.\""
		satisfied by FoodFastComponents.RetrieveProductCP ; 
	} 
	
	Requirement DeleteProductFR ( 7.4 ) { 
		text = "\"O sistema deve permitir a remoo de um produto do catlogo, garantindo que os dados sejam excludos de forma consistente.\""
		satisfied by FoodFastComponents.DeleteProductCP ; 
	} 
	
	Requirement CheckProductAvailabilityFR ( 7.5 ) { 
		text = "\"O sistema deve permitir a verificao da disponibilidade de um produto, considerando informaes provenientes de estoque interno ou processamento em mquinas especficas.\""
		satisfied by FoodFastComponents.GetMachineStockCP ; 
	}
}