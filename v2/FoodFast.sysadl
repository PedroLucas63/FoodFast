Model SysADLModel ;

package SysADLTypes {
	value type Int { } 
	value type Boolean { } 
	value type String { } 
	value type Void { } 
	value type Real { } 
	
	dimension Time 
	
	unit Second { 
		dimension = Time
	} 
	unit Millisecond { 
		dimension = Time
	}
	unit Minute { 
		dimension = Time
	} 
	unit Hour { 
		dimension = Time
	} 
	
	dimension Date 
	
	unit Day { 
		dimension = Date
	} 
	unit Month { 
		dimension = Date
	} 
	unit Year { 
		dimension = Date
	} 
	
	value type MillisecondsVT { 
		unit = Millisecond 
		dimension = Time
	} 
	value type SecondsVT { 
		unit = Second 
		dimension = Time
	} 
	value type MinutesVT { 
		unit = Minute 
		dimension = Time
	} 
	value type HoursVT { 
		unit = Hour 
		dimension = Time
	} 
	
	value type DaysVT { 
		unit = Day 
		dimension = Date
	} 
	value type MonthsVT { 
		unit = Month 
		dimension = Date
	} 
	value type YearsVT { 
		unit = Year 
		dimension = Date
	} 
	
	datatype TimestampDT { 
		attributes : ^value : MillisecondsVT ;
	} 
	datatype DateDT { 
		attributes : 
			day : DaysVT ;
			month : MonthsVT ; 
			year : YearsVT ;
	} 
	datatype TimeDT { 
		attributes : 
			hour : HoursVT ; 
			minute : MinutesVT ; 
			second : SecondsVT ;
	} 
	datatype DateTimeDT { 
		attributes : 
			date : DateDT ; 
			time : TimeDT ;
	} 
	
	datatype DBQueryDT { 
		attributes : 
			operation : DBOperationEnum ; 
			target : String ; 
			content : String ;
	} 
	enum DBOperationEnum { 
		INSERT , 
		UPDATE , 
		DELETE , 
		SELECT
	} 
	datatype DBResponseDT { 
		attributes : 
			success : Boolean ; 
			content : String ; 
			error : String ;
	} 
	
	datatype HTTPHeaderDT { 
		attributes : 
			key : String ; 
			^value : String ;
	} 
	enum HTTPMethodEnum { 
		GET , 
		POST , 
		PUT , 
		DELETE , 
		PATCH
	} 
	datatype HTTPBodyDT { 
		attributes : 
			content : String ;
	} 
	
	datatype HTTPRequestDT { 
		attributes : 
			method : HTTPMethodEnum ; 
			path : String ; 
			header : HTTPHeaderDT ; 
			^body : HTTPBodyDT ;
	} 
	datatype HTTPResponseDT { 
		attributes : 
			statusCode : Int ; 
			header : HTTPHeaderDT ; 
			^body : HTTPBodyDT ;
	} 
	
	enum BiometricTypeEnum { 
		FINGERPRINT , 
		FACE , 
		BARCODE
	} 
	
	datatype UserDT { 
		attributes : 
			name : String ; 
			cpf : String ; 
			email : String ; 
			birthdate : DateDT ; 
			phone : String ;
	id : Int ; } 
	
	datatype BiometricRawDT { 
		attributes : 
			^type : BiometricTypeEnum ; 
			data : String ;
	} 
	
	enum ProductCategoryEnum { 
		SNACK , 
		DRINK_PACKAGED , 
		DRINK_TAP , 
		MEAL
	} 
	
	datatype ProductDT { 
		attributes : 
			id : Int ; 
			name : String ; 
			description : String ; 
			category : ProductCategoryEnum ; 
			price : Real ;
	} 
	
	datatype ProductArrayDT { }
	 
	datatype StockInfoDT {
		attributes : 
			productId : Int ; 
			quantity : Int ; 
			lastUpdate : DateTimeDT ;
	} 
	
	enum MachineTypeEnum { 
		TOTEM , 
		DISPENSER , 
		TAP
	} 
	
	enum PaymentStatusEnum {
		PENDING , 
		AUTHORIZED , 
		CANCELED
	} 
	
	enum OrderStatusEnum { 
		CREATED , 
		PROCESSING , 
		READY , 
		FINISHED, 
		CANCELED
	} 
	
	datatype OrderItemDT { 
		attributes : 
			productId : Int ;
		 	quantity : Int ; 
		 	unitPrice : Real ;
	} 
	
	datatype OrderDT { 
		attributes : 
			orderId : Int ; 
			customerId : Int ; 
			createdAt : DateTimeDT ; 
			updatedAt : DateTimeDT ; 
			machineType : MachineTypeEnum ; 
			paymentStatus : PaymentStatusEnum ; 
			orderStatus : OrderStatusEnum ; 
			items : OrderItemArrayDT ;
	kitchenId : Int ; } 
	
	datatype OrderItemArrayDT { } 
datatype OrderProcessingDT { attributes : finalPrice : Real ; kitchenId : Int ; } datatype OrderChargeDT { attributes : customerId : Int ; ^value : Real ; } }

package FoodFastConnectors { 
	import FoodFastPorts ;
	
	connector def DBQueryCN { 
		participants : 
			~ destination : DBQueryIPT ; 
			~ source : DBQueryOPT ; 
		flows : 
			DBQueryDT from source to destination
	} 
	
	connector def DBResponseCN { 
		participants : 
			~ destination : DBResponseIPT ; 
			~ source : DBResponseOPT ; 
		flows : 
			DBResponseDT from source to destination
	} 
	
	connector def DatabaseCN { 
		participants : 
			~ service : DBServiceP ; 
			~ client : DBClientP ; 
		configuration { 
			connectors : 
				response : DBResponseCN bindings responseOPT = responseIPT ; 
				query : DBQueryCN bindings queryOPT = queryIPT ;
		}
	} 
	
	connector def HTTPRequestCN { 
		participants : 
			~ source : HTTPRequestOPT ; 
			~ destination : HTTPRequestIPT ; 
		flows : 
			HTTPRequestDT from source to destination
	} 
	connector def HTTPResponseCN { 
		participants : 
			~ destination : HTTPResponseIPT ; 
			~ source : HTTPResponseOPT ; 
		flows : 
			HTTPResponseDT from source to destination
	} 
	
	connector def HTTPCN { 
		participants : 
			~ service : HTTPServiceP ; 
			~ client : HTTPClientP ; 
			
			configuration { 
				connectors : 
					response : HTTPResponseCN bindings responseOPT = responseIPT ; 
					request : HTTPRequestCN bindings requestOPT = requestIPT ;
			}
	} 
	
	connector def BiometricTypeCN { 
		participants : 
			~ destination : BiometricTypeIPT ; 
			~ source : BiometricTypeOPT ; 
		flows : 
			BiometricTypeEnum from source to destination
	} 
	
	connector def BiometricRawCN { 
		participants : 
			~ destination : BiometricRawIPT ;
			~ source : BiometricRawOPT ; 
		flows : 
			BiometricRawDT from source to destination
	} 
	
	connector def UserCN { 
		participants : 
			~ destination : UserIPT ; 
			~ source : UserOPT ; 
		flows : 
			UserDT from source to destination
	} 
	
	connector def BooleanCN { 
		participants : 
			~ destination : BooleanIPT ; 
			~ source : BooleanOPT ; 
		flows : 
			Boolean from source to destination
	} 
	
	connector def SensorCN { 
		participants : 
			~ client : HTTPClientP ; 
			~ server : SensorCN ; 
			
			configuration { 
				connectors : 
					httpToBiometricType : HTTPToBiometricTypeCN bindings requestOPT = biometricType ; 
					biometricRawToHTTP : BiometricRawToHTTPCN bindings biometriRaw = responseIPT ;
			}
	} 
	
	connector def HTTPToBiometricTypeCN { 
		participants : 
			~ source : HTTPRequestOPT ; 
			~ destination : BiometricTypeIPT ; 
			
		flows : 
			HTTPRequestDT from source to destination
	} 
	
	connector def BiometricRawToHTTPCN { 
		participants : 
			~ source : BiometricRawOPT ; 
			~ destination : HTTPResponseIPT ; 
			
		flows : 
			BiometricRawDT from source to destination
	} 
	
	connector def StringCN { 
		participants : 
			~ destination : StringIPT ; 
			~ source : StringOPT ; 
		
		flows : 
			String from source to destination
	} 
connector def IntCN { participants : ~ destination : IntIPT ; ~ source : IntOPT ; flows : Int from source to destination } connector def OrderCN { participants : ~ destination : OrderIPT ; ~ source : OrderOPT ; flows : OrderDT from source to destination } connector def OrderProcessingCN { participants : ~ destination : OrderProcessingIPT ; ~ source : OrderProcessingOPT ; flows : OrderProcessingDT from source to destination } connector def OrderItemArrayCN { participants : ~ destination : OrderItemArrayIPT ; ~ source : OrderItemArrayOPT ; flows : OrderItemArrayDT from source to destination } connector def RealCN { participants : ~ source : RealOPT ; ~ destination : RealIPT ; flows : Real from source to destination } connector def OrderChargeCN { participants : ~ destination : OrderChargeIPT ; ~ source : OrderChargeOPT ; flows : OrderChargeDT from source to destination } connector def PaymentStatusCN { participants : ~ destination : PaymentStatusIPT ; ~ source : PaymentStatusOPT ; flows : PaymentStatusEnum from source to destination } }

package FoodFastComponents { 
	import FoodFastConnectors ; 
	import FoodFastPorts ; 
	import SysADLTypes ;
	
	component def FoodFastARCH { 
		configuration { 
			components : 
				DatabaseCP : DatabaseCP { 
					using ports : 
						dbServiceP : DBServiceP ;
				} 
				
				UserServerCP : UserServerCP { 
					using ports : 
						dbClient_User : DBClientP ; 
						httpServer_User : HTTPServiceP ;
				} 
				
				FrontendCP : FrontendCP { 
					using ports : 
						httpClient_Frontend : HTTPClientP ;
				} 
				
				BiometricServerCP : BiometricServerCP { 
					using ports : 
						httpServer_Biometric : HTTPServiceP ; 
						dbClient_Biometric : DBClientP ;
				} 
				
				RegisterBiometricTotenCP : RegisterBiometricTotemCP { 
					using ports : 
						httpClient_BiometricToten : HTTPClientP ;
				} 
				
				AdminFrontendCP : AdminFrontendCP { 
					using ports : 
						httpClient_AdminFrontend : HTTPClientP ;
				} 
				
				ProductServerCP : ProductServerCP { 
					using ports : 
						httpServer_Product_private : HTTPServiceP ; 
						httpServer_Product_public : HTTPServiceP ; 
						dbClient_Product : DBClientP ;
				} 
				
			OrderServerCP : OrderServerCP { 
				using ports : 
					httpServer_Order_private : HTTPServiceP ; 
					httpServer_Order_public : HTTPServiceP ; 
					dbClient_Order : DBClientP ;
			} 
			
			connectors : 
				DB_UserServer : DatabaseCN bindings dbClient_User = dbServiceP ; 
				DB_BiometricServer : DatabaseCN bindings dbClient_Biometric = dbServiceP ; 
				Front_UserServer : HTTPCN bindings httpClient_Frontend = httpServer_User ; 
				Toten_BiometricServer : HTTPCN bindings httpClient_BiometricToten = httpServer_Biometric ; 
				DB_ProductServer : DatabaseCN bindings dbClient_Product = dbServiceP ; 
				FrontAdmin_ProductServer : HTTPCN bindings httpClient_AdminFrontend = httpServer_Product_private ; 
				DB_OrderServer : DatabaseCN bindings dbClient_Order = dbServiceP ; 
				Front_OrderServer : HTTPCN bindings httpClient_Frontend = httpServer_Order_public ; 
		}
	} 
	
	boundary component def DatabaseCP { 
		ports : 
			dbServiceP : DBServiceP [ 1 , 2 ] ;
	}
	
	component def UserServerCP { 
		ports : 
			dbClient_User : DBClientP ; 
			httpServer_User : HTTPServiceP ; 
			
			configuration { 
				components : 
					UserAuthCP : UserAuthCP { 
						using ports : 
							httpServer_UserAuth : HTTPServiceP ; 
							dbClient_UserAuth : DBClientP ;
					} 
					
					UserCreateCP : UserCreateCP { 
						using ports : 
							httpServer_UserCreate : HTTPServiceP ; 
							dbClient_UserCreate : DBClientP ;
					} 
					
					UserDeleteCP : UserDeleteCP { 
						using ports : 
							httpServer_UserDelete : HTTPServiceP ; 
							dbClient_UserDelete : DBClientP ;
					} 
					
					UserUpdateCP : UserUpdateCP { 
						using ports : httpServer_UserUpdate : HTTPServiceP ; 
						dbClient_UserUpdate : DBClientP ;
					} 
					
					UserRetrieveCP : UserRetrieveCP { 
						using ports : 
							httpServer_UserRetrieve : HTTPServiceP ; 
							dbClient_UserRetrieve : DBClientP ;
					} 
					
					delegations : 
						httpServer_UserAuth to httpServer_User
						httpServer_UserCreate to httpServer_User 
						httpServer_UserDelete to httpServer_User 
						httpServer_UserUpdate to httpServer_User 
						dbClient_UserUpdate to dbClient_User 
						dbClient_UserDelete to dbClient_User 
						dbClient_UserCreate to dbClient_User 
						dbClient_UserRetrieve to dbClient_User 
						httpServer_UserRetrieve to httpServer_User 
						dbClient_UserAuth to dbClient_User
			}
	}
	
	boundary component def UserCreateCP { 
		ports : 
			httpServer_UserCreate : HTTPServiceP ; 
			dbClient_UserCreate : DBClientP ;
	} 
	
	boundary component def UserUpdateCP { 
		ports : 
			httpServer_UserUpdate : HTTPServiceP ; 
			dbClient_UserUpdate : DBClientP ;
	} 
	
	boundary component def UserRetrieveCP { 
		ports : 
			httpServer_UserRetrieve : HTTPServiceP ; 
			dbClient_UserRetrieve : DBClientP ;
	} 
	
	boundary component def UserDeleteCP { 
		ports : 
			httpServer_UserDelete : HTTPServiceP ; 
			dbClient_UserDelete : DBClientP ; 
			
			port def DBResponseIPT { 
				flow in DBResponseDT
			}
	} 
	
	boundary component def UserAuthCP { 
		ports : 
			httpServer_UserAuth : HTTPServiceP ; 
			dbClient_UserAuth : DBClientP ;
	} 
	
	boundary component def FrontendCP { 
		ports : 
			httpClient_Frontend : HTTPClientP [ 1 , 2 ] ;
	} 
	
	boundary component def FingerprintSensorCP { 
		ports : 
			active_Fingerprint : BooleanIPT ; 
			biometricRaw_Fingerprint : BiometricRawOPT ;
	} 
	
	boundary component def FaceCameraCP { 
		ports : 
			active_Camera : BooleanIPT ; 
			biometricRaw_Camera : BiometricRawOPT ;
	} boundary
	component def RegisterBiometricCP { 
		ports : 
			dbClient_RegisterBiometric : DBClientP ; 
			httpService_RegisterBiometric : HTTPServiceP ;
	} boundary
	component def RemoveBiometricCP { 
		ports : 
			httpService_RemoveBiometric : HTTPServiceP ; 
			dbClient_RemoveBiometric : DBClientP ;
	} boundary
	component def BiometricRecognitionCP { 
		ports : 
			dbClient_BiometricRecognition : DBClientP ; 
			httpService_BiometricRecognition : HTTPServiceP ;
	}
	
	component def BiometricServerCP { 
		ports : 
			httpServer_Biometric : HTTPServiceP ; 
			dbClient_Biometric : DBClientP ; 
		configuration { 
			components : 
				BiometricRecognitionCP : BiometricRecognitionCP { 
					using ports : 
						dbClient_BiometricRecognition : DBClientP ; 
						httpService_BiometricRecognition : HTTPServiceP ;
				} 
				
				RegisterBiometricCP : RegisterBiometricCP { 
					using ports : 
						dbClient_RegisterBiometric : DBClientP ; 
						httpService_RegisterBiometric : HTTPServiceP ;
				} 
				
				RemoveBiometricCP : RemoveBiometricCP { 
					using ports : 
						httpService_RemoveBiometric : HTTPServiceP ; 
						dbClient_RemoveBiometric : DBClientP ;
				} 
				
				delegations : 
					httpService_BiometricRecognition to httpServer_Biometric
					httpService_RegisterBiometric to httpServer_Biometric
					httpService_RemoveBiometric to httpServer_Biometric
					dbClient_BiometricRecognition to dbClient_Biometric
					dbClient_RegisterBiometric to dbClient_Biometric
					dbClient_RemoveBiometric to dbClient_Biometric
		}
		
	}
	
	component def BiometricSensorsCP { 
		ports : 
			sensors_Component : SensorCN ; 
		 
		configuration { 
			components : 
				BiometricControllerCP : BiometricControllerCP { 
					using ports : 
						biometricRawIPT_Fingerprint : BiometricRawIPT ; 
						biometricRawIPT_Camera : BiometricRawIPT ; 
						sensorActive_Fingerprint : BooleanOPT ; 
						sensorActive_Camera : BooleanOPT ; 
						sensors_Controller : SensorCN ;
				} 
				
				FaceCameraCP : FaceCameraCP { 
					using ports : 
						active_Camera : BooleanIPT ; 
						biometricRaw_Camera : BiometricRawOPT ;
				} 
				
				FingerprintSensorCP : FingerprintSensorCP { 
					using ports : 
						active_Fingerprint : BooleanIPT ; 
						biometricRaw_Fingerprint : BiometricRawOPT ;
				} 
				
			connectors : 
				biometricRaw_Camera : BiometricRawCN bindings biometricRaw_Camera = biometricRawIPT_Fingerprint ; 
				activeCamera : BooleanCN bindings sensorActive_Fingerprint = active_Camera ; 
				biometricRaw_FingerPrint : BiometricRawCN bindings biometricRaw_Fingerprint = biometricRawIPT_Camera ; 
				activeFingerprint : BooleanCN bindings active_Fingerprint = sensorActive_Camera ; 
			delegations : 
				sensors_Controller to sensors_Component 
		}
	}
	
	component def BiometricControllerCP { 
		ports : 
			 
			biometricRawIPT_Fingerprint : BiometricRawIPT ; 
			biometricRawIPT_Camera : BiometricRawIPT ; 
			 
			sensorActive_Fingerprint : BooleanOPT ; 
			sensorActive_Camera : BooleanOPT ;
	sensors_Controller : SensorCN ; }
	
	component def RegisterBiometricTotemCP { 
		ports : 
			httpClient_BiometricTotem : HTTPClientP [ 1 , 2 ] ; 
		configuration { 
			components : 
				BiometricTotenProcessorCP : BiometricTotemProcessorCP { 
					using ports : 
						httpClient_BiometricTotenProcessor_external : HTTPClientP ; 
						httpClient_BiometricTotenProcessor_internal : HTTPClientP ; 
						cpfString_BiometricToten : StringIPT ;
				} 
				
				KeywordCP : KeywordCP { 
					using ports : keywordOutput : StringOPT ;
				} 
				
				BiometricSensorsCP : BiometricSensorsCP { 
					using ports : sensors_Component : SensorCN ;
				} 
			
			connectors : 
				cpfConnector : StringCN bindings keywordOutput = cpfString_BiometricToten ; 
				sensorData : SensorCN bindings httpClient_BiometricTotenProcessor_internal = sensors_Component ;
				
			delegations : 
				httpClient_BiometricTotenProcessor_external to httpClient_BiometricTotem }
	}
	
	component def ProductServerCP { 
		ports : 
			httpServer_Product_private : HTTPServiceP ; 
			httpServer_Product_public : HTTPServiceP ; 
			dbClient_Product : DBClientP ; 
		configuration { 
			components : 
				CreateProductCP : CreateProductCP { 
					using ports : 
						httpServer_CreateProduct : HTTPServiceP ; 
						dbClient_CreateProduct : DBClientP ;
				} 
				
				UpdateProductCP : UpdateProductCP { 
					using ports : 
						httpServer_UpdateProduct : HTTPServiceP ; 
						dbClient_UpdateProduct : DBClientP ;
				} 
				
				DeleteProductCP : DeleteProductCP { 
					using ports : 
						httpServer_DeleteProduct : HTTPServiceP ; 
						dbClient_DeleteProduct : DBClientP ;
				} 
				
				RetrieveProductCP : RetrieveProductCP { 
					using ports : 
						httpServer_RetrieveProduct : HTTPServiceP ; 
						dbClient_RetrieveProduct : DBClientP ;
				} 
				
				CheckAvailabilityProductCP : CheckAvailabilityProductCP { 
					using ports : 
						httpServer_CheckAvailabilityProduct : HTTPServiceP ; 
						dbClient_CheckAvailabilityProduct : DBClientP ;
				} 
			
			delegations : 
				httpServer_CreateProduct to httpServer_Product_private
				dbClient_CreateProduct to dbClient_Product
				httpServer_UpdateProduct to httpServer_Product_private
				dbClient_UpdateProduct to dbClient_Product
				httpServer_DeleteProduct to httpServer_Product_private
				dbClient_DeleteProduct to dbClient_Product
				httpServer_RetrieveProduct to httpServer_Product_private
				httpServer_RetrieveProduct to httpServer_Product_public
				dbClient_RetrieveProduct to dbClient_Product
				dbClient_CheckAvailabilityProduct to dbClient_Product
				httpServer_CheckAvailabilityProduct to httpServer_Product_private
				httpServer_CheckAvailabilityProduct to httpServer_Product_public
		}
	} 
	
	boundary component def AdminFrontendCP { 
		ports : httpClient_AdminFrontend : HTTPClientP ;
	} 
	
	boundary component def CreateProductCP { 
		ports : 
			httpServer_CreateProduct : HTTPServiceP ; 
			dbClient_CreateProduct : DBClientP ; 
	} 
	
	boundary component def UpdateProductCP { 
		ports : 
			httpServer_UpdateProduct : HTTPServiceP ; 
			dbClient_UpdateProduct : DBClientP ; 
	} 
	
	boundary component def DeleteProductCP { 
		ports : 
			httpServer_DeleteProduct : HTTPServiceP ; 
			dbClient_DeleteProduct : DBClientP ;
	} 
	
	boundary component def RetrieveProductCP { 
		ports : 
			httpServer_RetrieveProduct : HTTPServiceP ; 
			dbClient_RetrieveProduct : DBClientP ;
	}
	
	boundary component def CheckAvailabilityProductCP { 
		ports : 
			httpServer_CheckAvailabilityProduct : HTTPServiceP ; 
			dbClient_CheckAvailabilityProduct : DBClientP ;
	}
	
	component def BiometricTotemProcessorCP { 
		ports : 
			httpClient_BiometricTotemProcessor_external : HTTPClientP ; 
			httpClient_BiometricTotemProcessor_internal : HTTPClientP ; cpfString_BiometricTotem : StringIPT ;
	} 
	
	boundary component def KeywordCP { 
		ports : keywordOutput : StringOPT ;
	}
	
	component def OrderServerCP { 
		ports : 
			httpServer_Order_private : HTTPServiceP ; 
			httpServer_Order_public : HTTPServiceP ; 
			dbClient_Order : DBClientP ; 
		
		configuration { 
			components : 
				UpdateOrderCP : UpdateOrderCP { 
					using ports : 
						httpServer_UpdateOrder : HTTPServiceP ; 
						dbClient_UpdateOrder : DBClientP ;
				} 
				
				RetrieveOrderCP : RetrieveOrderCP { 
					using ports : 
						httpServer_RetrieveOrder : HTTPServiceP ; 
						dbClient_RetrieveOrder : DBClientP ;
				} 
			
			ProcessingOrderCP : ProcessingOrderCP { using ports : dbClient_ProcessingOrder : DBClientP ; httpServer_ProcessingOrder : HTTPServiceP ; } delegations : dbClient_UpdateOrder to dbClient_Order
				dbClient_RetrieveOrder to dbClient_Order 
				httpServer_RetrieveOrder to httpServer_Order_public 
				httpServer_UpdateOrder to httpServer_Order_private
		dbClient_ProcessingOrder to dbClient_Order httpServer_ProcessingOrder to httpServer_Order_private }
	} 
	
	boundary component def RetrieveOrderCP { 
		ports : 
			httpServer_RetrieveOrder : HTTPServiceP ; 
			dbClient_RetrieveOrder : DBClientP ;
	} 
	
	boundary component def UpdateOrderCP { 
		ports : 
			httpServer_UpdateOrder : HTTPServiceP ; 
			dbClient_UpdateOrder : DBClientP ;
	} 
boundary
	component def CheckDebtsCP { ports : userId_CheckDebts : IntIPT ; dbClient_CheckDebts : DBClientP ; hasDebts : BooleanOPT ; }
	component def ProcessingOrderCP { ports : dbClient_ProcessingOrder : DBClientP ; httpServer_ProcessingOrder : HTTPServiceP ; configuration { components : OrderProcessingCoordinatorCP : OrderProcessingCoordinatorCP { using ports : httpServer_ProcessingOrderCoordinator : HTTPServiceP ; userId_CheckDebts_Coordinator : IntOPT ; hasDebts_Coordinator : BooleanIPT ; dbClient_ProcessingOrderCoordinator : DBClientP ; order_OrderProcessingCoordinator : OrderOPT ; orderProcessing_OrderProcessingCoordinator : OrderProcessingIPT ; orderCharge_OrderProcessingCoordinator : OrderChargeOPT ; paymentResult_OrderProcessingCoordinator : PaymentStatusIPT ; } CheckDebtsCP : CheckDebtsCP { using ports : userId_CheckDebts : IntIPT ; dbClient_CheckDebts : DBClientP ; hasDebts : BooleanOPT ; } AdditionalProcessingCP : AdditionalProcessingCP { using ports : order_AdditionalProcessing : OrderIPT ; orderProcessing_AdditionalProcessing : OrderProcessingOPT ; } PaymentProcessingCP : PaymentProcessingCP { using ports : orderCharge_PaymentProcessing : OrderChargeIPT ; paymentResult_PaymentProcessing : PaymentStatusOPT ; dbClient_PaymentProcessig : DBClientP ; } connectors : hasDebtsCN : BooleanCN bindings hasDebts = hasDebts_Coordinator ; userIdCN : IntCN bindings userId_CheckDebts_Coordinator = userId_CheckDebts ; additionalProcessingResults : OrderProcessingCN bindings orderProcessing_AdditionalProcessing = orderProcessing_OrderProcessingCoordinator ; orderToAdditionalProcessing : OrderCN bindings order_OrderProcessingCoordinator = order_AdditionalProcessing ; paymentStatusResult : RealCN bindings paymentResult_PaymentProcessing = paymentResult_OrderProcessingCoordinator ; paymentRequest : OrderChargeCN bindings orderCharge_OrderProcessingCoordinator = orderCharge_PaymentProcessing ; delegations : httpServer_ProcessingOrderCoordinator to httpServer_ProcessingOrder dbClient_ProcessingOrderCoordinator to dbClient_ProcessingOrder dbClient_CheckDebts to dbClient_ProcessingOrder dbClient_PaymentProcessig to dbClient_ProcessingOrder } } boundary
	component def KitchenRoutingCP { ports : orderItems_Routing : OrderItemArrayIPT ; kitchenId_Routing : IntOPT ; }
	component def OrderProcessingCoordinatorCP { ports : httpServer_ProcessingOrderCoordinator : HTTPServiceP ; userId_CheckDebts_Coordinator : IntOPT ; hasDebts_Coordinator : BooleanIPT ; dbClient_ProcessingOrderCoordinator : DBClientP ; order_OrderProcessingCoordinator : OrderOPT ; orderProcessing_OrderProcessingCoordinator : OrderProcessingIPT ; orderCharge_OrderProcessingCoordinator : OrderChargeOPT ; paymentResult_OrderProcessingCoordinator : PaymentStatusIPT ; }
	component def AdditionalProcessingCP { ports : order_AdditionalProcessing : OrderIPT ; orderProcessing_AdditionalProcessing : OrderProcessingOPT ; configuration { components : AdditionalProcessingCoordinatorCP : AdditionalProcessingCoordinatorCP { using ports : orderProcessing_APCoordinator : OrderProcessingOPT ; orderItems_ToRouting : OrderItemArrayOPT ; orderItems_ToPricing : OrderItemArrayOPT ; kitchenId_ByRouting : IntIPT ; orderPrice_ByPricing : RealIPT ; order_APCoordinator : OrderIPT ; } KitchenRoutingCP : KitchenRoutingCP { using ports : orderItems_Routing : OrderItemArrayIPT ; kitchenId_Routing : IntOPT ; } PriceCalculationCP : PriceCalculationCP { using ports : orderItems_Pricing : OrderItemArrayIPT ; orderPrice_Pricing : RealOPT ; } connectors : kitchenId : IntCN bindings kitchenId_Routing = kitchenId_ByRouting ; ordersToRouting : OrderItemArrayCN bindings orderItems_ToRouting = orderItems_Routing ; orderPrice : RealCN bindings orderPrice_Pricing = orderPrice_ByPricing ; ordersToPricing : OrderItemArrayCN bindings orderItems_ToPricing = orderItems_Pricing ; delegations : order_APCoordinator to order_AdditionalProcessing orderProcessing_APCoordinator to orderProcessing_AdditionalProcessing } } boundary
	component def PaymentProcessingCP { ports : orderCharge_PaymentProcessing : OrderChargeIPT ; paymentResult_PaymentProcessing : PaymentStatusOPT ; dbClient_PaymentProcessig : DBClientP ; } boundary
	component def PriceCalculationCP { ports : orderItems_Pricing : OrderItemArrayIPT ; orderPrice_Pricing : RealOPT ; }
	component def AdditionalProcessingCoordinatorCP { ports : orderProcessing_APCoordinator : OrderProcessingOPT ; orderItems_ToRouting : OrderItemArrayOPT ; orderItems_ToPricing : OrderItemArrayOPT ; kitchenId_ByRouting : IntIPT ; orderPrice_ByPricing : RealIPT ; order_APCoordinator : OrderIPT ; } } 

package FoodFastPorts { 
	import SysADLTypes ;
	
	port def DBQueryIPT { 
		flow in DBQueryDT
	} 
	port def DBQueryOPT { 
		flow out DBQueryDT
	} 
	
	port def DBResponseIPT { 
		flow in DBResponseDT 
	} 
	port def DBResponseOPT { 
		flow out DBResponseDT
	} 
	
	port def DBServiceP { 
		ports : 
			queryIPT : DBQueryIPT ; 
			responseOPT : DBResponseOPT ;
	} 
	port def DBClientP { 
		ports : 
			queryOPT : DBQueryOPT ; 
			responseIPT : DBResponseIPT ;
	} 
	
	port def HTTPRequestIPT { 
		flow in HTTPRequestDT 
	} 
	port def HTTPRequestOPT { 
		flow out HTTPRequestDT
	} 
	
	port def HTTPResponseIPT { 
		flow in HTTPResponseDT 
	}
	port def HTTPResponseOPT { 
		flow out HTTPResponseDT
	} 
	
	port def HTTPServiceP {
		ports : 
			requestIPT : HTTPRequestIPT ; 
			responseOPT : HTTPResponseOPT ;
	} 
	port def HTTPClientP { 
		ports : 
			requestOPT : HTTPRequestOPT ;
			responseIPT : HTTPResponseIPT ;
	} 
	
	port def BiometricTypeIPT { 
		flow in BiometricTypeEnum
	} 
	port def BiometricTypeOPT { 
		flow out BiometricTypeEnum
	} 
	
	port def BiometricRawIPT {
		flow in BiometricRawDT
	} 
	port def BiometricRawOPT { 
		flow out BiometricRawDT
	} 
	
	port def UserIPT { 
		flow in UserDT
	} 
	port def UserOPT { 
		flow out UserDT
	} 
	
	port def BooleanIPT { 
		flow in Boolean
	} 
	port def BooleanOPT { 
		flow out Boolean
	} 
	
	port def SensorCN { 
		ports : 
			biometricType : BiometricRawOPT ; 
			biometriRaw : BiometricTypeIPT ;
	} 
	
	port def StringIPT { 
		flow in String
	} 
	port def StringOPT { 
		flow out String
	}
port def IntIPT { flow in Int } port def IntOPT { flow out Int } port def OrderIPT { flow in OrderDT } port def OrderOPT { flow out OrderDT } port def OrderProcessingIPT { flow in OrderProcessingDT } port def OrderProcessingOPT { flow out OrderProcessingDT } port def OrderItemArrayIPT { flow in OrderItemArrayDT } port def OrderItemArrayOPT { flow out OrderItemArrayDT } port def RealIPT { flow in Real } port def RealOPT { flow out Real } port def OrderChargeIPT { flow in OrderChargeDT } port def OrderChargeOPT { flow out OrderChargeDT } port def PaymentStatusIPT { flow in PaymentStatusEnum } port def PaymentStatusOPT { flow out PaymentStatusEnum } } 

Requirement ManageUsersFR ( 1 ) { 
	text = "\"O sistema deve permitir o gerenciamento de usuários.\""
	
	Requirement UpdateUserFR ( 1.2 ) { 
		text = "“O sistema deve permitir que o usuário atualize a conta no sistema com todos os dados necessários.”" 
		satisfied by FoodFastComponents.UserUpdateCP ; 
		
		Requirement RegisterPaymentMethodsFR_ForUpdate ( 1.2.2 ) { 
			text = "“O sistema deve permitir que o usuário atualize seus métodos de pagamento.”" 
		} 
		
		Requirement RegisterPersonalInfoFR_ForUpdate ( 1.2.1 ) { 
			text = "“O sistema deve permitir que o usuário atualize suas informações pessoais.”"
		}
	}
	
	Requirement RegisterUserFR ( 1.1 ) { 
		text = "“O sistema deve permitir que o usuário realize o cadastro no sistema com todos os dados necessários.”" 
		satisfied by FoodFastComponents.UserCreateCP ; 
		
		Requirement RegisterPersonalInfoFR_ForRegister ( 1.1.1 ) { 
			text = "“O sistema deve permitir que o usuário cadastre suas informações pessoais.”" 
		} 
		
		Requirement RegisterPaymentMethodsFR_ForRegister ( 1.1.2 ) { 
			text = "“O sistema deve permitir que o usuário cadastre seus métodos de pagamento.”" 
		}
	}
	
	Requirement RetrieveUserFR ( 1.3 ) { 
		text = "“O sistema deve permitir que o usuário visualize suas informações cadastradas.”"
		satisfied by FoodFastComponents.UserRetrieveCP ; 
	} 
	
	Requirement DeleteUserFR ( 1.4 ) { 
		text = "“O sistema deve permitir que o usuário remova sua conta.”"
		satisfied by FoodFastComponents.UserDeleteCP ; 
	} 

	Requirement LoginUserFR ( 1.5 ) { 
		text = "\"O sistema deve permitir que o usuário se autentique em sua conta com CPF e senha registrados.\""
		satisfied by FoodFastComponents.UserAuthCP ; 
	} 
} 

 
Requirement ManageBiometricDataFR ( 2 ) { 
	text = "\"O sistema deve permitir o gerenciamento dos dados biométricos dos usuários.\"" 
	
	Requirement RegisterBiometricDataFR ( 2.1 ) { 
		text = "\"O sistema deve permitir que o usuário registre seus dados biométricos no sistema.\""
		satisfied by FoodFastComponents.RegisterBiometricCP ; 
	} 
	
	Requirement RemoveBiometricDataFR ( 2.2 ) { 
		text = "\"O sistema deve permitir que o usuário remova seus dados biométricos cadastrados no sistema.\""
		satisfied by FoodFastComponents.RemoveBiometricCP ; 
	}
} 

 
Requirement FingerprintAuthenticationFR ( 3.1 ) {
	text = "\"O sistema deve permitir que o usuário realize autenticação utilizando sua impressão digital.\"" 
	derive OrderManagementFR.CreateOrderInMachineFR.AuthenticateBiometricFR ; 
	
	Requirement CaptureFingerprintFR ( 3.1.1 ) { 
		text = "\"O sistema deve capturar a impressão digital do usuário utilizando o sensor biométrico apropriado.\""
		satisfied by FoodFastComponents.FingerprintSensorCP ; 
	} 
	
	Requirement RecognizeFingerprintFR ( 3.1.2 ) { 
		text = "\"O sistema deve comparar a digital capturada com os dados biométricos registrados para validar a identidade do usuário.\""
		satisfied by FoodFastComponents.BiometricRecognitionCP ; 
	}
} 

Requirement FacialAuthenticationFR ( 3.2 ) { 
	text = "\"O sistema deve permitir que o usuário realize autenticação utilizando reconhecimento facial.\"" 
	derive OrderManagementFR.CreateOrderInMachineFR.AuthenticateBiometricFR ;
	
	Requirement CaptureFaceFR ( 3.2.1 ) { 
		text = "\"O sistema deve capturar a imagem facial do usuário utilizando a câmera disponibilizada pelo dispositivo.\""
		satisfied by FoodFastComponents.FaceCameraCP ; 
	} 
	
	Requirement RecognizeFaceFR ( 3.2.2 ) { 
		text = "\"O sistema deve comparar a imagem facial capturada com os dados biométricos registrados para validar a identidade do usuário.\""
		satisfied by FoodFastComponents.BiometricRecognitionCP ;
	}
}

Requirement OrderManagementFR ( 4 ) { 
	text = "\"O sistema deve permitir o gerenciamento completo dos pedidos realizados pelos usuários.\"" 
	
	Requirement UpdateOrderFR ( 4.3 ) { 
		text = "\"O sistema deve permitir que funcionários ou subsistemas responsáveis atualizem pedidos em processamento.\""
		satisfied by FoodFastComponents.UpdateOrderCP ; 
	}
	
	Requirement ViewOrderFR ( 4.2 ) { 
		text = "\"O sistema deve permitir que o usuário visualize seus pedidos.\""
		satisfied by FoodFastComponents.RetrieveOrderCP ; 
	} 
	
	Requirement CreateOrderInMachineFR ( 4.1 ) { 
		text = "\"O sistema deve permitir que o usuário crie pedidos em máquinas apropriadas, realizando o cálculo do valor devido conforme os itens selecionados.\"" 
		
		Requirement AuthenticateBiometricFR ( 3 ) { 
			text = "\"O sistema deve permitir que o usuário realize autenticação por biometria.\""
			derive OrderPickupFR.IdentifyUserForPickupFR.IdentifyPickupRequestFR ; 
		} 
	} 
	
	Requirement ProcessOrderFR ( 4.4 ) { 
		text = "\"O sistema deve processar pedidos conforme o tipo de máquina e o fluxo operacional necessário.\"" 
		
		Requirement ChargeOrderFR ( 4.4.1 ) { 
			text = "\"O sistema deve realizar a cobrança do pedido conforme o fluxo operacional da máquina utilizada, podendo ocorrer antes ou depois do uso, conforme as regras do tipo de pedido.\""
		} 
		
		Requirement CheckPendingPaymentsFR ( 4.4.2 ) { 
			text = "\"O sistema deve verificar se o usuário possui valores pendentes de pedidos anteriores que ainda não foram pagos, bloqueando a continuidade do processamento caso existam pendências.\""
		} 
		
		Requirement MachineSpecificProcessingFR ( 4.4.3 ) {
			text = "\"O sistema deve executar o processamento adicional específico ao tipo de máquina na qual o pedido foi realizado.\""
		}
	} 
} 

Requirement CreateOrderInTotenFR ( 4.1.1 ) { 
	text = "\"O sistema deve permitir que o usuário realize pedidos em totens, selecionando itens que serão preparados na cozinha.\"" 
	derive OrderManagementFR.CreateOrderInMachineFR ; 
	
	Requirement CheckItemAvailabilityFR ( 4.1.1.1 ) { 
		text = "\"O sistema deve verificar a disponibilidade dos itens selecionados antes de confirmar o pedido.\""
	} 
	
	Requirement GenerateOrderReceiptFR ( 4.1.1.2 ) { 
		text = "\"O sistema deve gerar a nota de compra contendo o número do pedido, a cozinha de roteamento e o código de barras para retirada.\""
	} 
	
	Requirement ChargeBeforeConfirmationFR ( 4.1.1.3 ) { 
		text = "\"O sistema deve realizar a cobrança do pedido antes da confirmação final.\""
	}
} 

Requirement ProcessOrderFromTotenFR ( 4.4.3.1 ) { 
	text = "\"O sistema deve processar pedidos realizados em totens, encaminhando-os para a cozinha adequada após a cobrança.\"" 
	derive OrderManagementFR.ProcessOrderFR.MachineSpecificProcessingFR ; 
	
	Requirement RouteOrderToKitchenFR ( 4.4.3.1.1 ) { 
		text = "\"O sistema deve encaminhar o pedido para a cozinha apropriada conforme sua categoria.\""
	}
}

Requirement ProcessOrderFromDrinkDispenserFR ( 4.4.3.2 ) { 
	text = "\"O sistema deve processar pedidos realizados em máquinas de bebidas prontas, liberando a bebida após a confirmação da cobrança.\"" 
	derive OrderManagementFR.ProcessOrderFR.MachineSpecificProcessingFR ;
} 

Requirement ProcessOrderFromSnackDispenserFR ( 4.4.3.3 ) { 
	text = "\"O sistema deve processar pedidos realizados em máquinas de lanches prontos, liberando o lanche após a confirmação da cobrança.\"" 
	derive OrderManagementFR.ProcessOrderFR.MachineSpecificProcessingFR ;
} 

Requirement ProcessOrderFromTapFR ( 4.4.3.4 ) { 
	text = "\"O sistema deve processar pedidos realizados em torneiras de bebidas cobradas por volume, finalizando o cálculo e cobrança após o uso.\"" 
	derive OrderManagementFR.ProcessOrderFR.MachineSpecificProcessingFR ; 
	
	Requirement CalculateFinalTapCostFR ( 4.4.3.4.1 ) { 
		text = "\"O sistema deve calcular o custo final do pedido com base no volume total de bebida consumido.\""
	}
} 

Requirement CreateOrderInDrinkDispenserFR ( 4.1.2 ) { 
	text = "\"O sistema deve permitir que o usuário realize pedidos em máquinas de bebidas prontas (dispenser).\"" 
	derive OrderManagementFR.CreateOrderInMachineFR ; 
	
	Requirement CheckDrinkAvailabilityFR ( 4.1.2.1 ) { 
		text = "\"O sistema deve verificar a disponibilidade da bebida selecionada antes de permitir a confirmação.\""
	} 
	
	Requirement ChargeBeforeConfirmationFR ( 4.1.2.2 ) { 
		text = "\"O sistema deve realizar a cobrança do pedido antes da liberação da bebida.\""
	}
} 

Requirement CreateOrderInSnackDispenserFR ( 4.1.3 ) { 
	text = "\"O sistema deve permitir que o usuário realize pedidos em máquinas de lanches prontos.\"" 
	derive OrderManagementFR.CreateOrderInMachineFR ; 
	
	Requirement CheckSnackAvailabilityFR ( 4.1.3.1 ) { 
		text = "\"O sistema deve verificar a disponibilidade do lanche selecionado antes de permitir a confirmação.\""
	} 
	
	Requirement ChargeBeforeConfirmationFR ( 4.1.3.2 ) { 
		text = "\"O sistema deve realizar a cobrança do pedido antes da liberação do lanche.\""
	}
} 

Requirement CreateOrderInTapFR ( 4.1.4 ) { 
	text = "\"O sistema deve permitir que o usuário realize pedidos em torneiras de bebidas cobradas por volume consumido.\"" 
	derive OrderManagementFR.CreateOrderInMachineFR ; 
	
	Requirement CheckTapAvailabilityFR ( 4.1.4.1 ) { 
		text = "\"O sistema deve verificar a disponibilidade da bebida na torneira antes ou durante o uso, conforme necessário.\""
	} 
	
	Requirement MeasureDispensedVolumeFR ( 4.1.4.2 ) { 
		text = "\"O sistema deve medir o volume de bebida dispensado, em mililitros, durante o uso.\""
	} 
	
	Requirement PostUseChargeFR ( 4.1.4.3 ) { 
		text = "\"O sistema deve realizar a cobrança do pedido somente após o término do uso.\""
	}
} 

Requirement OrderPickupFR ( 5 ) { 
	text = "“O sistema deve gerenciar todo o processo de retirada de pedidos utilizando a esteira automatizada, garantindo identificação segura do usuário, acesso controlado aos compartimentos e rastreabilidade completa do pedido.”" 
	
	Requirement ManageConveyorFR ( 5.1 ) { 
		text = "“O sistema deve gerenciar a esteira automatizada, organizando compartimentos, exibindo pedidos disponíveis e controlando o fluxo de entrega.”" 
		
		Requirement SeparateConveyorCompartmentsFR ( 5.1.1 ) { 
			text = "“O sistema deve organizar a esteira em compartimentos individuais para armazenamento dos pedidos prontos.”"
		} 
		
		Requirement DisplayPickupOrdersFR ( 5.1.2 ) { 
			text = "“O sistema deve exibir na interface da esteira todos os pedidos disponíveis, pendentes ou em preparação relacionados ao ponto de retirada.”"
		} 
		
		Requirement UpdatePickupOrderStatusFR ( 5.1.3 ) { 
			text = "“O sistema deve atualizar automaticamente o status do pedido de acordo com o fluxo da esteira e permitir ajustes pelos funcionários.”"
		}
	} 
	
	Requirement IdentifyUserForPickupFR ( 5.2 ) { 
		text = "“O sistema deve identificar qual pedido pertence ao usuário no ponto de retirada, utilizando mecanismos de autenticação biométrica ou código de barras.”" 
		
		Requirement IdentifyPickupRequestFR ( 5.2.1 ) { 
			text = "“O sistema deve identificar o pedido associado ao usuário por meio de autenticação informada, como biometria ou código de barras.”"
		} 
		
		Requirement VerifyPickupRequestFR ( 5.2.2 ) { 
			text = "“O sistema deve verificar se o identificador obtido corresponde a um pedido disponível e autorizado para retirada.”"
		}
	}
	
	Requirement LocatePickupOrderFR ( 5.3 ) { 
		text = "“O sistema deve localizar o compartimento onde o pedido identificado está armazenado.”"
	} 
	
	Requirement ProcessConveyorDeliveryFR ( 5.4 ) {
		text = "“O sistema deve executar as ações necessárias para entregar o pedido ao usuário, incluindo mover a esteira e abrir automaticamente o compartimento correspondente.”" 
		
		Requirement MoveConveyorToUserFR ( 5.4.1 ) { 
			text = "“O sistema deve mover a esteira até que o compartimento do pedido esteja posicionado em frente ao usuário identificado.”"
		} 
		
		Requirement OpenConveyorCompartmentFR ( 5.4.2 ) { 
			text = "“O sistema deve abrir automaticamente o compartimento correspondente ao pedido após a identificação válida do usuário.”"
		} 
		
		Requirement ConfirmOrderPickupFR ( 5.4.3 ) { 
			text = "“O sistema deve detectar quando o pedido foi retirado e registrar a conclusão da entrega.”"
		}
	} 
} 

Requirement IdentifyPickupByBarcodeFR ( 5.2.1.1 ) { 
	text = "“O sistema deve identificar o pedido do usuário utilizando o código de barras fornecido no momento da retirada.”" 
	derive OrderPickupFR.IdentifyUserForPickupFR.IdentifyPickupRequestFR ; 
	
	Requirement CapturePickupBarcodeFR ( 5.2.1.1.1 ) { 
		text = "“O sistema deve capturar o código de barras apresentado pelo usuário no ponto de retirada.”"
	} 
	
	Requirement InterpretPickupBarcodeFR ( 5.2.1.1.2 ) { 
		text = "“O sistema deve interpretar o código de barras capturado e extrair o identificador do pedido associado ao usuário.”"
	}
}

Requirement QualityNFR ( 6 ) { 
	text = "“O sistema deve atender requisitos robustos de segurança, desempenho, disponibilidade, usabilidade, escalabilidade e manutenibilidade, com níveis mensuráveis definidos nos NFRs relacionados.”" 
	
	Requirement SecurityNFR ( 6.1 ) { 
		text = "“O sistema deve implementar mecanismos de segurança que previnam acesso não autorizado, garantam criptografia dos dados sensíveis e minimizem riscos de fraude e erros de identificação.”" 
		
		Requirement DataSecurityNFR ( 6.1.1 ) { 
			text = "“Todos os dados sensíveis dos usuários, incluindo informações de pagamento, devem ser armazenados e transmitidos utilizando criptografia forte (mínimo AES-256 ou equivalente).”"
		} 
		
		Requirement FraudSecurityNFR ( 6.1.2 ) { 
			text = "“O sistema deve detectar e bloquear tentativas suspeitas de fraude durante os processos de autenticação e pagamento, registrando eventos para auditoria.”"
		} 
		
		Requirement RecognitionSecurityNFR ( 6.1.3 ) { 
			text = "“Os métodos de reconhecimento biométrico devem manter precisão elevada, minimizando falsos positivos e falsos negativos conforme métricas aceitas (FAR < 0.01%, FRR < 1%).”"
		}
	} 
	
	Requirement PerformanceNFR ( 6.2 ) { 
		text = "“O sistema deve realizar processamento de dados e atender requisições dentro dos tempos máximos especificados nos NFRs derivados.”" 
		
		Requirement RecognitionTimeNFR ( 6.2.1 ) { 
			text = "“O reconhecimento facial ou digital deve ser concluído em até 3 segundos, considerando captura + processamento.”"
		} 
		
		Requirement PaymentTimeNFR ( 6.2.2 ) {
			text = "“O sistema deve processar transações de pagamento com tempo de resposta inferior a 5 segundos para cada requisição.”"
		}
	} 
	
	Requirement AvailableNFR ( 6.3 ) { 
		text = "“O sistema deve manter disponibilidade mínima de 99,9% ao longo do ano, incluindo totens, máquinas de pedido e esteiras automatizadas.”" 
		
		Requirement MachineMonitoringNFR ( 6.3.1 ) { 
			text = "“Totens, máquinas e módulos de esteira devem ser monitorados constantemente para garantir que permaneçam operacionais, com alertas automáticos em caso de falhas.”"
		}
	} 
	
	Requirement UsabilityNFR ( 6.4 ) { 
		text = "“O sistema deve ser intuitivo e fácil de usar para públicos de diferentes idades e perfis, reduzindo a necessidade de intervenção humana.”" 
		
		Requirement AccessibilityNFR ( 6.4.1 ) {
			text = "“Os recursos do sistema devem ser acessíveis a usuários com deficiências auditivas, visuais, motoras ou cognitivas, seguindo diretrizes WCAG 2.1 AA.”" 
		} 
		
		Requirement ResponsivenessNFR ( 6.4.2 ) { 
			text = "“As interfaces do sistema devem ser responsivas e adaptáveis a diferentes tamanhos e orientações de tela, garantindo boa usabilidade em totens, dispositivos móveis e desktops.”"
		}
	} 
	
	Requirement ScalabilityNFR ( 6.5 ) { 
		text = "“O sistema deve suportar aumento de carga, expansão de dispositivos e adição de novas máquinas sem necessidade de alterações estruturais significativas.”"
	} 
	
	Requirement MaintainabilityNFR ( 6.6 ) { 
		text = "“O sistema deve possuir processos bem definidos de atualização, registro de erros e manutenção corretiva, permitindo intervenções rápidas sem comprometer a operação.”"
	}
} 

Requirement CompatibilityNFR ( 6.4.2.1 ) { 
	text = "“O sistema deve ser compatível com navegadores modernos e sistemas operacionais móveis (iOS e Android).”" 
	derive QualityNFR.UsabilityNFR.ResponsivenessNFR ;
} 

Requirement ProductManagementFR ( 7 ) { 
	text = "\"O sistema deve oferecer um conjunto integrado de funcionalidades para cadastrar, atualizar, consultar e remover produtos, além de permitir a verificação de disponibilidade conforme necessário para operação das máquinas.\"" 
	
	Requirement CreateProductFR ( 7.1 ) { 
		text = "\"O sistema deve permitir o cadastro de um novo produto contendo nome, descrição, categoria e preço, garantindo a persistência das informações.\""
		satisfied by FoodFastComponents.CreateProductCP ; 
	} 
	
	Requirement UpdateProductFR ( 7.2 ) { 
		text = "\"O sistema deve permitir a modificação dos dados de um produto previamente cadastrado, mantendo histórico consistente no banco de dados.\""
		satisfied by FoodFastComponents.UpdateProductCP ; 
	} 
	
	Requirement RetrieveProductFR ( 7.3 ) { 
		text = "\"O sistema deve permitir a consulta de produtos individualmente ou em conjunto, retornando informações essenciais como nome, descrição, categoria, preço e disponibilidade quando aplicável.\""
		satisfied by FoodFastComponents.RetrieveProductCP ; 
	} 
	
	Requirement DeleteProductFR ( 7.4 ) { 
		text = "\"O sistema deve permitir a remoção de um produto do catálogo, garantindo que os dados sejam excluídos de forma consistente.\""
		satisfied by FoodFastComponents.DeleteProductCP ; 
	} 
	
	Requirement CheckProductAvailabilityFR ( 7.5 ) { 
		text = "\"O sistema deve permitir a verificação da disponibilidade de um produto, considerando informações provenientes de estoque interno ou processamento em máquinas específicas.\""
		satisfied by FoodFastComponents.CheckAvailabilityProductCP ; 
	}
}